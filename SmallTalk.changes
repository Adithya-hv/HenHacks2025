----QUIT----2025-02-24T15:41:46.745188+01:00 Pharo11-SNAPSHOT-64bit-cf2c3fee23.image priorSource: 0!----QUIT----2025-02-24T15:41:46.745993+01:00 Pharo11-SNAPSHOT-64bit-cf2c3fee23.image priorSource: 0!----QUIT----2025-02-24T15:42:05.491074+01:00 Pharo11-SNAPSHOT-64bit-cf2c3fee23.image priorSource: 102!----QUIT----2025-02-24T15:42:05.492756+01:00 Pharo11-SNAPSHOT-64bit-cf2c3fee23.image priorSource: 204!!BaselineOfSQLite3 commentStamp: '' prior: 0!A baseline for SQlite3 support in Pharo!!BaselineOfSQLite3 methodsFor: 'baselines'!baseline: spec	<baseline>	spec		for: #pharo		do: [ 			self setUpDependencies: spec.			spec				package: 'SQLite3-Core';				group: 'Core' with: 'SQLite3-Core';				package: 'SQLite3-Core-Benchmarks' with: [ spec requires: 'SQLite3-Core' ];				group: 'Benchmarks' with: 'SQLite3-Core-Benchmarks';								package: 'SQLite3-Core-Tests' with: [ spec requires: 'Core' ];				group: 'Tests' with: 'SQLite3-Core-Tests';								package: 'SQLite3-Glorp' with: [ spec requires: #('Core' 'Glorp-Core') ];				group: 'glorp' with: 'SQLite3-Glorp';								package: 'SQLite3-Glorp-Tests' with: [ spec requires: #('SQLite3-Glorp' 'Glorp-Tests')  ];				group: 'Tools' with: #().			spec				group: 'CI' with: #('SQLite3-Glorp-Tests' 'Tests');				group: 'all' with: #('Core' 'Tests' 'Benchmarks' 'Tools');				group: 'default' with: #('all')			].	self versionSpecificBaseline: spec.! !!BaselineOfSQLite3 methodsFor: 'baselines'!projectClass	^ MetacelloCypressBaselineProject! !!BaselineOfSQLite3 methodsFor: 'baselines'!setUpDependencies: spec	spec		baseline: 'Glorp' with: [ spec repository: 'github://pharo-rdbms/glorp/' ];		project: 'Glorp-Core' copyFrom: 'Glorp' with: [ spec loads: 'Core' ];		project: 'Glorp-Tests' copyFrom: 'Glorp' with: [ spec loads: 'Glorp-Integration-Tests' ]! !!BaselineOfSQLite3 methodsFor: 'baselines'!versionSpecificBaseline: spec	"Add version specific packages to the spec"	spec for: #( #'pharo7.x' #'pharo8.x' ) do: [ 		spec			package: 'SQLite3-Pharo8';			group: 'Core' with: 'SQLite3-Pharo8'		].	spec for: #( #'pharo9.x' #'pharo10.x' #'pharo11.x' #'pharo12.x' ) do: [ 		spec			package: 'SQLite3-Pharo9';			group: 'Core' with: 'SQLite3-Pharo9'		].	spec for: #( #'pharo10.x' #'pharo11.x' #'pharo12.x' ) do: [ 		spec			package: 'SQLite3-Pharo10';			group: 'Core' with: 'SQLite3-Pharo10'.		spec			package: 'SQLite3-Inspector-Extensions' with: [ spec requires: #( 'Core' ) ];			group: 'Tools' with: 'SQLite3-Inspector-Extensions'		]! !"BaselineOfSQLite3"!!SQLite3BackupExternalReference commentStamp: '' prior: 0!I represent the SQLite API 'sqlite3_backup' C-level type.!!SQLite3DatabaseExternalObject commentStamp: '' prior: 0!I represent the SQLite API 'sqlite3' C-level type.!!SQLite3StatementExternalObject commentStamp: '' prior: 0!I represent the SQLite API 'sqlite3_stmt' C-level type.!!SQLite3AbstractError commentStamp: '' prior: 0!I represent an SQLite non-ok condition.!!SQLite3NotOpen commentStamp: '' prior: 0!I am signalled when operations are invoked on a database that is not open.!!SQLite3Backup commentStamp: '' prior: 0!I represent a SQLite backup operation.This is detailed at https://sqlite.org/c3ref/backup_finish.html#sqlite3backupinit!!SQLite3BaseConnection commentStamp: '' prior: 0!I represent a connection to an SQLite database. I provide a thin wrapper over the SQLite C API.Do not use this class directly, please check and use my subclass SQLite3Connection!!SQLite3Connection commentStamp: '' prior: 0!I represent a connection to an SQLite database.!!SQLite3Column commentStamp: '' prior: 0!I represent a column in a table!!SQLite3Database commentStamp: '' prior: 0!An SQLite3 database!!SQLite3Row commentStamp: '' prior: 0!I represent a row of results returned by the database.!!SQLite3Table commentStamp: '' prior: 0!A table within a SQLite3 database!!SQLite3Constants commentStamp: '' prior: 0!I provide SQLIte's constants.!!SQLite3Cursor commentStamp: '' prior: 0!I represent a set of results returned by the database. I produce UDBCSQLite3Row instances lazily.!!SQLite3Library commentStamp: '' prior: 0!I am the (unified) FFI interface to SQLite.!!SQLite3NativeError commentStamp: '' prior: 0!Common subclass for errors corresponding to a native SQLite3 C library error code.Typically one uses this class to create and access instances of subclasses:  	(SQLite3NativeError forNativeErrorCode: SQLITE_INTERRUPT  messageText: 'Interrupted') signal!!SQLite3Abort commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_ABORT result code indicates that an operation was aborted prior to completion, usually be application request. See also: SQLITE_INTERRUPT.If the callback function to sqlite3_exec() returns non-zero, then sqlite3_exec() will return SQLITE_ABORT.If a ROLLBACK operation occurs on the same database connection as a pending read or write, then the pending read or write may fail with an SQLITE_ABORT or SQLITE_ABORT_ROLLBACK error.In addition to being a result code, the SQLITE_ABORT value is also used as a conflict resolution mode returned from the sqlite3_vtab_on_conflict() interface.!!SQLite3AbortRollback commentStamp: '' prior: 0!The SQLITE_ABORT_ROLLBACK error code is an extended error code for SQLITE_ABORT indicating that an SQL statement aborted because the transaction that was active when the SQL statement first started was rolled back. Pending write operations always fail with this error when a rollback occurs. A ROLLBACK will cause a pending read operation to fail only if the schema was changed within the transaction being rolled back.!!SQLite3AuthorizationDenied commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_AUTH error is returned when the authorizer callback indicates that an SQL statement being prepared is not authorized.!!SQLite3Busy commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_BUSY result code indicates that the database file could not be written (or in some cases read) because of concurrent activity by some other database connection, usually a database connection in a separate process.For example, if process A is in the middle of a large write transaction and at the same time process B attempts to start a new write transaction, process B will get back an SQLITE_BUSY result because SQLite only supports one writer at a time. Process B will need to wait for process A to finish its transaction before starting a new transaction. The sqlite3_busy_timeout() and sqlite3_busy_handler() interfaces and the busy_timeout pragma are available to process B to help it deal with SQLITE_BUSY errors.An SQLITE_BUSY error can occur at any point in a transaction: when the transaction is first started, during any write or update operations, or when the transaction commits. To avoid encountering SQLITE_BUSY errors in the middle of a transaction, the application can use BEGIN IMMEDIATE instead of just BEGIN to start a transaction. The BEGIN IMMEDIATE command might itself return SQLITE_BUSY, but if it succeeds, then SQLite guarantees that no subsequent operations on the same database through the next COMMIT will return SQLITE_BUSY.See also: SQLITE_BUSY_RECOVERY and SQLITE_BUSY_SNAPSHOT.The SQLITE_BUSY result code differs from SQLITE_LOCKED in that SQLITE_BUSY indicates a conflict with a separate database connection, probably in a separate process, whereas SQLITE_LOCKED indicates a conflict within the same database connection (or sometimes a database connection with a shared cache).!!SQLite3BusyRecovery commentStamp: '' prior: 0!The SQLITE_BUSY_RECOVERY error code is an extended error code for SQLITE_BUSY that indicates that an operation could not continue because another process is busy recovering a WAL mode database file following a crash. The SQLITE_BUSY_RECOVERY error code only occurs on WAL mode databases.!!SQLite3BusySnapshot commentStamp: '' prior: 0!The SQLITE_BUSY_SNAPSHOT error code is an extended error code for SQLITE_BUSY that occurs on WAL mode databases when a database connection tries to promote a read transaction into a write transaction but finds that another database connection has already written to the database and thus invalidated prior reads.The following scenario illustrates how an SQLITE_BUSY_SNAPSHOT error might arise:1. Process A starts a read transaction on the database and does one or more SELECT statement. Process A keeps the transaction open.2. Process B updates the database, changing values previous read by process A.3. Process A now tries to write to the database. But process A's view of the database content is now obsolete because process B has modified the database file after process A read from it. Hence process A gets an SQLITE_BUSY_SNAPSHOT error.!!SQLite3CantOpen commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_CANTOPEN result code indicates that SQLite was unable to open a file. The file in question might be a primary database file or one of several temporary disk files.!!SQLite3CantOpenConvertPath commentStamp: '' prior: 0!The SQLITE_CANTOPEN_CONVPATH error code is an extended error code for SQLITE_CANTOPEN used only by Cygwin VFS and indicating that the cygwin_conv_path() system call failed while trying to open a file. See also: SQLITE_IOERR_CONVPATH!!SQLite3CantOpenFullPath commentStamp: '' prior: 0!The SQLITE_CANTOPEN_FULLPATH error code is an extended error code for SQLITE_CANTOPEN indicating that a file open operation failed because the operating system was unable to convert the filename into a full pathname.!!SQLite3CantOpenIsDir commentStamp: '' prior: 0!The SQLITE_CANTOPEN_ISDIR error code is an extended error code for SQLITE_CANTOPEN indicating that a file open operation failed because the file is really a directory.!!SQLite3CantOpenNoTempDir commentStamp: '' prior: 0!The SQLITE_CANTOPEN_NOTEMPDIR error code is no longer used.!!SQLite3ConstraintViolation commentStamp: '' prior: 0!The SQLITE_CONSTRAINT error code means that an SQL constraint violation occurred while trying to process an SQL statement. Additional information about the failed constraint can be found by consulting the accompanying error message (returned via sqlite3_errmsg() or sqlite3_errmsg16()) or by looking at the extended error code.The SQLITE_CONSTRAINT code can also be used as the return value from the xBestIndex() method of a virtual table implementation. When xBestIndex() returns SQLITE_CONSTRAINT, that indicates that the particular combination of inputs submitted to xBestIndex() cannot result in a usable query plan and should not be given further consideration.!!SQLite3ConstraintViolationCheck commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_CHECK error code is an extended error code for SQLITE_CONSTRAINT indicating that a CHECK constraint failed.!!SQLite3ConstraintViolationCommitHook commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_COMMITHOOK error code is an extended error code for SQLITE_CONSTRAINT indicating that a commit hook callback returned non-zero that thus caused the SQL statement to be rolled back.!!SQLite3ConstraintViolationForeignKey commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_FOREIGNKEY error code is an extended error code for SQLITE_CONSTRAINT indicating that a foreign key constraint failed.!!SQLite3ConstraintViolationFunction commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_FUNCTION error code is not currently used by the SQLite core. However, this error code is available for use by extension functions.!!SQLite3ConstraintViolationNotNull commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_NOTNULL error code is an extended error code for SQLITE_CONSTRAINT indicating that a NOT NULL constraint failed.!!SQLite3ConstraintViolationPrimaryKey commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_PRIMARYKEY error code is an extended error code for SQLITE_CONSTRAINT indicating that a PRIMARY KEY constraint failed.!!SQLite3ConstraintViolationRowID commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_ROWID error code is an extended error code for SQLITE_CONSTRAINT indicating that a rowid is not unique.!!SQLite3ConstraintViolationTrigger commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_TRIGGER error code is an extended error code for SQLITE_CONSTRAINT indicating that a RAISE function within a trigger fired, causing the SQL statement to abort.!!SQLite3ConstraintViolationUnique commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_UNIQUE error code is an extended error code for SQLITE_CONSTRAINT indicating that a UNIQUE constraint failed.!!SQLite3ConstraintViolationVirtualTable commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_VTAB error code is not currently used by the SQLite core. However, this error code is available for use by application-defined virtual tables.!!SQLite3Corrupt commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_CORRUPT result code indicates that the database file has been corrupted. See the How To Corrupt Your Database Files for further discussion on how corruption can occur.!!SQLite3CorruptVirtualTable commentStamp: '' prior: 0!The SQLITE_CORRUPT_VTAB error code is an extended error code for SQLITE_CORRUPT used by virtual tables. A virtual table might return SQLITE_CORRUPT_VTAB to indicate that content in the virtual table is corrupt.!!SQLite3Empty commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_EMPTY result code is not currently used.!!SQLite3Error commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_ERROR result code is a generic error code that is used when no other more specific error code is available.!!SQLite3Format commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_FORMAT result code is not currently used.!!SQLite3Full commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_FULL result code indicates that a write could not complete because the disk is full. Note that this error can occur when trying to write information into the main database file, or it can also occur when writing into temporary disk files.Sometimes applications encounter this error even though there is an abundance of primary disk space because the error occurs when writing into temporary disk files on a system where temporary files are stored on a separate partition with much less space that the primary disk.!!SQLite3IOError commentStamp: '' prior: 0!The SQLITE_IOERR result code says that the operation could not finish because the operating system reported an I/O error.A full disk drive will normally give an SQLITE_FULL error rather than an SQLITE_IOERR error.There are many different extended result codes for I/O errors that identify the specific I/O operation that failed.!!SQLite3IOErrorAccess commentStamp: '' prior: 0!The SQLITE_IOERR_ACCESS error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xAccess method on the sqlite3_vfs object.!!SQLite3IOErrorBlocked commentStamp: '' prior: 0!The SQLITE_IOERR_BLOCKED error code is no longer used.!!SQLite3IOErrorCheckReservedLock commentStamp: '' prior: 0!The SQLITE_IOERR_CHECKRESERVEDLOCK error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xCheckReservedLock method on the sqlite3_io_methods object.!!SQLite3IOErrorClose commentStamp: '' prior: 0!The SQLITE_IOERR_CLOSE error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xClose method on the sqlite3_io_methods object.!!SQLite3IOErrorConvertPath commentStamp: '' prior: 0!The SQLITE_IOERR_CONVPATH error code is an extended error code for SQLITE_IOERR used only by Cygwin VFS and indicating that the cygwin_conv_path() system call failed. See also: SQLITE_CANTOPEN_CONVPATH!!SQLite3IOErrorDelete commentStamp: '' prior: 0!The SQLITE_IOERR_DELETE error code is an extended error code for SQLITE_IOERR indicating an I/O error within xDelete method on the sqlite3_vfs object.!!SQLite3IOErrorDeleteNoEntry commentStamp: '' prior: 0!The SQLITE_IOERR_DELETE_NOENT error code is an extended error code for SQLITE_IOERR indicating that the xDelete method on the sqlite3_vfs object failed because the file being deleted does not exist.!!SQLite3IOErrorDirClose commentStamp: '' prior: 0!The SQLITE_IOERR_DIR_CLOSE error code is no longer used.!!SQLite3IOErrorDirFSync commentStamp: '' prior: 0!The SQLITE_IOERR_DIR_FSYNC error code is an extended error code for SQLITE_IOERR indicating an I/O error in the VFS layer while trying to invoke fsync() on a directory. The unix VFS attempts to fsync() directories after creating or deleting certain files to ensure that those files will still appear in the filesystem following a power loss or system crash. This error code indicates a problem attempting to perform that fsync().!!SQLite3IOErrorFStat commentStamp: '' prior: 0!The SQLITE_IOERR_FSTAT error code is an extended error code for SQLITE_IOERR indicating an I/O error in the VFS layer while trying to invoke fstat() (or the equivalent) on a file in order to determine information such as the file size or access permissions.!!SQLite3IOErrorFSync commentStamp: '' prior: 0!The SQLITE_IOERR_FSYNC error code is an extended error code for SQLITE_IOERR indicating an I/O error in the VFS layer while trying to flush previously written content out of OS and/or disk-control buffers and into persistent storage. In other words, this code indicates a problem with the fsync() system call in unix or the FlushFileBuffers() system call in windows.!!SQLite3IOErrorGetTempPath commentStamp: '' prior: 0!The SQLITE_IOERR_GETTEMPPATH error code is an extended error code for SQLITE_IOERR indicating that the VFS is unable to determine a suitable directory in which to place temporary files.!!SQLite3IOErrorLock commentStamp: '' prior: 0!The SQLITE_IOERR_LOCK error code is an extended error code for SQLITE_IOERR indicating an I/O error in the advisory file locking logic. Usually an SQLITE_IOERR_LOCK error indicates a problem obtaining a PENDING lock. However it can also indicate miscellaneous locking errors on some of the specialized VFSes used on Macs.!!SQLite3IOErrorMemoryMap commentStamp: '' prior: 0!The SQLITE_IOERR_MMAP error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xFetch or xUnfetch methods on the sqlite3_io_methods object while trying to map or unmap part of the database file into the process address space.!!SQLite3IOErrorNoMemory commentStamp: '' prior: 0!The SQLITE_IOERR_NOMEM error code is sometimes returned by the VFS layer to indicate that an operation could not be completed due to the inability to allocate sufficient memory. This error code is normally converted into SQLITE_NOMEM by the higher layers of SQLite before being returned to the application.!!SQLite3IOErrorRead commentStamp: '' prior: 0!The SQLITE_IOERR_READ error code is an extended error code for SQLITE_IOERR indicating an I/O error in the VFS layer while trying to read from a file on disk. This error might result from a hardware malfunction or because a filesystem came unmounted while the file was open.!!SQLite3IOErrorReadLock commentStamp: '' prior: 0!The SQLITE_IOERR_RDLOCK error code is an extended error code for SQLITE_IOERR indicating an I/O error within xLock method on the sqlite3_io_methods object while trying to obtain a read lock.!!SQLite3IOErrorSeek commentStamp: '' prior: 0!The SQLITE_IOERR_SEEK error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xRead or xWrite methods on the sqlite3_io_methods object while trying to seek a file descriptor to the beginning point of the file where the read or write is to occur.!!SQLite3IOErrorSharedMemoryError commentStamp: '' prior: 0!Abstract superclass for extended errors on shared memory access in SQlite3!!SQLite3IOErrorSharedMemoryLock commentStamp: '' prior: 0!The SQLITE_IOERR_SHMLOCK error code is no longer used.!!SQLite3IOErrorSharedMemoryMap commentStamp: '' prior: 0!The SQLITE_IOERR_SHMMAP error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xShmMap method on the sqlite3_io_methods object while trying to map a shared memory segment into the process address space.!!SQLite3IOErrorSharedMemoryOpen commentStamp: '' prior: 0!The SQLITE_IOERR_SHMOPEN error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xShmMap method on the sqlite3_io_methods object while trying to open a new shared memory segment.!!SQLite3IOErrorSharedMemorySize commentStamp: '' prior: 0!The SQLITE_IOERR_SHMSIZE error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xShmMap method on the sqlite3_io_methods object while trying to enlarge a "shm" file as part of WAL mode transaction processing. This error may indicate that the underlying filesystem volume is out of space.!!SQLite3IOErrorShortRead commentStamp: '' prior: 0!The SQLITE_IOERR_SHORT_READ error code is an extended error code for SQLITE_IOERR indicating that a read attempt in the VFS layer was unable to obtain as many bytes as was requested. This might be due to a truncated file.!!SQLite3IOErrorTruncate commentStamp: '' prior: 0!The SQLITE_IOERR_TRUNCATE error code is an extended error code for SQLITE_IOERR indicating an I/O error in the VFS layer while trying to truncate a file to a smaller size.!!SQLite3IOErrorUnlock commentStamp: '' prior: 0!The SQLITE_IOERR_UNLOCK error code is an extended error code for SQLITE_IOERR indicating an I/O error within xUnlock method on the sqlite3_io_methods object.!!SQLite3IOErrorWrite commentStamp: '' prior: 0!The SQLITE_IOERR_WRITE error code is an extended error code for SQLITE_IOERR indicating an I/O error in the VFS layer while trying to write into a file on disk. This error might result from a hardware malfunction or because a filesystem came unmounted while the file was open. This error should not occur if the filesystem is full as there is a separate error code (SQLITE_FULL) for that purpose.!!SQLite3Internal commentStamp: '' prior: 0!The SQLITE_INTERNAL result code indicates an internal malfunction. In a working version of SQLite, an application should never see this result code. If application does encounter this result code, it shows that there is a bug in the database engine.SQLite does not currently generate this result code. However, application-defined SQL functions or virtual tables, or VFSes, or other extensions might cause this result code to be returned.!!SQLite3Interrupt commentStamp: '' prior: 0!The SQLITE_INTERRUPT result code indicates that an operation was interrupted by the sqlite3_interrupt() interface. See also: SQLITE_ABORT!!SQLite3Locked commentStamp: '' prior: 0!The SQLITE_LOCKED result code indicates that a write operation could not continue because of a conflict within the same database connection or a conflict with a different database connection that uses a shared cache.For example, a DROP TABLE statement cannot be run while another thread is reading from that table on the same database connection because dropping the table would delete the table out from under the concurrent reader.The SQLITE_LOCKED result code differs from SQLITE_BUSY in that SQLITE_LOCKED indicates a conflict on the same database connection (or on a connection with a shared cache) whereas SQLITE_BUSY indicates a conflict with a different database connection, probably in a different process.!!SQLite3LockedSharedCache commentStamp: '' prior: 0!The SQLITE_LOCKED_SHAREDCACHE error code is an extended error code for SQLITE_LOCKED indicating that the locking conflict has occurred due to contention with a different database connection that happens to hold a shared cache with the database connection to which the error was returned. For example, if the other database connection is holding an exclusive lock on the database, then the database connection that receives this error will be unable to read or write any part of the database file unless it has the read_uncommitted pragma enabled.The SQLITE_LOCKED_SHARECACHE error code works very much like the SQLITE_BUSY error code except that SQLITE_LOCKED_SHARECACHE is for separate database connections that share a cache whereas SQLITE_BUSY is for the much more common case of separate database connections that do not share the same cache. Also, the sqlite3_busy_handler() and sqlite3_busy_timeout() interfaces do not help in resolving SQLITE_LOCKED_SHAREDCACHE conflicts.!!SQLite3LogNotice commentStamp: '' prior: 0!The SQLITE_NOTICE result code is not returned by any C/C++ interface. However, SQLITE_NOTICE (or rather one of its extended error codes) is sometimes used as the first argument in an sqlite3_log() callback to indicate that an unusual operation is taking place.!!SQLite3LogNoticeRecoverRollback commentStamp: '' prior: 0!The SQLITE_NOTICE_RECOVER_ROLLBACK result code is passed to the callback of sqlite3_log() when a hot journal is rolled back.!!SQLite3LogNoticeRecoverWriteAheadLogging commentStamp: '' prior: 0!The SQLITE_NOTICE_RECOVER_WAL result code is passed to the callback of sqlite3_log() when a WAL mode database file is recovered.!!SQLite3LogWarning commentStamp: '' prior: 0!The SQLITE_WARNING result code is not returned by any C/C++ interface. However, SQLITE_WARNING (or rather one of its extended error codes) is sometimes used as the first argument in an sqlite3_log() callback to indicate that an unusual and possibly ill-advised operation is taking place.!!SQLite3LogWarningAutoIndex commentStamp: '' prior: 0!The SQLITE_WARNING_AUTOINDEX result code is passed to the callback of sqlite3_log() whenever automatic indexing is used. This can serve as a warning to application designers that the database might benefit from additional indexes.!!SQLite3Mismatch commentStamp: '' prior: 0!The SQLITE_MISMATCH error code indicates a datatype mismatch.SQLite is normally very forgiving about mismatches between the type of a value and the declared type of the container in which that value is to be stored. For example, SQLite allows the application to store a large BLOB in a column with a declared type of BOOLEAN. But in a few cases, SQLite is strict about types. The SQLITE_MISMATCH error is returned in those few cases when the types do not match.The rowid of a table must be an integer. Attempt to set the rowid to anything other than an integer (or a NULL which will be automatically converted into the next available integer rowid) results in an SQLITE_MISMATCH error.!!SQLite3Misuse commentStamp: '' prior: 0!The SQLITE_MISUSE return code might be returned if the application uses any SQLite interface in a way that is undefined or unsupported. For example, using a prepared statement after that prepared statement has been finalized might result in an SQLITE_MISUSE error.SQLite tries to detect misuse and report the misuse using this result code. However, there is no guarantee that the detection of misuse will be successful. Misuse detection is probabilistic. Applications should never depend on an SQLITE_MISUSE return value.If SQLite ever returns SQLITE_MISUSE from any interface, that means that the application is incorrectly coded and needs to be fixed. Do not ship an application that sometimes returns SQLITE_MISUSE from a standard SQLite interface because that application contains potentially serious bugs.!!SQLite3NoLargeFileSupport commentStamp: '' prior: 0!The SQLITE_NOLFS error can be returned on systems that do not support large files when the database grows to be larger than what the filesystem can handle. "NOLFS" stands for "NO Large File Support".!!SQLite3NoMemory commentStamp: '' prior: 0!The SQLITE_NOMEM result code indicates that SQLite was unable to allocate all the memory it needed to complete the operation. In other words, an internal call to sqlite3_malloc() or sqlite3_realloc() has failed in a case where the memory being allocated was required in order to continue the operation.!!SQLite3NotADatabase commentStamp: '' prior: 0!When attempting to open a file, the SQLITE_NOTADB error indicates that the file being opened does not appear to be an SQLite database file.!!SQLite3NotFound commentStamp: '' prior: 0!The SQLITE_NOTFOUND result code is used in two contexts. SQLITE_NOTFOUND can be returned by the sqlite3_file_control() interface to indicate that the file control opcode passed as the third argument was not recognized by the underlying VFS. SQLITE_NOTFOUND can also be returned by the xSetSystemCall() method of an sqlite3_vfs object.The SQLITE_NOTFOUND result code is also used internally by the SQLite implementation, but those internal uses are not exposed to the application.!!SQLite3OutOfRange commentStamp: '' prior: 0!The SQLITE_RANGE error indices that the parameter number argument to one of the sqlite3_bind routines or the column number in one of the sqlite3_column routines is out of range.!!SQLite3Permission commentStamp: '' prior: 0!The SQLITE_PERM result code indicates that the requested access mode for a newly created database could not be provided.!!SQLite3Protocol commentStamp: '' prior: 0!The SQLITE_PROTOCOL result code indicates a problem with the file locking protocol used by SQLite. The SQLITE_PROTOCOL error is currently only returned when using WAL mode and attempting to start a new transaction. There is a race condition that can occur when two separate database connections both try to start a transaction at the same time in WAL mode. The loser of the race backs off and tries again, after a brief delay. If the same connection loses the locking race dozens of times over a span of multiple seconds, it will eventually give up and return SQLITE_PROTOCOL. The SQLITE_PROTOCOL error should appear in practice very, very rarely, and only when there are many separate processes all competing intensely to write to the same database.!!SQLite3ReadOnly commentStamp: '' prior: 0!The SQLITE_READONLY result code is returned when an attempt is made to alter some data for which the current database connection does not have write permission.!!SQLite3ReadOnlyCantLock commentStamp: '' prior: 0!The SQLITE_READONLY_CANTLOCK error code is an extended error code for SQLITE_READONLY. The SQLITE_READONLY_CANTLOCK error code indicates that SQLite is unable to obtain a read lock on a WAL mode database because the shared-memory file associated with that database is read-only.!!SQLite3ReadOnlyDBMoved commentStamp: '' prior: 0!The SQLITE_READONLY_DBMOVED error code is an extended error code for SQLITE_READONLY. The SQLITE_READONLY_DBMOVED error code indicates that a database cannot be modified because the database file has been moved since it was opened, and so any attempt to modify the database might result in database corruption if the processes crashes because the rollback journal would not be correctly named.!!SQLite3ReadOnlyRecovery commentStamp: '' prior: 0!The SQLITE_READONLY_RECOVERY error code is an extended error code for SQLITE_READONLY. The SQLITE_READONLY_RECOVERY error code indicates that a WAL mode database cannot be opened because the database file needs to be recovered and recovery requires write access but only read access is available.!!SQLite3ReadOnlyRollback commentStamp: '' prior: 0!The SQLITE_READONLY_ROLLBACK error code is an extended error code for SQLITE_READONLY. The SQLITE_READONLY_ROLLBACK error code indicates that a database cannot be opened because it has a hot journal that needs to be rolled back but cannot because the database is readonly.!!SQLite3SchemaChanged commentStamp: '' prior: 0!The SQLITE_SCHEMA result code indicates that the database schema has changed. This result code can be returned from sqlite3_step() for a prepared statement that was generated using sqlite3_prepare() or sqlite3_prepare16(). If the database schema was changed by some other process in between the time that the statement was prepared and the time the statement was run, this error can result.If a prepared statement is generated from sqlite3_prepare_v2() then the statement is automatically re-prepared if the schema changes, up to SQLITE_MAX_SCHEMA_RETRY times (default: 50). The sqlite3_step() interface will only return SQLITE_SCHEMA back to the application if the failure persists after these many retries.!!SQLite3TooBig commentStamp: '' prior: 0!The SQLITE_TOOBIG error code indicates that a string or BLOB was too large. The default maximum length of a string or BLOB in SQLite is 1,000,000,000 bytes. This maximum length can be changed at compile-time using the SQLITE_MAX_LENGTH compile-time option, or at run-time using the sqlite3_limit(db,SQLITE_LIMIT_LENGTH,...) interface. The SQLITE_TOOBIG error results when SQLite encounters a string or BLOB that exceeds the compile-time or run-time limit.The SQLITE_TOOBIG error code can also result when an oversized SQL statement is passed into one of the sqlite3_prepare_v2() interfaces. The maximum length of an SQL statement defaults to a much smaller value of 1,000,000 bytes. The maximum SQL statement length can be set at compile-time using SQLITE_MAX_SQL_LENGTH or at run-time using sqlite3_limit(db,SQLITE_LIMIT_SQL_LENGTH,...).!!SQLite3PreparedStatement commentStamp: '' prior: 0!I represent an SQLite prepared statement.!!SQLite3Result commentStamp: '' prior: 0!I am an abstract superclass for corresponding classes to result codes created by SQLite3 C library.Subclasses should not be instantiated directly. Instead use #forNativeResultCode: with a valid result constant.   SQLite3Result forNativeResultCode: SQLITE_OK!!SQLite3DoneResult commentStamp: '' prior: 0!The SQLITE_DONE result code indicates that an operation has completed. The SQLITE_DONE result code is most commonly seen as a return value from sqlite3_step() indicating that the SQL statement has run to completion. But SQLITE_DONE can also be returned by other multi-step interfaces such as sqlite3_backup_step().!!SQLite3OKResult commentStamp: '' prior: 0!The SQLITE_OK result code means that the operation was successful and that there were no errors. Most other result codes indicate an error.!!SQLite3RowResult commentStamp: '' prior: 0!The SQLITE_ROW result code returned by sqlite3_step() indicates that another row of output is available.!!FFIExternalReference methodsFor: '*SQLite3-Core'!manualRelease	FFIExternalResourceManager uniqueInstance removeResource: self! !!SQLite3BackupExternalReference methodsFor: 'initialization'!beNull	^ handle beNull! !!SQLite3DatabaseExternalObject class methodsFor: 'instance finalization'!doFinalizeResourceData: resourceData	SQLite3Library current ffiCall:		#( int sqlite3_close_v2 #( void * resourceData ) )! !!SQLite3DatabaseExternalObject class methodsFor: 'finalization'!finalizeResourceData: aHandle	self doFinalizeResourceData: aHandle.	aHandle beNull! !!SQLite3DatabaseExternalObject methodsFor: 'initialization'!beNull	^ handle beNull! !!SQLite3StatementExternalObject class methodsFor: 'instance finalization'!doFinalizeResourceData: aHandle	SQLite3Library current ffiCall:		#( int sqlite3_finalize #( void * aHandle ) )! !!SQLite3StatementExternalObject class methodsFor: 'finalization'!finalizeResourceData: aHandle	self doFinalizeResourceData: aHandle.	aHandle beNull! !!SQLite3StatementExternalObject methodsFor: 'initialization'!beNull	^ handle beNull! !!SQLite3AbstractError class methodsFor: 'testing'!isAbstract	^self name = #SQLite3AbstractError! !!SQLite3AbstractError methodsFor: 'accessing'!resultCode	^ resultCode! !!SQLite3AbstractError methodsFor: 'accessing'!resultCode: anObject	resultCode := anObject! !!FFIExternalResourceManager methodsFor: '*SQLite3-Core'!removeResource: anObject	registry remove: anObject ifAbsent: [  ]! !!SQLite3Backup class methodsFor: 'creating'!to: dConnection named: dName from: sConnection named: sName	^(self new)		dstConnection: dConnection;		dstName: dName;		srcConnection: sConnection;		srcName: sName! !!SQLite3Backup methodsFor: 'accessing'!dstConnection	^ dstConnection! !!SQLite3Backup methodsFor: 'accessing'!dstConnection: anObject	dstConnection := anObject! !!SQLite3Backup methodsFor: 'accessing'!dstName	^ dstName! !!SQLite3Backup methodsFor: 'accessing'!dstName: anObject	dstName := anObject! !!SQLite3Backup methodsFor: 'finalization'!finalize	self finish! !!SQLite3Backup methodsFor: 'initialization'!finish	handle		ifNotNil: [			library apiBackupFinish: handle.			handle beNull.			handle := nil]! !!SQLite3Backup methodsFor: 'accessing'!handle	^ handle! !!SQLite3Backup methodsFor: 'accessing'!handle: anObject	handle := anObject! !!SQLite3Backup methodsFor: 'initialization'!initialize	super initialize.	isOpen := false.	library := SQLite3Library current.	handle := SQLite3DatabaseExternalObject new.	handle autoRelease! !!SQLite3Backup methodsFor: 'accessing'!isOpen	^ isOpen! !!SQLite3Backup methodsFor: 'accessing'!open	handle := (library backupTo: dstConnection named: dstName from: srcConnection named: srcName).	isOpen := true! !!SQLite3Backup methodsFor: 'accessing'!srcConnection	^ srcConnection! !!SQLite3Backup methodsFor: 'accessing'!srcConnection: anObject	srcConnection := anObject! !!SQLite3Backup methodsFor: 'accessing'!srcName	^ srcName! !!SQLite3Backup methodsFor: 'accessing'!srcName: anObject	srcName := anObject! !!SQLite3Backup methodsFor: 'accessing'!step	"Passing negative number means run to completion"	self step: -1! !!SQLite3Backup methodsFor: 'accessing'!step: nPages	library backup: handle step: nPages! !!SQLite3BaseConnection class methodsFor: 'testing'!isAbstract	^ self == SQLite3BaseConnection! !!SQLite3BaseConnection class methodsFor: 'testing'!isThreadsafe	"Native Library Version http://sqlite.org/c3ref/libversion.html sqlite3_libversion"	^ SQLite3Library current isThreadsafe ~= 0! !!SQLite3BaseConnection class methodsFor: 'accessing'!libraryVersion	"Native Library Version http://sqlite.org/c3ref/libversion.html sqlite3_libversion"	^ SQLite3Library current libraryVersion! !!SQLite3BaseConnection class methodsFor: 'examples'!memory	^ self on: ':memory:'! !!SQLite3BaseConnection class methodsFor: 'instance creation'!on: aFilename	^(self new)		on: aFilename;		yourself! !!SQLite3BaseConnection class methodsFor: 'instance creation'!openOn: aFilename	^(self new)		on: aFilename;		open;		yourself! !!SQLite3BaseConnection class methodsFor: 'testing'!threadsafe	"This method is deprecated so consider to migrate."	self deprecated:  'Please use #isThreadsafe instead' transformWith:  '`@receiver threadsafe'						-> '`@receiver isThreadsafe'.	^ self isThreadsafe! !!SQLite3BaseConnection methodsFor: 'public API - backups'!backupDatabaseNamed: sName to: aConnection named: dName	"database name is either 'main' or 'temp' or the name given to ATTACH DATABASE	See article at https://www.oreilly.com/library/view/using-sqlite/9781449394592/re225.html"	^SQLite3Backup to: aConnection handle named: dName from: dbHandle named: sName! !!SQLite3BaseConnection methodsFor: 'public API - backups'!backupTo: aConnection	^self backupTo: aConnection named: 'main'! !!SQLite3BaseConnection methodsFor: 'public API - backups'!backupTo: aConnection named: aName	^SQLite3Backup to: aConnection handle named: aName from: dbHandle named: 'main'! !!SQLite3BaseConnection methodsFor: 'public API - operating'!basicExecute: anSQLText	^ (self prepare: anSQLText) step; finalize"20190302, pierce: This used to invoke sqlite3_exec() which is an SQLite-internal convenience wrapper around prepare/step/finalize. It is now rewritten as seen to handle UTF8-encoded input properly. Rewriting this method breaks the Bobby Tables test which relies on naive SQL string construction to work."! !!SQLite3BaseConnection methodsFor: 'public API - transactional'!beginTransaction	^ self basicExecute: 'begin'! !!SQLite3BaseConnection methodsFor: 'public API - introspection'!changes	^ library changes: dbHandle! !!SQLite3BaseConnection methodsFor: 'public API - operating'!clearBindings: aStatement	library clearBindings: aStatement handle on: dbHandle! !!SQLite3BaseConnection methodsFor: 'public API - open/close'!close	"Do the minimal work to close the connection. 	Let FFIExternalResourceManager take care of calling sqlite_close_v2()."	dbHandle ifNil: [ ^ self ].	"Set dbHandle to nil to allow its garbage collection.	The underlying handle should not be switched to NULL here, SQLite3DatabaseExternalObject class>>doFinalizeResourceData: will take care of that"	dbHandle := nil.	isOpen := false! !!SQLite3BaseConnection methodsFor: 'public API - introspection'!columnNamesFor: aTableName	self isOpen		ifFalse: [ SQLite3NotOpen signal ]		ifTrue: [			^ (self existTableNamed: aTableName)				  ifTrue: [					  | columns s |					  columns := OrderedCollection new.					  s := self prepare: 'pragma table_info([' , aTableName , '])'.					  s basicExecute: [ :row | columns add: (row stringAt: 1) ].					  s finalize.					  columns ]				  ifFalse: [ nil ] ]! !!SQLite3BaseConnection methodsFor: 'public API - transactional'!commitTransaction	^ self basicExecute: 'commit'! !!SQLite3BaseConnection methodsFor: 'public API - introspection'!declaredColumnTypesFor: aTableName	self isOpen		ifFalse: [ SQLite3NotOpen signal ]		ifTrue: [			^ (self existTableNamed: aTableName)				  ifTrue: [					  | columns s |					  columns := OrderedCollection new.					  s := self prepare: 'pragma table_info([' , aTableName , '])'.					  s basicExecute: [ :row | columns add: (row stringAt: 2) ].					  s finalize.					  columns ]				  ifFalse: [ nil ] ]! !!SQLite3BaseConnection methodsFor: 'public API - extensions'!disableExtensions	^ library disableLoadExtension: dbHandle! !!SQLite3BaseConnection methodsFor: 'public API - extensions'!enableExtensions	^ library enableLoadExtension: dbHandle! !!SQLite3BaseConnection methodsFor: 'private'!existTableNamed: aTableName	| tableExists s |	tableExists := false.	s := self prepare: 'select count(*) from sqlite_master where type = "table" and tbl_name = ?'.	s at: 1 putString: aTableName.	s basicExecute: [ :row | tableExists := (row integerAt: 0) = 1 ].	s finalize.	^ tableExists! !!SQLite3BaseConnection methodsFor: 'accessing'!filename	^ dbFilename! !!SQLite3BaseConnection methodsFor: 'public API - operating'!finalize: aStatementHandle	library finalize: aStatementHandle on: dbHandle! !!SQLite3BaseConnection methodsFor: 'public API - open/close'!forceClose	"Forces the release of dbHandle, enabling to delete the database file without closing Pharo"	dbHandle ifNotNil: [ library close: dbHandle ].	self close! !!SQLite3BaseConnection methodsFor: 'public API - introspection'!getAutoCommit	^library getAutoCommit: dbHandle! !!SQLite3BaseConnection methodsFor: 'accessing'!handle	^dbHandle! !!SQLite3BaseConnection methodsFor: 'initialization'!initialize	super initialize.	isOpen := false.	library := SQLite3Library current.	dbHandle := SQLite3DatabaseExternalObject new.	dbHandle autoRelease.	statementClass := SQLite3PreparedStatement! !!SQLite3BaseConnection methodsFor: 'testing'!isOpen	^ isOpen! !!SQLite3BaseConnection methodsFor: 'public API - extensions'!loadExtension: aFilename	^ library loadExtension: dbHandle with: aFilename! !!SQLite3BaseConnection methodsFor: 'private'!on: aFilename	dbFilename := aFilename.	^ self! !!SQLite3BaseConnection methodsFor: 'public API - open/close'!open	library open: dbFilename via: dbHandle.	isOpen := true! !!SQLite3BaseConnection methodsFor: 'public API - operating'!prepare: anSQLText	| s |	s := self statementClass new.	s connection: self.	s prepare: anSQLText.	^ s! !!SQLite3BaseConnection methodsFor: 'public API - cleaning'!reset: aStatement	^library reset: aStatement handle! !!SQLite3BaseConnection methodsFor: 'public API - transactional'!rollbackTransaction	^ self basicExecute: 'rollback'! !!SQLite3BaseConnection methodsFor: 'private'!signal: exceptionClass with: value	library signal: exceptionClass with: value on: dbHandle! !!SQLite3BaseConnection methodsFor: 'accessing'!statementClass	^ statementClass! !!SQLite3BaseConnection methodsFor: 'public API - introspection'!tableNames	| tables s |	self isOpen		ifFalse: [ SQLite3NotOpen signal ]		ifTrue: [			tables := OrderedCollection new.			s := self prepare: 'select tbl_name from sqlite_master where type = "table"'.	  		s basicExecute: [ :row |				(row dataValuesAvailable > 0) ifTrue: [ tables add: (row stringAt: 0) ]].	  		s finalize.			^ tables ]! !!SQLite3BaseConnection methodsFor: 'public API - introspection'!totalChanges	^ library totalChanges: dbHandle! !!SQLite3BaseConnection methodsFor: 'public API - tracing'!traceUsing: callback with: appdata	library trace: dbHandle with: callback with: appdata! !!SQLite3Connection methodsFor: 'public API - operating'!execute: anSQLText	^ self execute: anSQLText with: #()! !!SQLite3Connection methodsFor: 'public API - operating'!execute: anSQLText value: anObject	^ (self prepare: anSQLText)	execute: (Array with: anObject)! !!SQLite3Connection methodsFor: 'public API - operating'!execute: anSQLText value: object1 value: object2	^ self execute: anSQLText with: (Array with: object1 with: object2)! !!SQLite3Connection methodsFor: 'public API - operating'!execute: anSQLText value: object1 value: object2 value: object3	^ self execute: anSQLText		with: (Array with: object1 with: object2 with: object3)! !!SQLite3Connection methodsFor: 'public API - operating'!execute: anSQLText value: object1 value: object2 value: object3 value: object4	^ self execute: anSQLText		with: (Array with: object1 with: object2 with: object3 with: object4)! !!SQLite3Connection methodsFor: 'public API - operating'!execute: anSQLText with: aCollection	^(self prepare: anSQLText) execute: aCollection! !!SQLite3Connection methodsFor: 'public API - operating'!execute: anSQLText with: aCollection doing: aBlock	| cursor |	cursor := self execute: anSQLText with: aCollection.	^ [aBlock value: cursor]			ensure: [ cursor finalizeStatement ]! !!SQLite3Connection methodsFor: 'public API - operating'!execute: anSQLText withAll: parameterCollection	"execute a sql statement with many parameters"	| stmt |	stmt := self prepare: anSQLText.	parameterCollection do: [ :parameters | stmt execute: parameters ].	stmt finalize! !!SQLite3Column methodsFor: 'accessing'!cid: anObject	"The cid column should not be taken to mean more than 'rank within the current result set'."	index := anObject! !!SQLite3Column methodsFor: 'accessing'!hasNotNullConstraint	^ hasNotNullConstraint! !!SQLite3Column methodsFor: 'accessing'!index	^ index! !!SQLite3Column methodsFor: 'accessing'!index: anObject	index := anObject! !!SQLite3Column methodsFor: 'initialization'!initialize	super initialize.	hasNotNullConstraint := false! !!SQLite3Column methodsFor: 'accessing'!name	^ name! !!SQLite3Column methodsFor: 'accessing'!name: anObject	name := anObject! !!SQLite3Column methodsFor: 'accessing'!notnull: anInteger	"whether or not the column can be NULL"	hasNotNullConstraint := anInteger = 1! !!SQLite3Column methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		<< '("';		<< self name;		<< '")'! !!SQLite3Column methodsFor: 'accessing'!type	^ type! !!SQLite3Column methodsFor: 'accessing'!type: anObject	type := anObject! !!SQLite3Database class methodsFor: 'instance creation'!forConnection: aConnection	^ self new		initConnection: aConnection;		yourself! !!SQLite3Database class methodsFor: 'instance creation'!memory	^ self forConnection: SQLite3Connection memory! !!SQLite3Database class methodsFor: 'instance creation'!on: aFilename	^ self forConnection: (SQLite3Connection on: aFilename)! !!SQLite3Database class methodsFor: 'instance creation'!openOn: aFilename	^ (self on: aFilename)			open;			yourself! !!SQLite3Database class methodsFor: 'accessing'!tableInfoFor: aFileName	| db |	db := self on: aFileName.	db connection open.	^ db tables! !!SQLite3Database methodsFor: 'open/close'!close	^ self connection close! !!SQLite3Database methodsFor: 'accessing'!connection	^ connection! !!SQLite3Database methodsFor: 'executing'!execute: anSQLStatement	^ self connection execute: anSQLStatement! !!SQLite3Database methodsFor: 'executing'!execute: anSQLStatement doing: aBlock	^ self connection execute: anSQLStatement with: #(  ) doing: aBlock! !!SQLite3Database methodsFor: 'private - initialization'!initConnection: aConnection	connection := aConnection! !!SQLite3Database methodsFor: 'open/close'!open	^ self connection open! !!SQLite3Database methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		<< '("';		<< self connection filename;		<< '")'! !!SQLite3Database methodsFor: 'accessing'!tables	self connection isOpen ifFalse: [ ^ SQLite3NotOpen signal ].	^ (connection execute: '			SELECT *			FROM sqlite_master			WHERE			    type =''table'' AND    			name NOT LIKE ''sqlite_%'';') rows collect: [ :eachRow |		  SQLite3Table properties: eachRow asDictionary in: self ]! !!SQLite3Row class methodsFor: 'instance creation'!new: anInteger	^(self new)		columnNames:(Array new:anInteger);		values: (Array new: anInteger);		yourself! !!SQLite3Row methodsFor: 'converting'!asArray	^ self values asArray! !!SQLite3Row methodsFor: 'converting'!asCombinedDictionary	^self asDictionary addAll: ((self values collectWithIndex:[:v :i | i -> v]) asDictionary); yourself! !!SQLite3Row methodsFor: 'converting'!asDictionary	"Borrowed from the future - Pharo 8"	| dict |	dict := Dictionary new.	self columnNames with: self values do: [ :k :v | dict at: k put: v ].	^ dict! !!SQLite3Row methodsFor: 'accessing'!at: aKey	^ self at: aKey ifAbsent: [  ]! !!SQLite3Row methodsFor: 'accessing'!at: aKey ifAbsent: aBlock	^ aKey isInteger		ifTrue: [ self values at: aKey ifAbsent: aBlock ]		ifFalse: [ self values at:(self columnNames indexOf: aKey) ifAbsent: aBlock ]! !!SQLite3Row methodsFor: 'accessing'!at: aKey put: anObject	^ aKey isInteger		ifTrue: [self atIndex: aKey put: anObject]		ifFalse: [ self atName: aKey put: anObject ]! !!SQLite3Row methodsFor: 'accessing'!atIndex: anIndex	^ values at: anIndex ifAbsent: [  ]! !!SQLite3Row methodsFor: 'accessing'!atIndex: anIndex put: anObject	^ self values at: anIndex put: anObject! !!SQLite3Row methodsFor: 'accessing'!atName: aKey	| idx |	idx := self columnNames indexOf: aKey.	^idx = 0		ifTrue: [ SQLite3Misuse				signal: 'Attept to set invalid column name ', aKey, ' in result set'   ]		ifFalse: [ values at: idx ]! !!SQLite3Row methodsFor: 'accessing'!atName: aKey put: anObject	| idx |	^ (idx := self columnNames indexOf: aKey) isZero		ifTrue: [			columnNames := self columnNames copyWith: aKey.			values := self values copyWith: anObject ]		ifFalse: [ values at: idx put: anObject ]! !!SQLite3Row methodsFor: 'accessing'!columnNames	^ columnNames ifNil: [ #() ]! !!SQLite3Row methodsFor: 'accessing'!columnNames: anArray	columnNames := anArray.	values := Array new: anArray size! !!SQLite3Row methodsFor: 'accessing'!data	"compatibility"	 ^self asCombinedDictionary! !!SQLite3Row methodsFor: 'accessing'!dataCount	^ self columnNames size! !!SQLite3Row methodsFor: 'reflective operations'!doesNotUnderstand: aMessage	^ self at: aMessage selector asString			ifAbsent: [				"20160514: This bit, for Glorp integration, feels a bit iffy."				self at: aMessage selector asString asUppercase					ifAbsent: [ super doesNotUnderstand: aMessage ]]! !!SQLite3Row methodsFor: 'accessing'!first	^ self values ifEmpty: [] ifNotEmpty: [:v | v first ]! !!SQLite3Row methodsFor: 'accessing'!last	^ self values ifEmpty: [ nil ] ifNotEmpty: [:v | v last ]! !!SQLite3Row methodsFor: 'accessing'!size	^ self columnNames size! !!SQLite3Row methodsFor: 'accessing'!values	 ^values ifNil: [ #() ]! !!SQLite3Row methodsFor: 'accessing'!values: anArray	 values := anArray! !!SQLite3Table class methodsFor: 'instance creation'!properties: aDictionary in: aDatabase	^ self new		database: aDatabase;		properties: aDictionary;		yourself! !!SQLite3Table methodsFor: 'accessing'!columnNames	^ self columns collect: [:each | each name ]! !!SQLite3Table methodsFor: 'accessing'!columns	^ (self database execute: 'pragma table_info([' , self name , ']);')		  rowClass: SQLite3Column;		  rows! !!SQLite3Table methodsFor: 'accessing'!database	^ database! !!SQLite3Table methodsFor: 'private - accessing'!database: anObject	database := anObject! !!SQLite3Table methodsFor: 'accessing'!name	^ self properties at: #name ifAbsent: [ '' ]! !!SQLite3Table methodsFor: 'accessing'!numberOfRows	^ (self database execute: 'SELECT COUNT(*) FROM [' , self name , '];')		  onlyValue! !!SQLite3Table methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		<< '("';		<< self name;		<< '")'! !!SQLite3Table methodsFor: 'accessing'!properties	^ properties ifNil: [ properties := Dictionary new ]! !!SQLite3Table methodsFor: 'private - accessing'!properties: anObject	properties := anObject! !!SQLite3Table methodsFor: 'accessing'!rows	^ (self database execute: 'SELECT *			FROM [' , self name , ']			LIMIT 1000;') rows! !!SQLite3Table methodsFor: 'accessing'!schema	^ self properties at: #sql ifAbsent: ''! !!SQLite3Constants class methodsFor: 'private - initialization'!initCheckpointModes    SQLITE_CHECKPOINT_PASSIVE := 0.    SQLITE_CHECKPOINT_FULL := 1.    SQLITE_CHECKPOINT_RESTART := 2.    SQLITE_CHECKPOINT_TRUNCATE := 3! !!SQLite3Constants class methodsFor: 'private - initialization'!initConstants	self		initResultCodes;		initErrorCodes;		initExtendedErrorCodes;		initFileOpenFlags! !!SQLite3Constants class methodsFor: 'private - initialization'!initDataTypes	"Fundamental Datatypes"	SQLITE_INTEGER := 1.	SQLITE_FLOAT := 2.	SQLITE_TEXT := 3.	SQLITE3_TEXT := 3.	SQLITE_BLOB := 4.	SQLITE_NULL := 5! !!SQLite3Constants class methodsFor: 'private - initialization constants'!initErrorCodes	"In its default configuration, SQLite API routines return one of 26 integer	[SQLITE_OK | result codes]."	SQLITE_ERROR := 1. 			"SQL error or missing database"	SQLITE_INTERNAL := 2.			"Internal logic error in SQLite"	SQLITE_PERM := 3.				"Access permission denied"	SQLITE_ABORT := 4.				"Callback routine requested an abort"	SQLITE_BUSY := 5.  			"The database file is locked"	SQLITE_LOCKED := 6. 			"A table in the database is locked"	SQLITE_NOMEM := 7.				"A malloc() failed"	SQLITE_READONLY := 8.			"Attempt to write a readonly database"	SQLITE_INTERRUPT := 9.		"Operation terminated by sqlite3_interrupt()"	SQLITE_IOERR := 10.			"Some kind of disk I/O error occurred"	SQLITE_CORRUPT := 11.			"The database disk image is malformed"	SQLITE_NOTFOUND := 12.		"Unknown opcode in sqlite3_file_control()"	SQLITE_FULL := 13.				"Insertion failed because database is full"	SQLITE_CANTOPEN := 14.   	"Unable to open the database file"	SQLITE_PROTOCOL := 15.		"Database lock protocol error"	SQLITE_EMPTY := 16.			"Database is empty"	SQLITE_SCHEMA := 17.			"The database schema changed"	SQLITE_TOOBIG := 18.			"String or BLOB exceeds size limit"	SQLITE_CONSTRAINT := 19.		"Abort due to constraint violation"	SQLITE_MISMATCH := 20.		"Data type mismatch"	SQLITE_MISUSE := 21. 			"Library used incorrectly"	SQLITE_NOLFS := 22.			"Uses OS features not supported on host"	SQLITE_AUTH := 23.				"Authorization denied"	SQLITE_FORMAT := 24.			"Auxiliary database format error"	SQLITE_RANGE := 25.			"2nd parameter to sqlite3_bind out of range"	SQLITE_NOTADB := 26.			"File opened that is not a database file"	SQLITE_NOTICE := 27.			"Notifications from sqlite3_log()"	SQLITE_WARNING := 28.			"Warnings from sqlite3_log()"! !!SQLite3Constants class methodsFor: 'private - initialization constants'!initExtendedErrorCodes	"Newer versions of SQLite (version 3.3.8 and later) include support for additional result codes that provide more detailed information about errors. The extended result codes are enabled or disabled on a per database connection basis using the [sqlite3_extended_result_codes()] API."    SQLITE_ERROR_MISSING_COLLSEQ    := (SQLITE_ERROR | (1<<8)).    SQLITE_ERROR_RETRY              := (SQLITE_ERROR | (2<<8)).    SQLITE_ERROR_SNAPSHOT           := (SQLITE_ERROR | (3<<8)).    SQLITE_IOERR_READ               := (SQLITE_IOERR | (1<<8)).    SQLITE_IOERR_SHORT_READ         := (SQLITE_IOERR | (2<<8)).    SQLITE_IOERR_WRITE              := (SQLITE_IOERR | (3<<8)).    SQLITE_IOERR_FSYNC              := (SQLITE_IOERR | (4<<8)).    SQLITE_IOERR_DIR_FSYNC          := (SQLITE_IOERR | (5<<8)).    SQLITE_IOERR_TRUNCATE           := (SQLITE_IOERR | (6<<8)).    SQLITE_IOERR_FSTAT              := (SQLITE_IOERR | (7<<8)).    SQLITE_IOERR_UNLOCK             := (SQLITE_IOERR | (8<<8)).    SQLITE_IOERR_RDLOCK             := (SQLITE_IOERR | (9<<8)).    SQLITE_IOERR_DELETE             := (SQLITE_IOERR | (10<<8)).    SQLITE_IOERR_BLOCKED            := (SQLITE_IOERR | (11<<8)).    SQLITE_IOERR_NOMEM              := (SQLITE_IOERR | (12<<8)).    SQLITE_IOERR_ACCESS             := (SQLITE_IOERR | (13<<8)).    SQLITE_IOERR_CHECKRESERVEDLOCK  := (SQLITE_IOERR | (14<<8)).    SQLITE_IOERR_LOCK               := (SQLITE_IOERR | (15<<8)).    SQLITE_IOERR_CLOSE              := (SQLITE_IOERR | (16<<8)).    SQLITE_IOERR_DIR_CLOSE          := (SQLITE_IOERR | (17<<8)).    SQLITE_IOERR_SHMOPEN            := (SQLITE_IOERR | (18<<8)).    SQLITE_IOERR_SHMSIZE            := (SQLITE_IOERR | (19<<8)).    SQLITE_IOERR_SHMLOCK            := (SQLITE_IOERR | (20<<8)).    SQLITE_IOERR_SHMMAP             := (SQLITE_IOERR | (21<<8)).    SQLITE_IOERR_SEEK               := (SQLITE_IOERR | (22<<8)).    SQLITE_IOERR_DELETE_NOENT       := (SQLITE_IOERR | (23<<8)).    SQLITE_IOERR_MMAP               := (SQLITE_IOERR | (24<<8)).    SQLITE_IOERR_GETTEMPPATH        := (SQLITE_IOERR | (25<<8)).    SQLITE_IOERR_CONVPATH           := (SQLITE_IOERR | (26<<8)).    SQLITE_IOERR_VNODE              := (SQLITE_IOERR | (27<<8)).    SQLITE_IOERR_AUTH               := (SQLITE_IOERR | (28<<8)).    SQLITE_IOERR_BEGIN_ATOMIC       := (SQLITE_IOERR | (29<<8)).    SQLITE_IOERR_COMMIT_ATOMIC      := (SQLITE_IOERR | (30<<8)).    SQLITE_IOERR_ROLLBACK_ATOMIC    := (SQLITE_IOERR | (31<<8)).    SQLITE_LOCKED_SHAREDCACHE       := (SQLITE_LOCKED |  (1<<8)).    SQLITE_LOCKED_VTAB              := (SQLITE_LOCKED |  (2<<8)).    SQLITE_BUSY_RECOVERY            := (SQLITE_BUSY   |  (1<<8)).    SQLITE_BUSY_SNAPSHOT            := (SQLITE_BUSY   |  (2<<8)).    SQLITE_CANTOPEN_NOTEMPDIR       := (SQLITE_CANTOPEN | (1<<8)).    SQLITE_CANTOPEN_ISDIR           := (SQLITE_CANTOPEN | (2<<8)).    SQLITE_CANTOPEN_FULLPATH        := (SQLITE_CANTOPEN | (3<<8)).    SQLITE_CANTOPEN_CONVPATH        := (SQLITE_CANTOPEN | (4<<8)).    SQLITE_CANTOPEN_DIRTYWAL        := (SQLITE_CANTOPEN | (5<<8)). "Not Used"    SQLITE_CORRUPT_VTAB             := (SQLITE_CORRUPT | (1<<8)).    SQLITE_CORRUPT_SEQUENCE         := (SQLITE_CORRUPT | (2<<8)).    SQLITE_READONLY_RECOVERY        := (SQLITE_READONLY | (1<<8)).    SQLITE_READONLY_CANTLOCK        := (SQLITE_READONLY | (2<<8)).    SQLITE_READONLY_ROLLBACK        := (SQLITE_READONLY | (3<<8)).    SQLITE_READONLY_DBMOVED         := (SQLITE_READONLY | (4<<8)).    SQLITE_READONLY_CANTINIT        := (SQLITE_READONLY | (5<<8)).    SQLITE_READONLY_DIRECTORY       := (SQLITE_READONLY | (6<<8)).    SQLITE_ABORT_ROLLBACK           := (SQLITE_ABORT | (2<<8)).    SQLITE_CONSTRAINT_CHECK         := (SQLITE_CONSTRAINT | (1<<8)).    SQLITE_CONSTRAINT_COMMITHOOK    := (SQLITE_CONSTRAINT | (2<<8)).    SQLITE_CONSTRAINT_FOREIGNKEY    := (SQLITE_CONSTRAINT | (3<<8)).    SQLITE_CONSTRAINT_FUNCTION      := (SQLITE_CONSTRAINT | (4<<8)).    SQLITE_CONSTRAINT_NOTNULL       := (SQLITE_CONSTRAINT | (5<<8)).    SQLITE_CONSTRAINT_PRIMARYKEY    := (SQLITE_CONSTRAINT | (6<<8)).    SQLITE_CONSTRAINT_TRIGGER       := (SQLITE_CONSTRAINT | (7<<8)).    SQLITE_CONSTRAINT_UNIQUE        := (SQLITE_CONSTRAINT | (8<<8)).    SQLITE_CONSTRAINT_VTAB          := (SQLITE_CONSTRAINT | (9<<8)).    SQLITE_CONSTRAINT_ROWID         := (SQLITE_CONSTRAINT |(10<<8)).    SQLITE_NOTICE_RECOVER_WAL       := (SQLITE_NOTICE | (1<<8)).    SQLITE_NOTICE_RECOVER_ROLLBACK  := (SQLITE_NOTICE | (2<<8)).    SQLITE_WARNING_AUTOINDEX        := (SQLITE_WARNING | (1<<8)).    SQLITE_AUTH_USER                := (SQLITE_AUTH | (1<<8)).    SQLITE_OK_LOAD_PERMANENTLY      := (SQLITE_OK | (1<<8))! !!SQLite3Constants class methodsFor: 'private - initialization constants'!initFileOpenFlags	SQLITE_OPEN_READONLY      	  := Integer readFrom: '00000001' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_READWRITE         := Integer readFrom: '00000002' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_CREATE            := Integer readFrom: '00000004' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_DELETEONCLOSE     := Integer readFrom: '00000008' base: 16.  " VFS only "	SQLITE_OPEN_EXCLUSIVE         := Integer readFrom: '00000010' base: 16.  " VFS only "	SQLITE_OPEN_AUTOPROXY         := Integer readFrom: '00000020' base: 16.  " VFS only "	SQLITE_OPEN_URI               := Integer readFrom: '00000040' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_MEMORY            := Integer readFrom: '00000080' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_MAIN_DB           := Integer readFrom: '00000100' base: 16.  " VFS only "	SQLITE_OPEN_TEMP_DB           := Integer readFrom: '00000200' base: 16.  " VFS only "	SQLITE_OPEN_TRANSIENT_DB      := Integer readFrom: '00000400' base: 16.  " VFS only "	SQLITE_OPEN_MAIN_JOURNAL      := Integer readFrom: '00000800' base: 16.  " VFS only "	SQLITE_OPEN_TEMP_JOURNAL      := Integer readFrom: '00001000' base: 16.  " VFS only "	SQLITE_OPEN_SUBJOURNAL        := Integer readFrom: '00002000' base: 16.  " VFS only "	SQLITE_OPEN_MASTER_JOURNAL    := Integer readFrom: '00004000' base: 16.  " VFS only "	SQLITE_OPEN_NOMUTEX           := Integer readFrom: '00008000' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_FULLMUTEX         := Integer readFrom: '00010000' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_SHAREDCACHE       := Integer readFrom: '00020000' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_PRIVATECACHE      := Integer readFrom: '00040000' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_WAL               := Integer readFrom: '00080000' base: 16.  " VFS only "! !!SQLite3Constants class methodsFor: 'private - initialization constants'!initResultCodes	SQLITE_OK := 0.		 			"Successful result"	SQLITE_ROW := 100.				"sqlite3_step() has another row ready"	SQLITE_DONE := 101 			"sqlite3_step() has finished executing"! !!SQLite3Constants class methodsFor: 'initialization'!initialize	self		initConstants;		initDataTypes;		initCheckpointModes! !!SQLite3Cursor class methodsFor: 'instance creation'!on: aStatement	^(self new) statement: aStatement; yourself! !!SQLite3Cursor methodsFor: 'accessing'!changes	^statement changes! !!SQLite3Cursor methodsFor: 'API'!close	" closing a cursor is not the same as closing the statement - we may reuse a prepared statement"	statement ifNotNil: [ statement reset ].	statement := nil.	mutators := nil! !!SQLite3Cursor methodsFor: 'accessing'!columnNames	^ statement ifNotNil: [ statement columnNames ] ifNil: [ #() ]! !!SQLite3Cursor methodsFor: 'accessing'!connection	^statement connection! !!SQLite3Cursor methodsFor: 'enumerating'!do: aBlock	"Evaluate aBlock with each of the receiver's rows as the argument."	| eachRow |	[ (eachRow := self next) isNotNil ] whileTrue: [		aBlock value: eachRow ]! !!SQLite3Cursor methodsFor: 'API'!finalizeStatement	statement finalize! !!SQLite3Cursor methodsFor: 'initialization'!initialize	"Initializes the receiver"	super initialize.	moreRows := true.	rowClass := SQLite3Row! !!SQLite3Cursor methodsFor: 'accessing'!mutators	^ mutators		ifNil: [ mutators := self columnNames				collect: [ :c |					(((c substrings: ' _-()') collect: [ :ea | ea capitalized ])						joinUsing: '') uncapitalized asSymbol asMutator ] ]! !!SQLite3Cursor methodsFor: 'API'!next	^ self nextOfClass: self rowClass! !!SQLite3Cursor methodsFor: 'API'!nextOfClass: aRowClass	| rr |	moreRows ifFalse: [ ^nil ].	statement		ifNil: [ SQLite3Misuse				signal: 'This result set does not contain a prepared statement.' ].	moreRows		ifTrue: [			rr := aRowClass new.			(rr respondsTo: #columnNames:)				ifTrue: [ "generic row class"					rr columnNames: self columnNames.					1 to: statement dataValuesAvailable do: [ :c | rr at: c put: (statement valueOfColumn: c - 1) ].					 ]				ifFalse: [ | msgs |					"custom object"					msgs := self mutators.					1 to: msgs size do: [ :c |						(rr respondsTo: (msgs at: c))							ifTrue: [ rr perform: (msgs at: c) with: (statement valueOfColumn: c - 1) ] ]						].			moreRows := statement step = SQLITE_ROW.			moreRows ifFalse: [ self close ].			^ rr ].	^ nil! !!SQLite3Cursor methodsFor: 'API'!onlyRow	^ self onlyRow: [ ]"For the common case where there is exactly one row expected. Returns nil if there is no row."! !!SQLite3Cursor methodsFor: 'API'!onlyRow: ifNoneBlock	^self rows		ifEmpty: [ ifNoneBlock value ]		ifNotEmpty: [ rows first ]."For the common case where there is exactly one row expected. Returns the evaluation of ifNoneBlock if there is no row."! !!SQLite3Cursor methodsFor: 'API'!onlyValue	^(self onlyRow: []) ifNotNil: [ :r | r first ]! !!SQLite3Cursor methodsFor: 'accessing'!rowClass	^ rowClass! !!SQLite3Cursor methodsFor: 'accessing'!rowClass: anObject	rowClass := anObject! !!SQLite3Cursor methodsFor: 'API'!rows	^ self rowsOfClass: self rowClass! !!SQLite3Cursor methodsFor: 'API'!rowsOfClass: aRowClass	rows ifNil: [ rows := OrderedCollection new ].	[ moreRows ] whileTrue: [			rows add: (self nextOfClass: aRowClass) ].	^ rows! !!SQLite3Cursor methodsFor: 'accessing'!statement	^ statement! !!SQLite3Cursor methodsFor: 'accessing'!statement: anObject	statement := anObject.	moreRows := (statement ifNil:[false ] ifNotNil: [ statement dataValuesAvailable > 0 ])! !!SQLite3Library class methodsFor: 'private - accessing'!booleanSQLFalseWords	^ #('false' 'f')! !!SQLite3Library class methodsFor: 'private - accessing'!booleanSQLTrueWords	^ #('true' 't')! !!SQLite3Library class methodsFor: 'private - accessing'!booleanTypes	^ #('boolean' 'bool')! !!SQLite3Library class methodsFor: 'factory'!current	^self uniqueInstance! !!SQLite3Library class methodsFor: 'unified FFI - binding'!ffiBindingOf: aTypeName	^ TypeMap at: aTypeName ifAbsent: [ super ffiBindingOf: aTypeName ]! !!SQLite3Library class methodsFor: 'class initialization'!initialize	self		initializeTypeMap;		initializeDataTypeMap;		initializeDateTimeTypeMap! !!SQLite3Library class methodsFor: 'private - initialization'!initializeDataTypeMap	DataTypeMap := Dictionary newFromPairs: #(		1			#integerAt:		2			#floatAt:		3			#stringAt:		4			#byteArrayAt:		5			#nilAt:	)! !!SQLite3Library class methodsFor: 'private - accessing'!initializeDateTimeTypeMap	DateTimeTypeMap := {		'datetime' -> #dateTimeAt:.		'date' -> #dateAt:.		'timestamp' -> #timestampAt:.		'time' -> #timeAt: } asDictionary! !!SQLite3Library class methodsFor: 'private - initialization'!initializeTypeMap	TypeMap := Dictionary newFromPairs: #(		sqlite3		      #SQLite3DatabaseExternalObject		sqlite3_stmt			#SQLite3StatementExternalObject		sqlite3_backup		#NBSQLite3BackupExternalObject		"sqlite3_blob			NBSQLite3BlobExternalObject "		sqlite3_int64		FFIInt64	)! !!SQLite3Library class methodsFor: 'factory'!reset	uniqueInstance := nil! !!SQLite3Library methodsFor: 'private - api'!apiBackupFinish: backupHandle	"int sqlite3_backup_finish(sqlite3_backup *p)"	^ self ffiCall: #(int sqlite3_backup_finish(SQLite3BackupExternalReference *backupHandle))! !!SQLite3Library methodsFor: 'private - api'!apiBackupPageCount: backupHandle	"int sqlite3_backup_pagecount(sqlite3_backup *p)"	^ self ffiCall: #(int sqlite3_backup_pagecount(sqlite3_backup *backupHandle))! !!SQLite3Library methodsFor: 'private - api'!apiBackupRemaining: backupHandle	"int sqlite3_backup_remaining(sqlite3_backup *p)"	^ self ffiCall: #(int sqlite3_backup_remaining(sqlite3_backup *backupHandle))! !!SQLite3Library methodsFor: 'private - api'!apiBackupStep:nPage via: backupHandle	"int sqlite3_backup_step(sqlite3_backup *p, int nPage)"	^ self ffiCall: #(int sqlite3_backup_step(SQLite3BackupExternalReference *backupHandle, int nPage))! !!SQLite3Library methodsFor: 'private - api'!apiBackupTo: pDest named: zDestName from: pSource named: zSourceName	"sqlite3_backup *sqlite3_backup_init(  sqlite3 *pDest,                        /* Destination database handle */  const char *zDestName,                 /* Destination database name */  sqlite3 *pSource,                      /* Source database handle */  const char *zSourceName                /* Source database name */)"	^ self ffiCall: #(SQLite3BackupExternalReference *sqlite3_backup_init(  sqlite3 *pDest, String zDestName, sqlite3 *pSource, String zSourceName))! !!SQLite3Library methodsFor: 'private - api'!apiBindBlob: aStatement atColumn: aColumn with: aByteArray with: anInteger with: aPointer	"int sqlite3_bind_blob(sqlite3_stmt*, int, const void *, int, void(*)(void*))"	^ self ffiCall: #(int sqlite3_bind_blob (sqlite3_stmt* aStatement, int aColumn, void* aByteArray, int anInteger, int aPointer)) "SQLITE_TRANSIENT"! !!SQLite3Library methodsFor: 'private - api'!apiBindDouble: aStatement atColumn: aColumn with: aFloat	"int sqlite3_bind_double(sqlite3_stmt*, int, double)"	^ self ffiCall: #(int sqlite3_bind_double (sqlite3_stmt* aStatement, int aColumn, double aFloat))! !!SQLite3Library methodsFor: 'private - api'!apiBindInteger: aStatement atColumn: aColumn with: anInteger	"int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite_int64)"	^ self		ffiCall: #(int sqlite3_bind_int64 (sqlite3_stmt* aStatement,int aColumn,sqlite3_int64 anInteger))! !!SQLite3Library methodsFor: 'private - api'!apiBindNull: aStatement atColumn: aColumn	"int sqlite3_bind_null(sqlite3_stmt*, int)"	^ self ffiCall: #(int sqlite3_bind_null (sqlite3_stmt* aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api'!apiBindParameterCount: aStatement	"int sqlite3_bind_parameter_count(sqlite3_stmt*)"	^ self ffiCall: #(int sqlite3_bind_parameter_count (sqlite3_stmt* aStatement))! !!SQLite3Library methodsFor: 'private - api'!apiBindParameterIndex: aStatement for: aName	"int sqlite3_bind_parameter_index(sqlite3_stmt*, const char* zName)"	^ self ffiCall: #(int sqlite3_bind_parameter_index (sqlite3_stmt* aStatement, String aName))! !!SQLite3Library methodsFor: 'private - api'!apiBindText: aStatement atColumn: aColumn with: aString with: anInteger with: anotherInteger	"int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int, void(*)(void*))"	^ self ffiCall: #(int sqlite3_bind_text (sqlite3_stmt* aStatement, int aColumn, String aString, int anInteger, int anotherInteger))! !!SQLite3Library methodsFor: 'private - api'!apiChanges: handle	"int sqlite3_changes(sqlite3*)"	^ self ffiCall: #(int sqlite3_changes (sqlite3 *handle))! !!SQLite3Library methodsFor: 'private - api'!apiClearBindings: aStatement	"int sqlite3_clear_bindings(sqlite3_stmt*)"	^ self ffiCall: #(int sqlite3_clear_bindings (sqlite3_stmt* aStatement))! !!SQLite3Library methodsFor: 'private - api'!apiClose: handle	"int sqlite3_close_v2(sqlite3*)"	^self ffiCall: #(int sqlite3_close_v2(sqlite3 *handle))! !!SQLite3Library methodsFor: 'private - api'!apiColumnBlob: aStatement atColumn: aColumn	"const void *sqlite3_column_blob(sqlite3_stmt*, int)"	^ self ffiCall: #(const void *sqlite3_column_blob (sqlite3_stmt* aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api'!apiColumnBytes: aStatement atColumn: aColumn	"int sqlite3_column_bytes(sqlite3_stmt*, int)"	^ self ffiCall: #(int sqlite3_column_bytes (sqlite3_stmt* aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api'!apiColumnCount: aStatement	"int sqlite3_column_count(sqlite3_stmt *pStmt)"	^ self ffiCall: #(int sqlite3_column_count(sqlite3_stmt *aStatement))! !!SQLite3Library methodsFor: 'private - api'!apiColumnDeclaredType: aStatement atColumn: aColumn	"const char *sqlite3_column_decltype(sqlite3_stmt*, int)"	^ self		ffiCall: #(String sqlite3_column_decltype #(sqlite3_stmt *aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api'!apiColumnDouble: aStatement atColumn: aColumn	"double sqlite3_column_double(sqlite3_stmt*, int)"	^ self ffiCall: #(double sqlite3_column_double (sqlite3_stmt* aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api'!apiColumnInt: aStatement atColumn: aColumn	"int sqlite3_column_int(sqlite3_stmt*, int)"	^ self ffiCall: #(sqlite3_int64 sqlite3_column_int64 (sqlite3_stmt* aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api'!apiColumnName: aStatement atColumn: aColumn	"const char *sqlite3_column_name(sqlite3_stmt*, int)"	^ self		ffiCall: #(String sqlite3_column_name(sqlite3_stmt* aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api'!apiColumnText: aStatement atColumn: aColumn	"const unsigned char *sqlite3_column_text(sqlite3_stmt*, int)"	^ self ffiCall: #(String sqlite3_column_text (sqlite3_stmt* aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api'!apiColumnType: aStatement atColumn: aColumn	"int sqlite3_column_type(sqlite3_stmt*, int)"	^ self		ffiCall: #(int sqlite3_column_type(sqlite3_stmt* aStatement,int aColumn))! !!SQLite3Library methodsFor: 'private - api'!apiConfigLoadExtension: dbHandle with: op with: onoff with: retpointer	"This is a specific invocation of sqlite3_db_config(sqlite3*, int, ...)."	^self ffiCall: #(int sqlite3_db_config (sqlite3 *dbHandle, int op, int onoff, int *retpointer))"Notes from https://www.sqlite.org/c3ref/c_dbconfig_enable_fkey.html:op == SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSIONThis option is used to enable or disable the sqlite3_load_extension() interface independently of the load_extension() SQL function. The sqlite3_enable_load_extension() API enables or disables both the C-API sqlite3_load_extension() and the SQL function load_extension(). There should be two additional arguments. When the first argument to this interface is 1, then only the C-API is enabled and the SQL function remains disabled. If the first argument to this interface is 0, then both the C-API and the SQL function are disabled. If the first argument is -1, then no changes are made to state of either the C-API or the SQL function. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether sqlite3_load_extension() interface is disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the new setting is not reported back."! !!SQLite3Library methodsFor: 'private - api'!apiDBHandle: statementHandle	"sqlite3 *sqlite3_db_handle(sqlite3_stmt*);"	^self ffiCall: #(SQLite3DatabaseExternalObject *sqlite3_db_handle(SQLite3StatementExternalObject *statementHandle))! !!SQLite3Library methodsFor: 'private - api'!apiDataCount: handle	"int sqlite3_data_count(sqlite3_stmt*)"	^ self ffiCall: #(int sqlite3_data_count (sqlite3_stmt *handle))! !!SQLite3Library methodsFor: 'private - api'!apiErrorMessage: handle	"const char *sqlite3_errmsg(sqlite3*)"	^self ffiCall: #(String sqlite3_errmsg(sqlite3 *handle))! !!SQLite3Library methodsFor: 'private - api'!apiExec: dbHandle withSQLText: anSQLText with: callback with: callbackData with: errorMessageBuffer	"int sqlite3_exec(sqlite3*, const char*, int (*callback), void*, char **)"	^self ffiCall: #(int sqlite3_exec (sqlite3 *dbHandle, String anSQLText, void *callback, void *callbackData, char **errorMessageBuffer))! !!SQLite3Library methodsFor: 'private - api'!apiFinalize: handle	"int sqlite3_finalize(sqlite3_stmt*)"	^self ffiCall: #(int sqlite3_finalize(sqlite3_stmt *handle))! !!SQLite3Library methodsFor: 'private - api'!apiGetAutocommit: handle	"int sqlite3_get_autocommit(sqlite3*);"	^ self ffiCall: #(int sqlite3_get_autocommit (sqlite3 *handle))! !!SQLite3Library methodsFor: 'private - api'!apiLastInsertRowid: handle	"sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*)"	^ self ffiCall: #(long sqlite3_last_insert_rowid(SQLite3DatabaseExternalObject *handle))! !!SQLite3Library methodsFor: 'private - api'!apiLibVersion	"const char *sqlite3_libversion(void)"	^self ffiCall: #(String sqlite3_libversion(void))! !!SQLite3Library methodsFor: 'private - api'!apiLoadExtension: dbHandle with: zFile with: zProc with: pzErrMsg	"int sqlite3_load_extension(sqlite3*, const char*, const char*, char **)."	^self ffiCall: #(int sqlite3_load_extension (sqlite3 *dbHandle, String zFile, const char *zProc, char **pzErrMsg))		module: self library! !!SQLite3Library methodsFor: 'private - api'!apiOpen: filename via: handle	"int sqlite3_open(const char*, sqlite3**)"	^self ffiCall: #(int sqlite3_open(String filename, sqlite3 **handle))! !!SQLite3Library methodsFor: 'private - api'!apiOpen: filename withFlags: flags vfs: vfs via: handle	"int sqlite3_open_v2(  const char *filename,   /* Database filename (UTF-8) */  sqlite3 **ppDb,         /* OUT: SQLite db handle */  int flags,              /* Flags */  const char *zVfs        /* Name of VFS module to use */)"	^self ffiCall: #(int sqlite3_open_v2(String filename, sqlite3 **handle, int flags, String vfs))! !!SQLite3Library methodsFor: 'private - api'!apiPrepare: dbHandle withSQLText: anSQLText with: textSize with: sHandle with: tail	"int sqlite3_prepare_v2(sqlite3*, const char*, int, sqlite3_stmt**, const char **)"	^ self ffiCall: #(int sqlite3_prepare_v2 (sqlite3* dbHandle, String anSQLText, int textSize, sqlite3_stmt** sHandle, const char** tail))! !!SQLite3Library methodsFor: 'private - api'!apiReset: handle	"int sqlite3_reset(sqlite3_stmt*)"	^ self ffiCall: #(int sqlite3_reset (sqlite3_stmt *handle))! !!SQLite3Library methodsFor: 'private - api'!apiSleep	"int sqlite3_sleep(int)"	^ self ffiCall: #(int sqlite3_sleep(int))! !!SQLite3Library methodsFor: 'private - api'!apiSql: handle	"const char *sqlite3_sql(sqlite3_stmt*)"	^ self ffiCall: #(String sqlite3_sql (sqlite3_stmt* handle))! !!SQLite3Library methodsFor: 'private - api'!apiStatementReadOnly: handle	"int sqlite3_stmt_readonly(sqlite3_stmt *pStmt)"	^ self ffiCall: #(int sqlite3_stmt_readonly (SQLite3StatementExternalObject * handle))! !!SQLite3Library methodsFor: 'private - api'!apiStep: handle	"int sqlite3_step(sqlite3_stmt*)"	^ self ffiCall: #(int sqlite3_step (sqlite3_stmt* handle))! !!SQLite3Library methodsFor: 'private - api'!apiThreadsafe	"int sqlite3_threadsafe(void)"	^self ffiCall: #(int sqlite3_threadsafe(void))! !!SQLite3Library methodsFor: 'private - api'!apiTotalChanges: handle	"int sqlite3_total_changes(sqlite3*)"	^ self ffiCall: #(int sqlite3_total_changes (sqlite3 *handle))! !!SQLite3Library methodsFor: 'private - api'!apiTrace: handle with: callback with: appdata	^ self ffiCall: #(void* sqlite3_trace (sqlite3* handle, FFICallback callback, ExternalAddress appdata))! !!SQLite3Library methodsFor: 'operating'!backup: backupHandle step: nPages	^self apiBackupStep: nPages via: backupHandle! !!SQLite3Library methodsFor: 'operating'!backupTo: dstConnection named: dstName from: srcConnection named: srcName	^self apiBackupTo: dstConnection named: dstName from: srcConnection named: srcName! !!SQLite3Library methodsFor: 'operating'!bindParameterCount: aStatementHandle	^ self apiBindParameterCount: aStatementHandle! !!SQLite3Library methodsFor: 'operating'!bindParameterIndex: aStatementHandle for: aName	^ self apiBindParameterIndex: aStatementHandle for: aName! !!SQLite3Library methodsFor: 'accessing'!blobFrom: aStatement at: aColumn	| address size array |	address := self apiColumnBlob: aStatement atColumn: aColumn.	size := self apiColumnBytes: aStatement atColumn: aColumn.	array := address copyFrom: 1 to: size.	^array! !!SQLite3Library methodsFor: 'accessing'!booleanFrom: aStatement at: aColumn	| declared selector value |	declared := self apiColumnDeclaredType: aStatement atColumn: aColumn.	(self class booleanTypes includes: declared asLowercase) ifFalse: [		SQLite3AbstractError signal: 'Column is not declared as a boolean.' ].	selector := DataTypeMap at: (self apiColumnType: aStatement atColumn: aColumn).	(selector = #nilAt:) ifTrue: [ ^ nil ].	(selector = #stringAt:)		ifTrue: [			value := self apiColumnText: aStatement atColumn: aColumn.			(self class booleanSQLTrueWords includes: value asLowercase)				ifTrue: [ ^ true ]				ifFalse: [					(self class booleanSQLFalseWords includes: value asLowercase)						ifTrue: [ ^ false ]						ifFalse: [ SQLite3AbstractError signal: 'Column value cannot be read as a boolean.' ]]].	(selector = #integerAt:)		ifTrue: [			value := self apiColumnInt: aStatement atColumn: aColumn.			(value = 1)				ifTrue: [ ^ true ]				ifFalse: [					(value = 0)						ifTrue: [ ^ false ]						ifFalse: [ SQLite3AbstractError signal: 'Column value cannot be read as a boolean.' ]]]! !!SQLite3Library methodsFor: 'introspection'!changes: aHandle	^ self apiChanges: aHandle! !!SQLite3Library methodsFor: 'private - utilities'!checkForOk: anInteger on: aHandle	^ self sqlite3ResultFor: anInteger ifNoneMatch: [		 (SQLite3NativeError forNativeErrorCode: anInteger messageText: (self apiErrorMessage: aHandle)) signal ]! !!SQLite3Library methodsFor: 'cleaning'!clearBindings: sHandle on: dbHandle	^ self checkForOk: (self apiClearBindings: sHandle) on: dbHandle! !!SQLite3Library methodsFor: 'connection handling'!close: aHandle	^ self apiClose: aHandle! !!SQLite3Library methodsFor: 'connection handling'!columnCount: aStatementHandle	^ self apiColumnCount: aStatementHandle! !!SQLite3Library methodsFor: 'accessing'!dataValuesAvailable: aStatementHandle	^ self apiDataCount: aStatementHandle! !!SQLite3Library methodsFor: 'connection handling'!dbHandle: statementHandle	^self apiDBHandle: statementHandle! !!SQLite3Library methodsFor: 'configuring'!disableLoadExtension: aHandle	^ self checkForOk: (self apiConfigLoadExtension: aHandle with: 1005 with: 0 with: ExternalAddress new)		on: aHandle"Magic number 1005 = SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION.See comment in #apiConfigLoadExtension:with:with:with:."! !!SQLite3Library methodsFor: 'configuring'!enableLoadExtension: aHandle	^ self checkForOk: (self apiConfigLoadExtension: aHandle with: 1005 with: 1 with: ExternalAddress new)		on: aHandle"Magic number 1005 = SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION.See comment in #apiConfigLoadExtension:with:with:with:."! !!SQLite3Library methodsFor: 'operating'!execute: anSQLText on: aDBHandle	| null |	null := ExternalAddress new.	^ self checkForOk: (self apiExec: aDBHandle							withSQLText: anSQLText							with: null							with: null							with: null)		 on: aDBHandle! !!SQLite3Library methodsFor: 'operating'!finalize: aStatementHandle on: aDBHandle	| result |	result := self checkForOk: (self apiFinalize: aStatementHandle) on: aDBHandle.	aStatementHandle beNull.	^ result! !!SQLite3Library methodsFor: 'accessing'!floatFrom: aStatement at: aColumn	^ self apiColumnDouble: aStatement atColumn: aColumn! !!SQLite3Library methodsFor: 'accessing'!getAutoCommit: aHandle	^ (self apiGetAutocommit: aHandle) ~= 0! !!SQLite3Library methodsFor: 'operating'!integerFrom: aStatement at: aColumn	^ self apiColumnInt: aStatement atColumn: aColumn! !!SQLite3Library methodsFor: 'testing'!isThreadsafe	"http://sqlite.org/c3ref/threadsafe.html"	^ self apiThreadsafe! !!SQLite3Library methodsFor: 'accessing'!lastInsertRowId: dbHandle	^ self apiLastInsertRowid: dbHandle! !!SQLite3Library methodsFor: 'private - accessing'!library	^self libraryName! !!SQLite3Library methodsFor: 'accessing'!libraryVersion	"See http://sqlite.org/c3ref/libversion.html"	^self apiLibVersion! !!SQLite3Library methodsFor: 'private - api'!loadExtension: dbHandle with: aFilename	^ self checkForOk: (self apiLoadExtension: dbHandle										with: aFilename										with: ExternalAddress new										with: ExternalAddress new)		on: dbHandle! !!SQLite3Library methodsFor: 'private - accessing'!macLibraryName	| pluginDir |	pluginDir := FileSystem /'usr'/'lib'.	#('libsqlite3.dylib' 'libsqlite3.0.dylib' 'sqlite3/libtclsqlite3.dylib')		detect: [ :each | (pluginDir / each) exists ]		ifFound: [ :libName | ^ (pluginDir / libName) fullName  ].	self error: 'Module not found.'! !!SQLite3Library methodsFor: 'accessing'!nameFor: aStatement at: aColumn	^ self apiColumnName: aStatement atColumn: aColumn! !!SQLite3Library methodsFor: 'connection handling'!open: aFilename via: aHandle	^ self checkForOk: (self apiOpen: aFilename via: aHandle) on: aHandle! !!SQLite3Library methodsFor: 'accessing'!open: aFilename withFlags: flags vfs: vfs via: aHandle	^ self checkForOk: (self apiOpen: aFilename withFlags: flags vfs: vfs via: aHandle) on: aHandle! !!SQLite3Library methodsFor: 'accessing'!open: aFilename withFlags: flags via: aHandle	^ self checkForOk: (self apiOpen: aFilename withFlags: flags vfs: nil via: aHandle) on: aHandle! !!SQLite3Library methodsFor: 'private - conversion'!pharoStringToUTF8: aPharoString	"Converts from Pharo Multibyte Characters to SQLite3 UTF-8 storage format"	^ZnUTF8Encoder new encodeString: aPharoString! !!SQLite3Library methodsFor: 'operating'!prepare: aStatementHandle on: aDBHandle with: anSQLText	| utf8SQL |	utf8SQL := self pharoStringToUTF8: anSQLText.	^ self checkForOk: (self apiPrepare: aDBHandle							withSQLText: utf8SQL							with: utf8SQL size							with: aStatementHandle							with: (ExternalAddress new))		 on: aDBHandle! !!SQLite3Library methodsFor: 'cleaning'!reset: aStatementHandle	^ aStatementHandle		ifNil: [ 0 ]		ifNotNil: [ self apiReset: aStatementHandle ]! !!SQLite3Library methodsFor: 'private - utilities'!signal: exceptionClass with: value on: handle	(exceptionClass new)		resultCode: value;		signal: (self apiErrorMessage: handle)! !!SQLite3Library methodsFor: 'stepping'!sqlText: aStatementHandle	^ self apiSql: aStatementHandle! !!SQLite3Library methodsFor: 'private - utilities'!sqlite3ResultFor: anInteger ifNoneMatch: aBlock	^[		SQLite3Result forNativeResultCode: anInteger	] on: NotFound do: aBlock! !!SQLite3Library methodsFor: 'stepping'!statementReadOnly: handle	"int sqlite3_stmt_readonly(sqlite3_stmt *pStmt)"	^ (self apiStatementReadOnly: handle) ~= 0! !!SQLite3Library methodsFor: 'stepping'!step: aStatementHandle	^ self apiStep: aStatementHandle! !!SQLite3Library methodsFor: 'testing'!threadsafe	"This method is deprecated so consider to migrate."	self deprecated:  'Please use #isThreadsafe instead' transformWith:  '`@receiver threadsafe'						-> '`@receiver isThreadsafe'.	^ self isThreadsafe! !!SQLite3Library methodsFor: 'introspection'!totalChanges: aHandle	^ self apiTotalChanges: aHandle! !!SQLite3Library methodsFor: 'tracing'!trace: handle with: callback with: appdata	^ self apiTrace: handle with: callback with: appdata! !!SQLite3Library methodsFor: 'private - utilities'!typeFor: aStatement at: aColumn	| selector declared |	declared := self apiColumnDeclaredType: aStatement atColumn: aColumn.	declared ifNotNil: [ "Handle column type of boolean as a special case."		(self class booleanTypes includes: declared) ifTrue: [ ^ #booleanAt: ] ].	selector := DataTypeMap at: (self apiColumnType: aStatement atColumn: aColumn).	selector = #stringAt: ifTrue: [		declared ifNotNil: [ "Handle column type of date/time as a special case."			^ DateTimeTypeMap at: declared asLowercase ifAbsent: [ selector ] ] ].	^ selector! !!SQLite3Library methodsFor: 'private - accessing'!unix32LibraryName	(#('/usr/lib/i386-linux-gnu' '/usr/lib32' '/usr/lib'),			((OSEnvironment current at: 'LD_LIBRARY_PATH' ifAbsent: [ '' ]) substrings: ':'))		do: [ :path |			#('libsqlite3.so.0' 'libsqlite3.so') do: [ :libraryName |			| libraryPath |			libraryPath := path asFileReference / libraryName.			libraryPath exists				ifTrue: [ ^ libraryPath fullName ] ] ].	self error: 'Module not found.'! !!SQLite3Library methodsFor: 'private - accessing'!unix64LibraryName	(#('/usr/lib/x86_64-linux-gnu' '/lib/x86_64-linux-gnu' '/usr/lib'),			((OSEnvironment current at: 'LD_LIBRARY_PATH' ifAbsent: [ '' ]) substrings: ':'))		do: [ :path |			#('libsqlite3.so.0' 'libsqlite3.so') do: [ :libraryName |				| libraryPath |				libraryPath := path asFileReference /  libraryName.				libraryPath exists					ifTrue: [ ^ libraryPath fullName ]]].	self error: 'Module not found.'! !!SQLite3Library methodsFor: 'private - accessing'!win32LibraryName	^ 'sqlite3'! !!SQLite3Library methodsFor: 'operating'!with: aStatement at: aColumn putBlob: aByteArray	^ self		  apiBindBlob: aStatement		  atColumn: aColumn		  with: aByteArray		  with: aByteArray size		  with: 0! !!SQLite3Library methodsFor: 'operating'!with: aStatement at: aColumn putFloat: aFloat	^ self apiBindDouble: aStatement atColumn: aColumn with: aFloat! !!SQLite3Library methodsFor: 'operating'!with: aStatement at: aColumn putInteger: anInteger	^ self apiBindInteger: aStatement atColumn: aColumn with: anInteger! !!SQLite3Library methodsFor: 'operating'!with: aStatement at: aColumn putText: aString	| bytes |	bytes := self pharoStringToUTF8: aString.	^ self		  apiBindText: aStatement		  atColumn: aColumn		  with: bytes		  with: bytes size		  with: 0! !!SQLite3Library methodsFor: 'operating'!with: aStatement putNullAt: aColumn	^ self apiBindNull: aStatement atColumn: aColumn! !!SQLite3Abort class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_ABORT! !!SQLite3AbortRollback class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_ABORT_ROLLBACK! !!SQLite3AuthorizationDenied class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_AUTH! !!SQLite3Busy class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_BUSY! !!SQLite3BusyRecovery class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_BUSY_RECOVERY! !!SQLite3BusySnapshot class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_BUSY_SNAPSHOT! !!SQLite3CantOpen class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_CANTOPEN! !!SQLite3CantOpenConvertPath class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_CANTOPEN_CONVPATH! !!SQLite3CantOpenFullPath class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_CANTOPEN_FULLPATH! !!SQLite3CantOpenIsDir class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_CANTOPEN_ISDIR! !!SQLite3CantOpenNoTempDir class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_CANTOPEN_NOTEMPDIR! !!SQLite3ConstraintViolation class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_CONSTRAINT! !!SQLite3ConstraintViolationCheck class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_CONSTRAINT_CHECK! !!SQLite3ConstraintViolationCommitHook class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_CONSTRAINT_COMMITHOOK! !!SQLite3ConstraintViolationForeignKey class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_CONSTRAINT_FOREIGNKEY! !!SQLite3ConstraintViolationFunction class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_CONSTRAINT_FUNCTION! !!SQLite3ConstraintViolationNotNull class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_CONSTRAINT_NOTNULL! !!SQLite3ConstraintViolationPrimaryKey class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_CONSTRAINT_PRIMARYKEY! !!SQLite3ConstraintViolationRowID class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_CONSTRAINT_ROWID! !!SQLite3ConstraintViolationTrigger class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_CONSTRAINT_TRIGGER! !!SQLite3ConstraintViolationUnique class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_CONSTRAINT_UNIQUE! !!SQLite3ConstraintViolationVirtualTable class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_CONSTRAINT_VTAB! !!SQLite3Corrupt class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_CORRUPT! !!SQLite3CorruptVirtualTable class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_CORRUPT_VTAB! !!SQLite3Empty class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_EMPTY! !!SQLite3Error class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_ERROR! !!SQLite3Format class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_FORMAT! !!SQLite3Full class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_FULL! !!SQLite3IOError class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR! !!SQLite3IOErrorAccess class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_ACCESS! !!SQLite3IOErrorBlocked class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_BLOCKED! !!SQLite3IOErrorCheckReservedLock class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_CHECKRESERVEDLOCK! !!SQLite3IOErrorClose class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_CLOSE! !!SQLite3IOErrorConvertPath class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_CONVPATH! !!SQLite3IOErrorDelete class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_DELETE! !!SQLite3IOErrorDeleteNoEntry class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_DELETE_NOENT! !!SQLite3IOErrorDirClose class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_DIR_CLOSE! !!SQLite3IOErrorDirFSync class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_DIR_FSYNC! !!SQLite3IOErrorFStat class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_FSTAT! !!SQLite3IOErrorFSync class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_FSYNC! !!SQLite3IOErrorGetTempPath class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_GETTEMPPATH! !!SQLite3IOErrorLock class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_LOCK! !!SQLite3IOErrorMemoryMap class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_MMAP! !!SQLite3IOErrorNoMemory class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_NOMEM! !!SQLite3IOErrorRead class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_READ! !!SQLite3IOErrorReadLock class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_RDLOCK! !!SQLite3IOErrorSeek class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_SEEK! !!SQLite3IOErrorSharedMemoryError class methodsFor: 'testing'!isAbstract	^self name = #SQLite3IOErrorSharedMemoryError! !!SQLite3IOErrorSharedMemoryLock class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_SHMLOCK! !!SQLite3IOErrorSharedMemoryMap class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_SHMMAP! !!SQLite3IOErrorSharedMemoryOpen class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_SHMOPEN! !!SQLite3IOErrorSharedMemorySize class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_SHMSIZE! !!SQLite3IOErrorShortRead class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_SHORT_READ! !!SQLite3IOErrorTruncate class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_TRUNCATE! !!SQLite3IOErrorUnlock class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_UNLOCK! !!SQLite3IOErrorWrite class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_IOERR_WRITE! !!SQLite3Internal class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_INTERNAL! !!SQLite3Interrupt class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_INTERRUPT! !!SQLite3Locked class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_LOCKED! !!SQLite3LockedSharedCache class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_LOCKED_SHAREDCACHE! !!SQLite3LogNotice class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_NOTICE! !!SQLite3LogNoticeRecoverRollback class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_NOTICE_RECOVER_ROLLBACK! !!SQLite3LogNoticeRecoverWriteAheadLogging class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_NOTICE_RECOVER_WAL! !!SQLite3LogWarning class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_WARNING! !!SQLite3LogWarningAutoIndex class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_WARNING_AUTOINDEX! !!SQLite3Mismatch class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_MISMATCH! !!SQLite3Misuse class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_MISUSE! !!SQLite3NativeError class methodsFor: 'examples'!example	(SQLite3NativeError forNativeErrorCode: SQLITE_INTERRUPT  messageText: 'Interrupted') signal! !!SQLite3NativeError class methodsFor: 'accessing'!forNativeErrorCode: anInteger messageText: aString	^(self subclassForNativeErrorCode: anInteger) new			messageText: aString;			yourself! !!SQLite3NativeError class methodsFor: 'testing'!isAbstract	^self name = #SQLite3NativeError! !!SQLite3NativeError class methodsFor: 'private - accessing'!nativeErrorCode	"Returns the native error code as defined by SQLite C library."	^ self subclassResponsibility! !!SQLite3NativeError class methodsFor: 'private - accessing'!subclassForNativeErrorCode: anInteger	^ self subclasses		detect: [ :subclass | subclass nativeErrorCode = anInteger ]! !!SQLite3NoLargeFileSupport class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_NOLFS! !!SQLite3NoMemory class methodsFor: 'private - accessing'!nativeErrorCode	^SQLITE_NOMEM! !!SQLite3NotADatabase class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_NOTADB! !!SQLite3NotFound class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_NOTFOUND! !!SQLite3OutOfRange class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_RANGE! !!SQLite3Permission class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_PERM! !!SQLite3Protocol class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_PROTOCOL! !!SQLite3ReadOnly class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_READONLY! !!SQLite3ReadOnlyCantLock class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_READONLY_CANTLOCK! !!SQLite3ReadOnlyDBMoved class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_READONLY_DBMOVED! !!SQLite3ReadOnlyRecovery class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_READONLY_RECOVERY! !!SQLite3ReadOnlyRollback class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_READONLY_ROLLBACK! !!SQLite3SchemaChanged class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_SCHEMA! !!SQLite3TooBig class methodsFor: 'private - accessing'!nativeErrorCode	^ SQLITE_TOOBIG! !!SQLite3PreparedStatement methodsFor: 'bindings'!at: aColumn putBoolean: aBoolean	^ self library		with: handle		at: aColumn		putInteger: (aBoolean ifTrue: [ 1 ] ifFalse: [ 0 ])"See http://www.sqlite.org/datatype3.html."! !!SQLite3PreparedStatement methodsFor: 'bindings'!at: aColumn putByteArray: anObject	| byteArray |	byteArray := self bindingAt: anObject ifAbsentPut: [ anObject ].	^ self library with: handle at: aColumn putBlob: byteArray! !!SQLite3PreparedStatement methodsFor: 'bindings'!at: aColumn putDate: aDate	| string |	string := self bindingAt: aDate ifAbsentPut: [		          String streamContents: [ :stream |			          BasicDatePrinter new printDate: aDate format: #(  ) on: stream ] ].	^ self library with: handle at: aColumn putText: string! !!SQLite3PreparedStatement methodsFor: 'bindings'!at: aColumn putDateTime: aDateTime	| string |	string := self		     bindingAt: aDateTime		     ifAbsentPut: [ String streamContents: [ :stream | aDateTime asDateAndTime printOn: stream ] ].	^ self library with: handle at: aColumn putText: string! !!SQLite3PreparedStatement methodsFor: 'bindings'!at: aColumn putFloat: aFloat	| f |	f := (aFloat isKindOf: Fraction)		ifTrue: [ aFloat asFloat ]		ifFalse: [ aFloat ].	^ self library with: handle at: aColumn putFloat: f! !!SQLite3PreparedStatement methodsFor: 'bindings'!at: aColumn putInteger: anInteger	^ self library with: handle at: aColumn putInteger: anInteger! !!SQLite3PreparedStatement methodsFor: 'bindings'!at: aColumn putNil: anObject	"Goofy interface note - anObject is ignored here."	"When used by SQLite3Connection, anObject will always be nil."	^ self library with: handle putNullAt: aColumn! !!SQLite3PreparedStatement methodsFor: 'bindings'!at: aColumn putObject: anObject	| blob |	blob := self bindingAt: anObject ifAbsentPut: [ FLSerializer serializeToByteArray: anObject ].	^ self library		  with: handle		  at: aColumn		  putBlob: blob! !!SQLite3PreparedStatement methodsFor: 'bindings'!at: aColumn putString: aString	| s |	s := self bindingAt: aString ifAbsentPut: [ aString ].	^ self library with: handle at: aColumn putText: s! !!SQLite3PreparedStatement methodsFor: 'bindings'!at: aColumn putTime: aTime	| string |	string := self		          bindingAt: aTime		          ifAbsentPut: [ String streamContents: [ :stream | aTime printOn: stream ] ].	^ self library with: handle at: aColumn putText: string! !!SQLite3PreparedStatement methodsFor: 'public'!basicExecute: aBlock	| ret |	ret := self step.	(ret = SQLITE_DONE) " == SQLITE_DONE, meaning step should not be sent again."		ifTrue: [ aBlock value: self ]		ifFalse: [			[ ret = SQLITE_ROW ] whileTrue: [ " == SQLITE_ROW, meaning another row is available."				aBlock value: self.				ret := self step ]]! !!SQLite3PreparedStatement methodsFor: 'bindings'!bindParameterCount	^ self library bindParameterCount: handle! !!SQLite3PreparedStatement methodsFor: 'bindings'!bindParameterIndex: aName	^ self library bindParameterIndex: handle for: aName! !!SQLite3PreparedStatement methodsFor: 'bindings'!bindParameters: parameters	"A 'variable' or 'parameter' token specifies a placeholder in the expression for a value that is filled in at runtime using the sqlite3_bind() family of C/C++ interfaces. Parameters can take several forms:?NNN		A question mark followed by a number NNN holds a spot for the NNN-th parameter. NNN must be between 1 and SQLITE_MAX_VARIABLE_NUMBER.?		A question mark that is not followed by a number creates a parameter with a number one greater than the largest parameter number already assigned. If this means the parameter number is greater than SQLITE_MAX_VARIABLE_NUMBER, it is an error. This parameter format is provided for compatibility with other database engines. But because it is easy to miscount the question marks, the use of this parameter format is discouraged. Programmers are encouraged to use one of the symbolic formats below or the ?NNN format above instead.:AAAA		A colon followed by an identifier name holds a spot for a named parameter with the name :AAAA. Named parameters are also numbered. The number assigned is one greater than the largest parameter number already assigned. If this means the parameter would be assigned a number greater than SQLITE_MAX_VARIABLE_NUMBER, it is an error. To avoid confusion, it is best to avoid mixing named and numbered parameters.@AAAA		An 'at' sign works exactly like a colon, except that the name of the parameter created is @AAAA.$AAAA		A dollar-sign followed by an identifier name also holds a spot for a named parameter with the name $AAAA. The identifier name in this case can include one or more occurrences of '::' and a suffix enclosed in '(...)' containing any text at all. This syntax is the form of a variable name in the Tcl programming language. The presence of this syntax results from the fact that SQLite is really a Tcl extension that has escaped into the wild.Parameters that are not assigned values using sqlite3_bind() are treated as NULL. The sqlite3_bind_parameter_index() interface can be used to translate a symbolic parameter name into its equivalent numeric index."	(parameters isCollection and: [ parameters isString not ]) ifFalse: [		SQLite3AbstractError signal:			'Unable to execute SQL on instance of ' , parameters class asString ].	parameters keysAndValuesDo: [ :k :v |		| idx |		k isInteger			ifTrue: [ idx := k ]			ifFalse: [				idx := self bindParameterIndex: k.				idx = 0 ifTrue: [ idx := self bindParameterIndex: '@' , k ].				idx = 0 ifTrue: [ idx := self bindParameterIndex: ':' , k ].				idx = 0 ifTrue: [ idx := self bindParameterIndex: '$' , k ].				(idx = 0 and: [ k isAllDigits ]) ifTrue: [ idx := k asInteger ] ].		idx > 0 ifTrue: [			self perform: (self dataTypeForObject: v) with: idx with: v ] ]! !!SQLite3PreparedStatement methodsFor: 'bindings'!bindingAt: anObject ifAbsentPut: aBlock	^bindings at: anObject ifAbsentPut: aBlock! !!SQLite3PreparedStatement methodsFor: 'fetching'!booleanAt: aColumn	^self library booleanFrom: handle at: aColumn! !!SQLite3PreparedStatement methodsFor: 'fetching'!byteArrayAt: aColumn	^ self library blobFrom: handle at: aColumn! !!SQLite3PreparedStatement methodsFor: 'public - accessing'!changes	^changes ifNil: [ changes := 0 ]! !!SQLite3PreparedStatement methodsFor: 'private'!checkOk: aValue	"These are normal conditions."	aValue = SQLITE_OK ifTrue: [ ^aValue ].	"These are error conditions."	(aValue = SQLITE_BUSY)		ifTrue: [ connection signal: SQLite3Busy with: aValue ].	(aValue = SQLITE_MISUSE)		ifTrue: [ connection signal: SQLite3Misuse with: aValue ].	"Catch any error not specifically handled above."	connection signal: SQLite3AbstractError with: aValue! !!SQLite3PreparedStatement methodsFor: 'bindings'!clearBindings	| cleared |	cleared := self library clearBindings: handle on: connection handle.	bindings removeAll.	^cleared! !!SQLite3PreparedStatement methodsFor: 'public'!columnCount	^self library columnCount: handle! !!SQLite3PreparedStatement methodsFor: 'public - accessing'!columnNames	^ columnNames ifNil: [		  columnNames := (1 to: self columnCount) collect: [ :c | self nameOfColumn: c - 1 ].		  columnNames ]! !!SQLite3PreparedStatement methodsFor: 'private - accessing'!connection: anObject	connection := anObject! !!SQLite3PreparedStatement methodsFor: 'bindings'!dataTypeForObject: anObject	anObject ifNil: [ ^ #at:putNil: ].	( anObject isKindOf: Boolean )		ifTrue: [ ^ #at:putBoolean: ].	( anObject isKindOf: Integer )		ifTrue: [ ^ #at:putInteger: ].	( self isFloatLike: anObject )		ifTrue: [ ^ #at:putFloat: ].	( anObject isKindOf: String )		ifTrue: [ ^ #at:putString: ].	( anObject isKindOf: ByteArray )		ifTrue: [ ^ #at:putByteArray: ].	( anObject isKindOf: DateAndTime )		ifTrue: [ ^ #at:putDateTime: ].	( anObject isKindOf: Time )		ifTrue: [ ^ #at:putTime: ].	( anObject isKindOf: Date )		ifTrue: [ ^ #at:putDate: ].	^ #at:putObject:! !!SQLite3PreparedStatement methodsFor: 'public - accessing'!dataValuesAvailable	^ self library dataValuesAvailable: handle! !!SQLite3PreparedStatement methodsFor: 'fetching'!dateAt: aColumn	^ Date fromString: ( self stringAt: aColumn )! !!SQLite3PreparedStatement methodsFor: 'fetching'!dateTimeAt: aColumn	^ DateAndTime fromString: ( self stringAt: aColumn )! !!SQLite3PreparedStatement methodsFor: 'private - accessing'!dbHandle	^(self library dbHandle: handle)! !!SQLite3PreparedStatement methodsFor: 'operating'!execute: parameters	| result |	self checkOk: self reset.	self clearBindings.	self bindParameters: parameters.	result := self step.	changes := connection changes.	^ SQLite3Cursor on: self! !!SQLite3PreparedStatement methodsFor: 'initialization'!finalize	"Finalize the statement as required by the SQLite3 API. As per the API, the user is expected to finalize a statement after use.	Since executing a new statement without having finalized the previous one might cause SQLITE_BUSY errors, we can't rely on the garbage collector to execute the finalization, or we'll be exposed to non-deterministic behaviour."	handle		ifNotNil:			[ "Remove the statement object from its finalization registry. This should happen before the actual finalization to avoid finalizing the statement twice, which might result in 'undefined and undesirable behavior such as segfaults and heap corruption' as per the SQLite3 API"			handle manualRelease.			connection finalize: handle.			handle := nil ].	^ 0! !!SQLite3PreparedStatement methodsFor: 'fetching'!floatAt: aColumn	^self library floatFrom: handle at: aColumn! !!SQLite3PreparedStatement methodsFor: 'private - accessing'!handle	^ handle! !!SQLite3PreparedStatement methodsFor: 'initialization'!initialize	super initialize.	bindings := IdentityDictionary new.	handle := SQLite3StatementExternalObject new.	handle autoRelease! !!SQLite3PreparedStatement methodsFor: 'fetching'!integerAt: aColumn	^self library integerFrom: handle at: aColumn! !!SQLite3PreparedStatement methodsFor: 'private - testing'!isFloatLike: anObject	^ (anObject isKindOf: Float) or: [ anObject isKindOf: Fraction ]! !!SQLite3PreparedStatement methodsFor: 'public - accessing'!isReadOnly	^self library statementReadOnly: handle! !!SQLite3PreparedStatement methodsFor: 'private - accessing'!library	^SQLite3Library current! !!SQLite3PreparedStatement methodsFor: 'fetching'!nameOfColumn: aColumn	^ self library nameFor: handle at: aColumn! !!SQLite3PreparedStatement methodsFor: 'fetching'!nilAt: aColumn	^ nil! !!SQLite3PreparedStatement methodsFor: 'fetching'!objectAt: aColumn	^ FLMaterializer materializeFromByteArray: (self library blobFrom: handle at: aColumn)! !!SQLite3PreparedStatement methodsFor: 'public'!prepare: anSQLText	self library prepare: handle on: connection handle with: anSQLText! !!SQLite3PreparedStatement methodsFor: 'public'!reset	^connection reset: self! !!SQLite3PreparedStatement methodsFor: 'operating'!sqlText	^ self library sqlText: handle! !!SQLite3PreparedStatement methodsFor: 'public'!step	^ self stepOk: (self library step: handle)! !!SQLite3PreparedStatement methodsFor: 'private'!stepOk: aValue	"These are normal conditions."	(aValue = SQLITE_ROW or: [aValue = SQLITE_DONE]) ifTrue: [		changes := connection changes.		^aValue  ].	"These are error conditions."	(aValue = SQLITE_BUSY)		ifTrue: [ connection signal: SQLite3Busy with: aValue ].	(aValue = SQLITE_MISUSE)		ifTrue: [ connection signal: SQLite3Misuse with: aValue ].	(aValue = SQLITE_CONSTRAINT)		ifTrue:  [ connection signal: SQLite3ConstraintViolation with: aValue].	"Catch any error not specifically handled above."	connection signal: SQLite3AbstractError with: aValue! !!SQLite3PreparedStatement methodsFor: 'fetching'!stringAt: aColumn	"Answer the string from the specified column"	"#stringFrom:at: is supplied in a version specific package.	If there are no implementers the appropriate package needs to be loaded. :-)"	^ self library stringFrom: handle at: aColumn! !!SQLite3PreparedStatement methodsFor: 'fetching'!timeAt: aColumn	^ Time fromString: ( self stringAt: aColumn )! !!SQLite3PreparedStatement methodsFor: 'fetching'!timestampAt: aColumn	^ DateAndTime fromString: ( self stringAt: aColumn )! !!SQLite3PreparedStatement methodsFor: 'fetching'!typeOfColumn: aColumn	^ self library typeFor: handle at: aColumn! !!SQLite3PreparedStatement methodsFor: 'fetching'!valueOfColumn: aColumn	^ self perform: (self typeOfColumn: aColumn) with: aColumn! !!SQLite3DoneResult class methodsFor: 'private - accessing'!nativeResultCode	^ SQLITE_DONE! !!SQLite3OKResult class methodsFor: 'private - accessing'!nativeResultCode	^ SQLITE_OK! !!SQLite3Result class methodsFor: 'accessing'!forNativeResultCode: anInteger	^ (self subclassForNativeResultCode: anInteger) new! !!SQLite3Result class methodsFor: 'testing'!isAbstract	^self name = #SQLite3Result! !!SQLite3Result class methodsFor: 'private - accessing'!nativeResultCode	^ self subclassResponsibility! !!SQLite3Result class methodsFor: 'private - accessing'!subclassForNativeResultCode: anInteger	^ self subclasses		detect: [ :subclass | subclass nativeResultCode = anInteger ]! !!SQLite3RowResult class methodsFor: 'private - accessing'!nativeResultCode	^ SQLITE_ROW! !"SQLite3-Core"!!SQLite3Benchmark commentStamp: '' prior: 0!Benchmarking harness.!!ManifestSQLite3CoreBenchmarks commentStamp: '' prior: 0!Please describe the package using the class comment of the included manifest class. The manifest class also includes other additional metadata for the package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!SQLite3Benchmark methodsFor: 'running'!basicExecute: anSQLText times: aCount	db beginTransaction.	1 to: aCount do: [ :i |		db basicExecute: anSQLText ].	db commitTransaction! !!SQLite3Benchmark methodsFor: 'connecting-disconnecting'!connectBy: aConnectionClass	db := aConnectionClass openOn: ':memory:'! !!SQLite3Benchmark methodsFor: 'connecting-disconnecting'!disconnect	db close! !!SQLite3Benchmark methodsFor: 'running'!execute: anSQLText times: aCount bindingsBlock: bindingsBlock	db beginTransaction.	1 to: aCount do: [ :i |		db execute: anSQLText with: (bindingsBlock value: i) ].	db commitTransaction! !!SQLite3Benchmark methodsFor: 'running'!finalizeStatement	stmt ifNotNil: [ stmt finalize ]! !!SQLite3Benchmark methodsFor: 'running'!prepStep: anSQLText times: aCount bindingsBlock: bindingsBlock	stmt := db prepare: anSQLText.	db beginTransaction.	1 to: aCount do: [ :i |		bindingsBlock value: stmt value: i.		stmt step; clearBindings; reset ].	db commitTransaction! !!SQLite3Benchmark methodsFor: 'running'!runBlock: aBlock	db beginTransaction.	aBlock value: db.	db commitTransaction! !!ManifestSQLite3CoreBenchmarks class methodsFor: 'code coverage'!classNamesNotUnderTest	^ #( ManifestSQLite3CoreBenchmarks )! !!ManifestSQLite3CoreBenchmarks class methodsFor: 'code-critics'!ruleClassNotReferencedRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#SQLite3Benchmark)) #'2022-05-10T08:25:40.035+02:00') )! !"SQLite3-Core-Benchmarks"!!SQLite3Library methodsFor: '*SQLite3-Pharo9'!stringFrom: aStatement at: aColumn	^ self apiColumnText: aStatement atColumn: aColumn! !!Random methodsFor: '*SQLite3-Pharo10'!nextInt: anInteger	^ self nextInteger: anInteger! !!SQLite3BaseConnectionTest commentStamp: '' prior: 0!Unit tests for SQLiteBaseConnection!!SQLite3ConnectionTest commentStamp: '' prior: 0!Unit tests for SQLiteConnection!!SQLite3DatabaseTest commentStamp: '' prior: 0!A test class for `SQLite3Database`!!SQLite3RowTest commentStamp: '' prior: 0!Unit tests for SQLite3Row!!SQLite3TableTest commentStamp: '' prior: 0!A test class for `SQLite3Table`!!ManifestSQLite3CoreTests commentStamp: '' prior: 0!Please describe the package using the class comment of the included manifest class. The manifest class also includes other additional metadata for the package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!SQLite3BaseConnectionTest methodsFor: 'tests - DEACTIVATED'!deactivatedTestTracing	| sql callback expected actual  |	(SystemVersion current major >= 7) ifTrue: [ self skip ].	"This test invokes a callback from SQLite to Pharo. It works in Pharo 6 and earlier but not in Pharo 7."	sql := #('create table if not exists x (xk integer primary key, iv integer, tv text)'			'insert into x values (NULL, 1, ''two'')'			'drop table x').	expected := String streamContents: [ :s |		s nextPutAll: sql first; cr;			nextPutAll: sql second; cr;			nextPutAll: sql third; cr ].	actual := WriteStream on: String new.	callback := FFICallback						signature: #(void (ExternalAddress appData, String sqlText))						block: [ :appdata :sqltext |							"We ignore appdata in this test, because we're passing a null pointer in."							actual nextPutAll: sqltext; cr ].	"The null pointer appears as appdata in the callback."	db traceUsing: callback with: ExternalAddress new.	res := db basicExecute: sql first.	self assert: res equals: 0.	res := db basicExecute: sql second.	self assert: res equals: 0.	res := db basicExecute: sql third.	self assert: res equals: 0.	self assert: actual contents equals: expected! !!SQLite3BaseConnectionTest methodsFor: 'private'!executeInDB: anSQLText	| result |	result := db basicExecute: anSQLText.	self assert: result equals: 0! !!SQLite3BaseConnectionTest methodsFor: 'utilities'!getTempPath	| env |	env := Smalltalk os environment.	^ Smalltalk os isWindows		  ifTrue: [ "See https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-gettemppath2a"			  (env				   at: 'TMP'				   ifAbsent: [ env at: 'TEMP' ifAbsent: [ env at: 'USERPROFILE' ] ])			  , '\' ]		  ifFalse: [ "See https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html"			(env at: 'TMPDIR' ifAbsent: ['/tmp']), '/' ]! !!SQLite3BaseConnectionTest methodsFor: 'utilities'!invalidFileNameOnCurrentOperatingSystem	^Smalltalk os isWindows		ifTrue: [ '/&*no' ]		ifFalse: [ '/nosuchfile' ]! !!SQLite3BaseConnectionTest methodsFor: 'utilities'!newUniqueFileName	^ self getTempPath , UUID new asString! !!SQLite3BaseConnectionTest methodsFor: 'tests'!noTestColumnNamesBobbyGo	"In this test, Bobby Tables strikes naive SQL string construction."	"20190302, pierce: #basicExecute: uses prepare/step/finalize internally and is no longer susceptible to injection attacks. "	| tables bobby |	res := db basicExecute: 'create table x (xk integer, xv integer);'.	self assert: res equals: 0.	res := db basicExecute:		       'create table students (sk integer, sname varchar);'.	self assert: res equals: 0.	tables := db tableNames.	self assert: tables size equals: 2.	self assert: tables first equals: 'x'.	self assert: tables second equals: 'students'.	bobby := 'x); drop table students; --'.	res := db basicExecute: 'pragma table_info(' , bobby , ')'.	self assert: res equals: 0.	tables := db tableNames.	self assert: tables size equals: 1.	self assert: tables first equals: 'x'! !!SQLite3BaseConnectionTest methodsFor: 'running'!setUp	super setUp.	db := SQLite3BaseConnection on: ':memory:'.	db open! !!SQLite3BaseConnectionTest methodsFor: 'running'!tearDown	[ db close ] on: SQLite3Misuse do: [ ].	super tearDown! !!SQLite3BaseConnectionTest methodsFor: 'tests - connections'!testBadOpen	| newConnection |	newConnection := SQLite3BaseConnection on: self invalidFileNameOnCurrentOperatingSystem.	self should: [ newConnection open ] raise: SQLite3CantOpen.	self deny: newConnection isOpen! !!SQLite3BaseConnectionTest methodsFor: 'tests - execution'!testBasicExecuteOk	self executeInDB: 'create table x (xk integer, xv integer);'.	self executeInDB: 'drop table x;'! !!SQLite3BaseConnectionTest methodsFor: 'tests - execution'!testBasicExecuteSyntaxError	self should: [ db basicExecute: 'create table,;' ]		raise: SQLite3AbstractError! !!SQLite3BaseConnectionTest methodsFor: 'tests - types'!testBooleanColumnTypeMismatch	self executeInDB: 'create table x (xk integer primary key, xv notboolean);'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row | self should: [ row booleanAt: 0 ] raise: SQLite3AbstractError ] ]! !!SQLite3BaseConnectionTest methodsFor: 'tests - types'!testBooleanObject	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putObject: true.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row objectAt: 0.			self assert: value equals: true			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing'!testBooleanWriteIntegerOneThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putInteger: 1.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row booleanAt: 0.			self assert: value equals: true			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing'!testBooleanWriteIntegerTwoThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putInteger: 2.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row | self should: [ row booleanAt: 0 ] raise: SQLite3AbstractError ] ]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing'!testBooleanWriteIntegerZeroThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putInteger: 0.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row booleanAt: 0.			self assert: value equals: false			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing'!testBooleanWriteNilThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putNil: nil.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row booleanAt: 0.			self assert: value isNil			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing'!testBooleanWriteSQLNullThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, NULL)' do: [ :statement | statement step ].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row booleanAt: 0.			self assert: value isNil			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing'!testBooleanWriteStringFalseThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putString: 'false'.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row booleanAt: 0.			self assert: value equals: false			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing'!testBooleanWriteStringTrueThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putString: 'true'.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row booleanAt: 0.			self assert: value equals: true			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing'!testBooleanWriteStringTwoThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putString: '2'.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row | self should: [ row booleanAt: 0 ] raise: SQLite3AbstractError ] ]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing'!testBooleanWriteThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putBoolean: true.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row booleanAt: 0.			self assert: value equals: true			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - connections'!testCloseFile	| fileName newConnection |	fileName := self newUniqueFileName.	newConnection := SQLite3BaseConnection on: fileName.	newConnection		open;		close.	newConnection := nil.	Smalltalk garbageCollect.	self		shouldnt: [ File deleteFile: fileName ]		raise: CannotDeleteFileException! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns'!testColumnNames	| columns |	self executeInDB: 'create table x (xk integer, xv integer);'.	columns := db columnNamesFor: 'x'.	self assert: columns size equals: 2.	self assert: columns first equals: 'xk'.	self assert: columns second equals: 'xv'! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns'!testColumnNamesBobbyStop	"In this test, Bobby Tables strikes again, but fails, because #columnNamesFor: uses parameter binding."	| columns tables |	self executeInDB: 'create table x (xk integer, xv integer);'.	self executeInDB: 'create table students (sk integer, sname varchar);'.	tables := db tableNames.	self assert: tables size equals: 2.	self assert: tables first equals: 'x'.	self assert: tables second equals: 'students'.	columns := db columnNamesFor: 'x; drop table students; --'.	self assert: columns isNil.	tables := db tableNames.	self assert: tables size equals: 2.	self assert: tables first equals: 'x'.	self assert: tables second equals: 'students'! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns'!testColumnNamesForNoSuchTableWithSpaces	| columns |	self executeInDB: 'create table x (xk integer, xv integer);'.	columns := db columnNamesFor: 'no such table with spaces'.	self assert: columns isNil! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns'!testColumnNamesForTableWithSpaces	| columns |	self executeInDB: 'create table [table name with spaces] (xk integer, xv integer);'.	columns := db columnNamesFor: 'table name with spaces'.	self assert: columns size equals: 2.	self assert: columns first equals: 'xk'.	self assert: columns second equals: 'xv'! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns'!testColumnNamesNoSuchTable	| columns |	self executeInDB: 'create table x (xk integer, xv integer);'.	columns := db columnNamesFor: 'y'.	self assert: columns isNil! !!SQLite3BaseConnectionTest methodsFor: 'tests - connections'!testConstraintViolation	self		executeInDB: 'create table x (value integer primary key);';		executeInDB: 'insert into x values(1);'.	self should: [ db basicExecute: 'insert into x values(1);' ] raise: SQLite3ConstraintViolation! !!SQLite3BaseConnectionTest methodsFor: 'tests - execution'!testDataValuesAvailable	self executeInDB: 'create table x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'insert into x values (NULL, 1, "duh");'.	self		withPreparedStatement: 'select * from x'		do: [ :statement |		statement basicExecute: [ :row | self assert: row dataValuesAvailable equals: 3 ] ]! !!SQLite3BaseConnectionTest methodsFor: 'tests - types'!testDate	| data |	data := Date year: 2015 month: 4 day: 1.	self executeInDB: 'create table x (xv date);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (?)' do: [ :statement |		statement at: 1 putDateTime: data.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row dateTimeAt: 0.			self				assert: value year equals: 2015;				assert: value month equals: 4;				assert: value dayOfMonth equals: 1			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - types'!testDateAndTime	| data |	data := DateAndTime year: 2015 month: 4 day: 1.	self executeInDB: 'create table x (xv datetime);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (?)' do: [ :statement |		statement at: 1 putDateTime: data.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row dateTimeAt: 0.			self				assert: value year equals: 2015;				assert: value month equals: 4;				assert: value dayOfMonth equals: 1;				assert: value hours equals: 0;				assert: value minutes equals: 0;				assert: value seconds equals: 0			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns'!testDeclaredColumnTypes	| columns |	self executeInDB: 'create table x (xk integer, xv blob, xb boolean);'.	columns := db declaredColumnTypesFor: 'x'.	self assert: columns size equals: 3.	self assert: columns first equals: 'INTEGER'.	self assert: columns second equals: 'BLOB'.	self assert: columns third equals: 'boolean'! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns'!testDeclaredColumnTypesForNoSuchTable	| columns |	self executeInDB: 'create table x (xk integer, xv integer);'.	columns := db declaredColumnTypesFor: 'y'.	self assert: columns isNil! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns'!testDeclaredColumnTypesForNoSuchTableWithSpaces	| columns |	self executeInDB: 'create table x (xk integer, xv integer);'.	columns := db declaredColumnTypesFor: 'no such table with spaces'.	self assert: columns isNil! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns'!testDeclaredColumnTypesForTableWithSpaces	| columns |	self executeInDB: 'create table [table name with spaces] (xk INTEGER, xv BLOB, xb BOOLEAN);'.	columns := db declaredColumnTypesFor: 'table name with spaces'.	self assert: columns size equals: 3.	self assert: columns first equals: 'INTEGER'.	self assert: columns second equals: 'BLOB'.	self assert: columns third equals: 'BOOLEAN'! !!SQLite3BaseConnectionTest methodsFor: 'tests - multilingual'!testDefaultMultilingualStrings	self executeInDB:		'create table x (xk integer primary key, xm1 text default ''中文'', xm2 text default ''áěšřčá'');'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x (xk) values (NULL)' do: [ :statement | statement step ].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xm1, xm2 from x order by xk' do: [ :statement |		statement basicExecute: [ :row |			self assert: ( row stringAt: 0 ) equals: '中文'.			self assert: ( row stringAt: 1 ) equals: 'áěšřčá'			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - connections'!testDoubleClose	db close.	[ db close ] on: SQLite3Misuse do: [ ]	"#tearDown will close the db again, and is similarly guarded."! !!SQLite3BaseConnectionTest methodsFor: 'tests - types'!testFloat	self executeInDB: 'create table x (xk integer primary key, xv real);'.	self executeInDB: 'insert into x values (NULL, 1.141);'.	self withPreparedStatement: 'select * from x' do: [ :statement |		statement basicExecute: [ :row |			self assert: ( row nameOfColumn: 1 ) equals: 'xv'.			self assert: ( row floatAt: 1 ) equals: 1.141			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - types'!testInteger	"The large integer comes from Glorp's testInt8."	self executeInDB: 'create table x (xk integer primary key, xv integer);'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putInteger: 3212321555.		statement step		].	self withPreparedStatement: 'select * from x' do: [ :statement |		statement basicExecute: [ :row |			self assert: ( row nameOfColumn: 1 ) equals: 'xv'.			self assert: ( row integerAt: 1 ) equals: 3212321555			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests'!testIsAbstract	self assert: SQLite3BaseConnection isAbstract! !!SQLite3BaseConnectionTest methodsFor: 'tests'!testIsThreadsafe	self assert: (SQLite3BaseConnection isThreadsafe isKindOf: Boolean)! !!SQLite3BaseConnectionTest methodsFor: 'tests - multilingual'!testMultilingualStrings	| data index |	data := OrderedCollection with: 'English' with: '中文' with: 'にほんご' , 'áěšřčá'.	self executeInDB: 'create table x (xk integer primary key, xv varchar);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		data do: [ :ea |			statement at: 1 putString: ea.			statement				step;				clearBindings;				reset			]		].	self executeInDB: 'commit'.	index := 1.	self withPreparedStatement: 'select xv from x order by xk asc' do: [ :statement |		statement basicExecute: [ :row |			self assert: ( row stringAt: 0 ) equals: ( data at: index ).			index := index + 1			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - multilingual'!testMultilingualTableName	self executeInDB: 'create table 表一 (xk integer primary key, xm1 text default ''中文'');'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into 表一 (xk) values (NULL)' do: [ :statement | statement step ].	self executeInDB: 'commit'.	self		withPreparedStatement: 'select xm1 from 表一 order by xk'		do: [ :statement |		statement basicExecute: [ :row | self assert: ( row stringAt: 0 ) equals: '中文' ] ]! !!SQLite3BaseConnectionTest methodsFor: 'tests - types'!testObjectBlob	| data |	data := OrderedCollection with: 1 with: 'two' with: 3.3.	self		executeInDB: 'create table x (xk integer primary key, xv blob);';		executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putObject: data.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row objectAt: 0.			self				assert: value size equals: 3;				assert: value first equals: 1;				assert: value second equals: 'two';				assert: value third equals: 3.3			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests'!testPrepareStep	self executeInDB: 'create table x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?, ?)' do: [ :statement |		self assert: statement sqlText equals: 'insert into x values (NULL, ?, ?)'.		1 to: 10 do: [ :x |			statement at: 1 putInteger: x * x.			statement at: 2 putString: ( '<1p> * <1p>' expandMacrosWith: x ).			statement step.			statement clearBindings.			statement reset			]		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select * from x' do: [ :statement |		| i |		self assert: statement sqlText equals: 'select * from x'.		statement basicExecute: [ :row |			i := row integerAt: 0.			self assert: ( row integerAt: 1 ) equals: i * i.			self assert: ( row stringAt: 2 ) equals: ( '<1p> * <1p>' expandMacrosWith: i )			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests'!testPrepareStepSelective	| i count |	self executeInDB: 'create table x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?, ?)' do: [ :statement |		self assert: statement sqlText equals: 'insert into x values (NULL, ?, ?)'.		1 to: 10 do: [ :x |			statement				at: 1 putInteger: x * x;				at: 2 putString: x asString , ' * ' , x asString;				step;				clearBindings;				reset			]		].	self executeInDB: 'commit'.	count := 0.	self withPreparedStatement: 'select * from x where iv < ?' do: [ :statement |		self assert: statement sqlText equals: 'select * from x where iv < ?'.		statement at: 1 putInteger: 27.		statement basicExecute: [ :row |			count := count + 1.			i := row integerAt: 0.			self assert: ( row integerAt: 1 ) equals: i * i.			self assert: ( row stringAt: 2 ) equals: i asString , ' * ' , i asString			]		].	self assert: count equals: 5! !!SQLite3BaseConnectionTest methodsFor: 'tests'!testResultSetColumnIntrospection	self executeInDB: 'create table x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'insert into x values (NULL, 1, "duh");'.	self withPreparedStatement: 'select * from x' do: [ :statement |		statement basicExecute: [ :row |			self assert: ( row nameOfColumn: 0 ) equals: 'xk'.			self assert: ( row valueOfColumn: 0 ) equals: 1.			self assert: ( row nameOfColumn: 1 ) equals: 'iv'.			self assert: ( row valueOfColumn: 1 ) equals: 1.			self assert: ( row nameOfColumn: 2 ) equals: 'tv'.			self assert: ( row valueOfColumn: 2 ) equals: 'duh'			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - types'!testScaledDecimal	"This test is a simplified version of GlorpNumericTest>>tesNumeric."	| number float |	number := Number readFrom: '12345678s'.	float := number asFloat.	self executeInDB: 'create table x (xk integer primary key, xv real);'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putFloat: number.		statement step		].	self withPreparedStatement: 'select * from x' do: [ :statement |		statement basicExecute: [ :row |			self				assert: ( row nameOfColumn: 1 ) equals: 'xv';				assert: ( row floatAt: 1 ) equals: float			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - tables'!testTableNames	| tables |	self executeInDB: 'create table x (xk integer, xv integer);'.	tables := db tableNames.	self assert: tables size equals: 1.	self assert: tables first equals: 'x'! !!SQLite3BaseConnectionTest methodsFor: 'tests - tables'!testTableNamesOfEmptyDatabase	| tables |	tables := db tableNames.	self assert: tables isEmpty! !!SQLite3BaseConnectionTest methodsFor: 'tests - types'!testTime	| data |	data := Time noon.	self		executeInDB: 'create table x (xv time);';		executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (?)' do: [ :statement |		statement at: 1 putTime: data.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row timeAt: 0.			self				assert: value hour equals: data hour;				assert: value minute equals: data minute;				assert: value second equals: data second			]		]! !!SQLite3BaseConnectionTest methodsFor: 'private'!withPreparedStatement: anSQLText do: aBlock	| statement |	statement := db prepare: anSQLText.	[ aBlock value: statement ] ensure: [ statement finalize ]! !!SQLite3ColumnTest methodsFor: 'running'!setUp	super setUp.	db := SQLite3Database memory.	db connection open.	db connection execute: self tableCreationScript.	table := db tables first.	firstColumn := table columns first.	secondColumn := table columns second! !!SQLite3ColumnTest methodsFor: 'accessing'!tableCreationScript	^'CREATE TABLE "SAMPLE"(    [ID] INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,    [NAME] NVARCHAR(120))'! !!SQLite3ColumnTest methodsFor: 'running'!tearDown	db connection close.	db := nil.	super tearDown! !!SQLite3ColumnTest methodsFor: 'tests'!testHasNotNullConstraint	self assert: firstColumn hasNotNullConstraint.	self deny: secondColumn hasNotNullConstraint! !!SQLite3ColumnTest methodsFor: 'tests'!testIndex	self assert: firstColumn index equals: 0.	self assert: secondColumn index equals: 1! !!SQLite3ColumnTest methodsFor: 'tests'!testInitialization	| instance |	instance := SQLite3Column new.	self deny: instance hasNotNullConstraint! !!SQLite3ColumnTest methodsFor: 'tests'!testName	self assert: firstColumn name equals: 'ID'.	self assert: secondColumn name equals: 'NAME'! !!SQLite3ColumnTest methodsFor: 'tests'!testPrintString	self assert: firstColumn printString equals: 'a SQLite3Column("ID")'.	self assert: secondColumn printString equals: 'a SQLite3Column("NAME")'! !!SQLite3ColumnTest methodsFor: 'tests'!testType	self assert: firstColumn type equals: 'INTEGER'.	self assert: secondColumn type equals: 'NVARCHAR(120)'! !!SQLite3ConnectionTest methodsFor: 'private'!executeInDB: anSQLText	| result |	result := db basicExecute: anSQLText.	self assert: result equals: 0! !!SQLite3ConnectionTest methodsFor: 'utilities'!populateRowsInto: tableName of: database	| rand rows schema insert rn rt |	 rand := Random new.	rows := rand nextInt: 100.	schema := 'create table ', tableName, ' (rk integer primary key, rn integer, rt text);'.	insert := 'insert into ', tableName, ' values (?, ?, ?)'.	database basicExecute: 'begin'.	database	basicExecute: schema.	1 to: rows do: [ :i |		rn := i * (rand nextInt: 10).		rt := i asString, '-ZZZ'.		database execute: insert with: (Array with: i with: rn with: rt) ].	database basicExecute: 'commit'.	^ rows! !!SQLite3ConnectionTest methodsFor: 'running'!setUp	super setUp.	db := SQLite3Connection memory.	db open! !!SQLite3ConnectionTest methodsFor: 'running'!tearDown	[ db close ] on: SQLite3Misuse do: [ ].	[ target ifNotNil:[target close] ] on: SQLite3Misuse do: [ ].	super tearDown! !!SQLite3ConnectionTest methodsFor: 'tests'!testBackup	| row backup |	target := SQLite3Connection memory.	target open.	self populateRowsInto: 'junk' of: db.	backup := db backupTo: target.	backup open; step; finish.	row := (target execute: 'select * from junk where rt = ''1-ZZZ''') onlyRow.	self assert: (row at: 'rk') equals: 1.	self assert: (row at: 'rt') equals: '1-ZZZ'.	self assert: (row at: 1) equals: 1.	self assert: (row at: 3) equals: '1-ZZZ'! !!SQLite3ConnectionTest methodsFor: 'tests'!testChanges	| count |	count := self populateRowsInto: 'stuff' of: db.	self assert: db changes equals: 1.	(db basicExecute: 'delete from stuff').	self assert: db changes equals: count! !!SQLite3ConnectionTest methodsFor: 'tests'!testDo	| arrayResults dictResults |	self executeInDB:		'create table if not exists x (id integer , tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	db basicExecute: 'insert into x values (10, "abc")'.	db basicExecute: 'insert into x values (20, "def")'.	db basicExecute: 'insert into x values (30, "ghi")'.	res := db commitTransaction.	self assert: res equals: 0.	arrayResults := OrderedCollection new.	dictResults := OrderedCollection new.	rs := db execute: 'select * from x;'.	rs do: [ :row |		arrayResults add: row asArray.		dictResults add: row asDictionary ].	rs close.	self deny: arrayResults isEmpty.	self assert: arrayResults size equals: 3.	self assert: arrayResults first equals: #( 10 'abc' ).	self assert: arrayResults second equals: #( 20 'def' ).	self assert: arrayResults third equals: #( 30 'ghi' ).	self deny: dictResults isEmpty.	self assert: dictResults size equals: 3.	self assert: dictResults first equals: { ('id' -> 10). ('tv' -> 'abc') } asDictionary.	self assert: dictResults second equals: { ('id' -> 20). ('tv' -> 'def') } asDictionary.	self assert: dictResults third equals: { ('id' -> 30). ('tv' -> 'ghi') } asDictionary! !!SQLite3ConnectionTest methodsFor: 'tests'!testExactlyOneRow	| row |	self populateRowsInto: 'junk' of: db.	row := (db execute: 'select * from junk where rt = ''1-ZZZ''') onlyRow.	self assert: (row at: 'rk') equals: 1.	self assert: (row at: 'rt') equals: '1-ZZZ'.	self assert: (row at: 1) equals: 1.	self assert: (row at: 3) equals: '1-ZZZ'! !!SQLite3ConnectionTest methodsFor: 'tests'!testExactlyOneRowGotNone	| row |	self populateRowsInto: 'junk' of: db.	row := (db execute: 'select * from junk where rt = ''0-ZZZ''') onlyRow.	self assert: row isNil! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteDelete	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	rs := db execute: 'delete from x;'.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteDrop	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	rs := db execute: 'drop table x;'.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteNoResult	rs := db execute: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self assert: (rs next isNil).	rs close.	rs := db execute: 'delete from x;'.	self assert: (rs next isNil).	rs close.	rs := db execute: 'drop table x;'.	self assert: (rs next isNil).	rs close! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteValueInsertArray	| rd |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' value: 1 value: 'two'.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rd := ( db execute: 'select * from x' ) rows first.	self assert: ( rd at: 'xk' ) equals: 1.	self assert: ( rd at: 'iv' ) equals: 1.	self assert: ( rd at: 'tv' ) equals: 'two'.	self assert: ( rd at: 1 ) equals: 1.	self assert: ( rd at: 2 ) equals: 1.	self assert: ( rd at: 3 ) equals: 'two'.	self assert: rd first equals: 1.	self assert: rd last equals: 'two'! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteValueInsertBooleanNilThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, bv boolean);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?)' value: nil.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'bv' ) equals: nil.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: nil.	self assert: row first equals: 1.	self assert: row last equals: nil.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteValueInsertBooleanThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, bv boolean);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?)' value: true.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'bv' ) equals: true.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: true.	self assert: row first equals: 1.	self assert: row last equals: true.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteValueInsertChanges	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' value: 1 value: 'two'.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	self assert: db changes equals: 1.	self assert: db totalChanges equals: 1.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' value: 2 value: 'too'.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	self assert: db changes equals: 1.	self assert: db totalChanges equals: 2! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteValueInsertThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' value: 1 value: 'two'.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'iv' ) equals: 1.	self assert: ( row at: 'tv' ) equals: 'two'.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: 1.	self assert: ( row at: 3 ) equals: 'two'.	self assert: row first equals: 1.	self assert: row last equals: 'two'.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteValueInsertThenSelect2	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' value: 1 value: 'two'.	self assert: rs next isNil.	rs close.	rs := db execute: 'insert into x values (NULL, ?, ?)' value: 2 value: 'three'.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'iv' ) equals: 1.	self assert: ( row at: 'tv' ) equals: 'two'.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: 1.	self assert: ( row at: 3 ) equals: 'two'.	self assert: row first equals: 1.	self assert: row last equals: 'two'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 2.	self assert: ( row at: 'iv' ) equals: 2.	self assert: ( row at: 'tv' ) equals: 'three'.	self assert: ( row at: 1 ) equals: 2.	self assert: ( row at: 2 ) equals: 2.	self assert: ( row at: 3 ) equals: 'three'.	self assert: row first equals: 2.	self assert: row last equals: 'three'.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteValueInsertThenSelectDateTime	| row data |	self executeInDB: 'create table if not exists x (xv datetime);'.	res := db beginTransaction.	self assert: res equals: 0.	data := DateAndTime year: 2015 month: 4 day: 1.	rs := db execute: 'insert into x values (?)' value: data.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select xv from x'.	row := rs next.	data := row at: 'xv'.	self assert: data class equals: DateAndTime.	self assert: data year equals: 2015.	self assert: data month equals: 4.	self assert: data dayOfMonth equals: 1.	data := row at: 1.	self assert: data class equals: DateAndTime.	self assert: data year equals: 2015.	self assert: data month equals: 4.	self assert: data dayOfMonth equals: 1.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteWithAllInsertManyValues	| results |	self executeInDB:		'create table if not exists x (iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	db		execute: 'insert into x values (?, ?)'		withAll: #( #( 1 'two' ) #( 2 'three' ) #( 3 'four' ) ).	res := db commitTransaction.	self assert: res equals: 0.	results := OrderedCollection new.	rs := db execute: 'select * from x'.	rs do: [ :each | results add: each asArray ].	rs close.	self deny: results isEmpty.	self assert: results size equals: 3.	self assert: results first equals: #( 1 'two' ).	self assert: results second equals: #( 2 'three' ).	self assert: results third equals: #( 3 'four' )! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteWithAllUpdateManyValues	| results |	self executeInDB:		'create table if not exists x (iv integer, tv text);'.	self executeInDB: 'delete from x;'.	self executeInDB: 'insert into x values (1, ''two'')'.	self executeInDB: 'insert into x values (2, ''three'')'.	self executeInDB: 'insert into x values (3, ''four'')'.	results := OrderedCollection new.	rs := db execute: 'select * from x'.	rs do: [ :each | results add: each asArray ].	rs close.	self deny: results isEmpty.	self assert: results size equals: 3.	self assert: results first equals: #( 1 'two' ).	self assert: results second equals: #( 2 'three' ).	self assert: results third equals: #( 3 'four' ).	res := db beginTransaction.	self assert: res equals: 0.	db		execute: 'update x set tv = ?2 where iv = ?1'		withAll: #( #( 1 'five' ) #( 2 'six' ) #( 3 'seven' ) ).	res := db commitTransaction.	self assert: res equals: 0.	results := OrderedCollection new.	rs := db execute: 'select * from x'.	rs do: [ :each | results add: each asArray ].	rs close.	self deny: results isEmpty.	self assert: results size equals: 3.	self assert: results first equals: #( 1 'five' ).	self assert: results second equals: #( 2 'six' ).	self assert: results third equals: #( 3 'seven' )! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteWithInsertArray	| rd |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' with: #( 1 'two' ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rd := ( db execute: 'select * from x' ) rows first.	self assert: ( rd at: 'xk' ) equals: 1.	self assert: ( rd at: 'iv' ) equals: 1.	self assert: ( rd at: 'tv' ) equals: 'two'.	self assert: ( rd at: 1 ) equals: 1.	self assert: ( rd at: 2 ) equals: 1.	self assert: ( rd at: 3 ) equals: 'two'.	self assert: rd first equals: 1.	self assert: rd last equals: 'two'! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteWithInsertBooleanNilThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, bv boolean);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?)' with: ( Array with: nil ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'bv' ) equals: nil.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: nil.	self assert: row first equals: 1.	self assert: row last equals: nil.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteWithInsertBooleanSQLNullThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, bv boolean);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, NULL)'.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'bv' ) equals: nil.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: nil.	self assert: row first equals: 1.	self assert: row last equals: nil.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteWithInsertBooleanThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, bv boolean);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?)' with: ( Array with: true ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'bv' ) equals: true.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: true.	self assert: row first equals: 1.	self assert: row last equals: true.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteWithInsertChanges	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' with: #( 1 'two' ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	self assert: db changes equals: 1.	self assert: db totalChanges equals: 1.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' with: #( 2 'too' ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	self assert: db changes equals: 1.	self assert: db totalChanges equals: 2! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteWithInsertDictionary	| rd |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db		      execute: 'insert into x values (NULL, :first, :two)'		      with: ( Dictionary newFromPairs: #( ':first' 1 ':two' '2' ':nosuch' 3 ) ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rd := ( db execute: 'select * from x' ) rows first.	self assert: ( rd at: 'xk' ) equals: 1.	self assert: ( rd at: 'iv' ) equals: 1.	self assert: ( rd at: 'tv' ) equals: '2'.	self assert: ( rd at: 1 ) equals: 1.	self assert: ( rd at: 2 ) equals: 1.	self assert: ( rd at: 3 ) equals: '2'.	self assert: rd first equals: 1.	self assert: rd last equals: '2'! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteWithInsertMultilingualStringsThenSelect	| data s row idx |	data := OrderedCollection with: 'English' with: '中文' with: 'にほんご' , 'áěšřčá'.	self executeInDB: 'create table if not exists x (xk integer primary key, tv text);'.	self executeInDB: 'delete from x;'.	self executeInDB: 'begin'.	s := db prepare: 'insert into x values (NULL, ?)'.	data do: [ :x |		s at: 1 putString: x.		s step.		s clearBindings.		s reset		].	s finalize.	self executeInDB: 'commit'.	idx := 1.	rs := db execute: 'select xk, tv from x order by xk asc'.	[ ( row := rs next ) isNotNil ] whileTrue: [		self assert: ( row at: 'xk' ) equals: idx.		self assert: ( row at: 'tv' ) equals: ( data at: idx ).		idx := idx + 1		].	rs close.	self assert: idx equals: 4! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteWithInsertNoDataThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL)' with: #(  ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 1 ) equals: 1.	self assert: row first equals: 1.	self assert: row last equals: 1.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteWithInsertThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' with: #( 1 'two' ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'iv' ) equals: 1.	self assert: ( row at: 'tv' ) equals: 'two'.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: 1.	self assert: ( row at: 3 ) equals: 'two'.	self assert: row first equals: 1.	self assert: row last equals: 'two'.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteWithInsertThenSelect2	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' with: #( 1 'two' ).	self assert: rs next isNil.	rs close.	rs := db execute: 'insert into x values (NULL, ?, ?)' with: #( 2 'three' ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'iv' ) equals: 1.	self assert: ( row at: 'tv' ) equals: 'two'.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: 1.	self assert: ( row at: 3 ) equals: 'two'.	self assert: row first equals: 1.	self assert: row last equals: 'two'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 2.	self assert: ( row at: 'iv' ) equals: 2.	self assert: ( row at: 'tv' ) equals: 'three'.	self assert: ( row at: 1 ) equals: 2.	self assert: ( row at: 2 ) equals: 2.	self assert: ( row at: 3 ) equals: 'three'.	self assert: row first equals: 2.	self assert: row last equals: 'three'.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteWithInsertThenSelect3	| s row idx |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	self executeInDB: 'begin'.	s := db prepare: 'insert into x values (NULL, ?, ?)'.	1 to: 10 do: [ :x |		s at: 1 putInteger: x * x.		s at: 2 putString: x asString , ' * ' , x asString.		s step.		s clearBindings.		s reset		].	s finalize.	self executeInDB: 'commit'.	idx := 1.	rs := db execute: 'select * from x where iv < ?' with: #( 27 ).	[ ( row := rs next ) isNotNil ] whileTrue: [		self assert: ( row at: 'xk' ) equals: idx.		self assert: ( row at: 'iv' ) equals: idx * idx.		self assert: ( row at: 'tv' ) equals: idx asString , ' * ' , idx asString.		self assert: ( row at: 1 ) equals: idx.		self assert: ( row at: 2 ) equals: idx * idx.		self assert: ( row at: 3 ) equals: idx asString , ' * ' , idx asString.		self assert: row first equals: idx.		self assert: row last equals: idx asString , ' * ' , idx asString.		idx := idx + 1		].	rs close.	self assert: idx equals: 6! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteWithInsertThenSelectChineseTableName	| data s row idx |	data := OrderedCollection with: 'English' with: '中文' with: 'にほんご' , 'áěšřčá'.	self executeInDB: 'create table if not exists 表一 (xk integer primary key, tv text);'.	self executeInDB: 'delete from 表一;'.	self executeInDB: 'begin'.	s := db prepare: 'insert into 表一 values (NULL, ?)'.	data do: [ :x |		s at: 1 putString: x.		s step.		s clearBindings.		s reset		].	s finalize.	self executeInDB: 'commit'.	idx := 1.	rs := db execute: 'select xk, tv from 表一 order by xk asc'.	[ ( row := rs next ) isNotNil ] whileTrue: [		self assert: ( row at: 'xk' ) equals: idx.		self assert: ( row at: 'tv' ) equals: ( data at: idx ).		idx := idx + 1		].	rs close.	self assert: idx equals: 4! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteWithInsertThenSelectDateTime	| row data |	self executeInDB: 'create table if not exists x (xv datetime);'.	res := db beginTransaction.	self assert: res equals: 0.	data := DateAndTime year: 2015 month: 4 day: 1.	rs := db execute: 'insert into x values (?)' with: ( Array with: data ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select xv from x'.	row := rs next.	data := row at: 'xv'.	self assert: data class equals: DateAndTime.	self assert: data year equals: 2015.	self assert: data month equals: 4.	self assert: data dayOfMonth equals: 1.	data := row at: 1.	self assert: data class equals: DateAndTime.	self assert: data year equals: 2015.	self assert: data month equals: 4.	self assert: data dayOfMonth equals: 1.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteWithInsertThenSelectJapaneseTableName	| data s row idx |	data := OrderedCollection with: 'English' with: '中文' with: 'にほんご' , 'áěšřčá'.	self executeInDB: 'create table if not exists テーブル一 (xk integer primary key, tv text);'.	self executeInDB: 'delete from テーブル一;'.	self executeInDB: 'begin'.	s := db prepare: 'insert into テーブル一 values (NULL, ?)'.	data do: [ :x |		s at: 1 putString: x.		s step.		s clearBindings.		s reset		].	s finalize.	self executeInDB: 'commit'.	idx := 1.	rs := db execute: 'select xk, tv from テーブル一 order by xk asc'.	[ ( row := rs next ) isNotNil ] whileTrue: [		self assert: ( row at: 'xk' ) equals: idx.		self assert: ( row at: 'tv' ) equals: ( data at: idx ).		idx := idx + 1		].	rs close.	self assert: idx equals: 4! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteWithToFail	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	self		should: [ db execute: 'insert into x values (NULL, ?, ?)' with: 42 ]		raise: SQLite3AbstractError.	res := db rollbackTransaction.	self assert: res equals: 0! !!SQLite3ConnectionTest methodsFor: 'tests'!testExecuteWithToFail2	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	self		should: [ db execute: 'insert into x values (NULL, ?, ?)' with: '42' ]		raise: SQLite3AbstractError.	res := db rollbackTransaction.	self assert: res equals: 0! !!SQLite3ConnectionTest methodsFor: 'tests - open / close'!testForcedClose	| fileRef conn |	fileRef := FileReference		           newTempFilePrefix: 'sqlite3_test_forced_close_'		           suffix: '.db'.	self assert: fileRef exists not.	conn := SQLite3Connection on: fileRef fullName.	conn open.	self assert: fileRef exists.	conn execute: 'create table if not exists BOOK (ID integer primary key, NAME VARCHAR2);'.	"now force closing"	conn forceClose.	Smalltalk garbageCollect.		"it must be possible to delete the DB now"	fileRef delete.	self assert: fileRef exists not! !!SQLite3ConnectionTest methodsFor: 'tests'!testGetAutocommit	self assert: db getAutoCommit equals: true.	db beginTransaction.	self assert: db getAutoCommit equals: false.	db rollbackTransaction.	self assert: db getAutoCommit equals: true! !!SQLite3ConnectionTest methodsFor: 'tests - glorp compatibility'!testGlorpAutoID	| schema rows |	schema := 'CREATE TABLE BOOK (ID INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, STUFF TEXT NOT NULL);'.	db basicExecute: schema.	db beginTransaction.	db execute: 'insert into BOOK (STUFF) values (?)'		with: #('The Bad Beginning').	db execute: 'insert into BOOK (STUFF) values (?)'		with: #('Better Now').	db commitTransaction.	rows := (db execute: 'select last_insert_rowid() as lid') rows.	self assert: (rows first at: 'lid') equals: 2.	rows := (db execute: 'select * from BOOK') rows.	self assert: rows size equals: 2.	self assert: (rows first at: 'ID') equals: 1.	self assert: (rows first at: 'STUFF') equals: 'The Bad Beginning'! !!SQLite3ConnectionTest methodsFor: 'tests - glorp compatibility'!testGlorpCompositeKey	| schema rows |	"This is the schema generated by Glorp."	schema := 'CREATE TABLE GR_USER (ID integer  NOT NULL ,NAME text  NULL , CONSTRAINT GR_USER_PK PRIMARY KEY  (ID), CONSTRAINT GR_USER_UNIQ UNIQUE  (ID));'.	db basicExecute: schema.	db beginTransaction.	db execute: 'insert into GR_USER values (?, ?)' with: #(1 'User One').	db execute: 'insert into GR_USER values (?, ?)' with: #(2 'User Two').	db commitTransaction.	rs := db execute: 'select ID,NAME from GR_USER'.	rows := rs rows.	self assert: rows size equals: 2.	self assert: (rows first at: 'ID') equals: 1.	self assert: (rows first at: 'NAME') equals: 'User One'! !!SQLite3ConnectionTest methodsFor: 'tests - glorp compatibility'!testGlorpDoubleInsertPrimaryKey	| schema rows |	schema := 'CREATE TABLE GR_USER (ID integer  NOT NULL ,NAME text  NULL , CONSTRAINT GR_USER_PK PRIMARY KEY  (ID), CONSTRAINT GR_USER_UNIQ UNIQUE  (ID));'.	db basicExecute: schema.	db beginTransaction.	db execute: 'insert into GR_USER values (?, ?)'		with: #(1 'Fred').	self should: [ db execute: 'insert into GR_USER values (?, ?)' with: #(1 'Barney') ]		raise: SQLite3AbstractError.	db commitTransaction.	rs := db execute: 'select * from GR_USER'.	rows := rs rows.	self assert: rows size equals: 1.	self assert: (rows first at: 'ID') equals: 1.	self assert: (rows first at: 'NAME') equals: 'Fred'! !!SQLite3ConnectionTest methodsFor: 'tests - glorp compatibility'!testGlorpUpdate	| schema rows |	schema := 'CREATE TABLE BOOK (ID INTEGER PRIMARY KEY AUTOINCREMENT  NOT NULL ,TITLE text  NULL ,DESCRIPTION text  NULL ,COPIES_IN_STOCK int  NULL ,VERSION int  NULL );'.	db basicExecute: schema.	db beginTransaction.	db execute: 'insert into BOOK (TITLE,COPIES_IN_STOCK,VERSION) values (?, ?, ?)'		with: #('The Bad Beginning' 3 6).	db execute: 'UPDATE BOOK SET TITLE = ?,COPIES_IN_STOCK = ?,VERSION = ? WHERE ID = ? AND BOOK.VERSION = ?'		with: #('The Bad Beginning' 6 7 1 6).	db commitTransaction.	rs := db execute: 'select * from BOOK'.	rows := rs rows.	self assert: rows size equals: 1.	self assert: (rows first at: 'ID') equals: 1.	self assert: (rows first at: 'TITLE') equals: 'The Bad Beginning'.	self assert: (rows first at: 'COPIES_IN_STOCK') equals: 6! !!SQLite3ConnectionTest methodsFor: 'tests - glorp compatibility'!testGlorpUpdateTwice	| schema rows |	schema := 'CREATE TABLE BOOK (ID INTEGER PRIMARY KEY AUTOINCREMENT  NOT NULL ,TITLE text  NULL ,DESCRIPTION text  NULL ,COPIES_IN_STOCK int  NULL ,VERSION int  NULL );'.	db basicExecute: schema.	db beginTransaction.	db execute: 'insert into BOOK (TITLE,COPIES_IN_STOCK,VERSION) values (?, ?, ?)'		with: #('The Bad Beginning' 3 6).	db execute: 'UPDATE BOOK SET COPIES_IN_STOCK = 7'.	db execute: 'UPDATE BOOK SET TITLE = ?,COPIES_IN_STOCK = ?,VERSION = ? WHERE ID = ? AND BOOK.VERSION = ?'		with: #('The Bad Beginning' 6 7 1 6).	db commitTransaction.	rs := db execute: 'select * from BOOK'.	rows := rs rows.	self assert: rows size equals: 1.	self assert: (rows first at: 'ID') equals: 1.	self assert: (rows first at: 'TITLE') equals: 'The Bad Beginning'.	self assert: (rows first at: 'COPIES_IN_STOCK') equals: 6! !!SQLite3ConnectionTest methodsFor: 'tests'!testInsertThenSelectInTransaction	"From GlorpDatabaseBasicTest>>testNameBinding."	self executeInDB: 'create table if not exists x (id integer , tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	db basicExecute: 'insert into x values (10, "abc")'.	db basicExecute: 'insert into x values (20, "def")'.	db basicExecute: 'insert into x values (30, "ghi")'.	rs := db execute: 'select * from x where id = ? or id = ?' with: { 10. 30 }.	self assert: rs rows size equals: 2.	res := db rollbackTransaction.	self assert: res equals: 0! !!SQLite3ConnectionTest methodsFor: 'tests'!testRows	"SQLite uses 1-based column indexing for database rows."	| rowCount rows any |	rowCount := self populateRowsInto: 'junk' of: db.	rs := db execute: 'select * from junk'.	rs rowClass: SQLite3Row.	rows := rs rows.	self assert: rows size equals: rowCount.	self assert: ( rows first at: 'rk' ) equals: 1.	self assert: ( rows first at: 'rt' ) equals: '1-ZZZ'.	self assert: ( rows first at: 1 ) equals: 1.	self assert: ( rows first at: 3 ) equals: '1-ZZZ'.	1 to: 5 do: [ :x |		any := Random new nextInt: rowCount.		self assert: ( ( rows at: any ) at: 'rk' ) equals: any.		self assert: ( ( rows at: any ) at: 'rt' ) equals: any asString , '-ZZZ'.		self assert: ( ( rows at: any ) at: 1 ) equals: any.		self assert: ( ( rows at: any ) at: 3 ) equals: any asString , '-ZZZ'		].	self assert: ( rows last at: 'rk' ) equals: rowCount.	self assert: ( rows last at: 'rt' ) equals: rowCount asString , '-ZZZ'.	self assert: ( rows last at: 1 ) equals: rowCount.	self assert: ( rows last at: 3 ) equals: rowCount asString , '-ZZZ'! !!SQLite3ConnectionTest methodsFor: 'tests'!testStatementReadOnly	| stmt |	self populateRowsInto: 'junk' of: db.	stmt := db prepare: 'select * from junk'.	self assert: stmt isReadOnly equals: true.	stmt := db prepare: 'delete from junk'.	self assert: stmt isReadOnly equals: false! !!SQLite3ConnectionTest methodsFor: 'tests'!testValueInsertThenSelectInTransaction	"From GlorpDatabaseBasicTest>>testNameBinding."	self executeInDB: 'create table if not exists x (id integer , tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	db basicExecute: 'insert into x values (10, "abc")'.	db basicExecute: 'insert into x values (20, "def")'.	db basicExecute: 'insert into x values (30, "ghi")'.	rs := db execute: 'select * from x where id = ? or id = ?' value: 10 value: 30.	self assert: rs rows size equals: 2.	res := db rollbackTransaction.	self assert: res equals: 0! !!SQLite3ConnectionTest methodsFor: 'tests'!untestStatementInProgress	"XXX Doesn't work yet."	| s1 s2 |	res := db basicExecute: 'create table if not exists x (xk integer primary key, iv integer);'.	self assert: res equals: 0.	db beginTransaction.	s1 := db prepare: 'insert into x values (NULL, ?)'.	s1 at: 1 putInteger: 1.	"s1 step."	db execute: 'delete from x;'.	"self should: [ db rollbackTransaction ] raise: SQLite3Error."	db commitTransaction.	s1 reset.	s1 finalize! !!SQLite3DatabaseTest methodsFor: 'tests'!testPrintString	self assert: SQLite3Database memory printString equals: 'a SQLite3Database(":memory:")'! !!SQLite3RowTest methodsFor: 'running'!setUp	super setUp.	emptyRow := SQLite3Row new.	filledRow := SQLite3Row new columnNames: {'foo'. 'bar'. 'pi'}; yourself.	filledRow		at: 'foo' put: 1;		at: 'bar' put: true;		at: 'pi' put: '3.14'! !!SQLite3RowTest methodsFor: 'tests'!testAsArray	self assert: emptyRow asArray equals: #().	self assert: filledRow asArray equals: #(1 true '3.14')! !!SQLite3RowTest methodsFor: 'tests'!testAsCombinedDictionary	| dict  |	dict := Dictionary new.	dict at: 'foo' put: 1.	dict at: 'bar' put: true.	dict at: 'pi' put: '3.14'.	dict at: 1 put: 1.	dict at: 2 put: true.	dict at: 3 put: '3.14'.	self assert: emptyRow asCombinedDictionary equals: Dictionary new.	self assert: filledRow asCombinedDictionary equals: dict! !!SQLite3RowTest methodsFor: 'tests'!testAsDictionary	| dict  |	dict := Dictionary new.	dict at: 'foo' put: 1.	dict at: 'bar' put: true.	dict at: 'pi' put: '3.14'.	self assert: emptyRow asDictionary equals: Dictionary new.	self assert: filledRow asDictionary equals: dict! !!SQLite3RowTest methodsFor: 'tests'!testColumnAccessingIfAbsent	|blockExecutedFlag|	blockExecutedFlag := false.	filledRow at: 'foo' ifAbsent: [ blockExecutedFlag := true ].	self deny: blockExecutedFlag.	filledRow at: 'nope' ifAbsent: [ blockExecutedFlag := true ].	self assert: blockExecutedFlag! !!SQLite3RowTest methodsFor: 'tests'!testColumnAccessingOnEmptyRow	self assert: (emptyRow at: 'foo') equals: nil! !!SQLite3RowTest methodsFor: 'tests'!testColumnAccessingOnFilledRow	self assert: (filledRow at: 'foo') equals: 1.	self assert: (filledRow at: 'bar') equals: true.	self assert: (filledRow at: 'pi') equals: '3.14'.	self assert: (filledRow at: 'nope') equals: nil! !!SQLite3RowTest methodsFor: 'tests'!testColumnNamesOnEmptyRow	self assert: emptyRow columnNames equals: #()! !!SQLite3RowTest methodsFor: 'tests'!testColumnNamesOnFilledRow	self assert: filledRow columnNames equals: #('foo' 'bar' 'pi')! !!SQLite3RowTest methodsFor: 'tests'!testColumnPuttingOnEmptyRow	self assert: (emptyRow at: 'foo') equals: nil.	emptyRow at: 'foo' put: 42.	self assert: (emptyRow at: 'foo') equals: 42! !!SQLite3RowTest methodsFor: 'tests'!testColumnPuttingOnFilledRow	self assert: (filledRow at: 'foo') equals: 1.	filledRow at: 'foo' put: 2.	self assert: (filledRow at: 'foo') equals: 2! !!SQLite3TableBasedTest class methodsFor: 'testing'!isAbstract	^ self == SQLite3TableBasedTest! !!SQLite3TableBasedTest methodsFor: 'running'!setUp	super setUp.	db := SQLite3Database memory.	db connection open.	db connection execute: self tableCreationScript.	table := db tables first! !!SQLite3TableBasedTest methodsFor: 'accessing'!tableCreationScript	^ self subclassResponsibility! !!SQLite3TableBasedTest methodsFor: 'running'!tearDown	db connection close.	db := nil.	super tearDown! !!SQLite3TableBasedTest methodsFor: 'tests - sample'!testSampleTableSchema	self assert: table schema equals: self tableCreationScript! !!SQLite3TableTest methodsFor: 'accessing'!tableCreationScript	^'CREATE TABLE "SAMPLE"(    [ID] INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,    [NAME] NVARCHAR(120))'! !!SQLite3TableTest methodsFor: 'tests'!testName	| properties instance |	properties := Dictionary newFromPairs: #( #name 'SimpleTable' ).	instance := SQLite3Table properties: properties in: nil.	self assert: instance name equals: 'SimpleTable'! !!SQLite3TableTest methodsFor: 'tests - sample'!testNumberOfRows	self assert: table numberOfRows equals: 0! !!SQLite3TableTest methodsFor: 'tests - sample'!testNumberOfRowsIsOne	db execute: 'INSERT INTO SAMPLE(NAME) VALUES (''first example'');'.	self assert: table numberOfRows equals: 1! !!SQLite3TableTest methodsFor: 'tests - sample'!testNumberOfRowsIsTwo	db execute: 'INSERT INTO SAMPLE(NAME) VALUES (''first example''), (''second example'');'.	self assert: table numberOfRows equals: 2! !!SQLite3TableTest methodsFor: 'tests'!testPrintString	self assert: table printString equals: 'a SQLite3Table("SAMPLE")'! !!SQLite3TableTest methodsFor: 'tests - sample'!testRows	self assert: table rows isEmpty! !!SQLite3TableTest methodsFor: 'tests - sample'!testRowsHasOneRow	| rows |	db execute: 'INSERT INTO SAMPLE(NAME) VALUES (''first example'');'.	rows := table rows.	self deny: rows isEmpty.	self assert: rows size equals: 1.	self assert: (rows first at: 'NAME') equals: 'first example'! !!SQLite3TableTest methodsFor: 'tests - sample'!testRowsHasTwoRows	| rows |	db execute:		'INSERT INTO SAMPLE(NAME) VALUES (''first example''), (''second example'');'.	rows := table rows.	self deny: rows isEmpty.	self assert: rows size equals: 2.	self assert: (rows first at: 'NAME') equals: 'first example'.	self assert: (rows second at: 'NAME') equals: 'second example'! !!SQLite3TableTest methodsFor: 'tests - sample'!testSampleTable	self assert: table name equals: 'SAMPLE'! !!SQLite3TableTest methodsFor: 'tests - sample'!testSampleTableColumnNames	self assert: table columnNames size equals: 2! !!SQLite3TableTest methodsFor: 'tests - sample'!testSampleTableColumns	self assert: table columns size equals: 2! !!SQLite3TableTest methodsFor: 'tests - sample'!testSampleTableProperties	|props|	props := table properties.	self assert: props size equals: 5.	self assert: (props at: #type) equals: 'table'.	self assert: (props at: #tbl_name) equals: 'SAMPLE'.	self assert: (props at: #rootpage) equals: 2.	self assert: (props at: #name) equals: 'SAMPLE'.	self assert: (props at: #sql) equals: self tableCreationScript! !!SQLite3TableTest methodsFor: 'tests'!testUnitializedName	self assert: SQLite3Table new name equals: ''! !!SQLite3TableWithSpacesTest methodsFor: 'accessing'!tableCreationScript	^'CREATE TABLE "ANOTHER TABLE"(    [ID] INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,    [SOME NAME] NVARCHAR(120))'! !!SQLite3TableWithSpacesTest methodsFor: 'tests'!testColumnNameHasSpace	self assert: table columnNames size equals: 2.	self assert: table columnNames second equals: 'SOME NAME'! !!SQLite3TableWithSpacesTest methodsFor: 'tests'!testPrintStringHasTableNameWithSpace	self assert: table printString equals: 'a SQLite3Table("ANOTHER TABLE")'! !!ManifestSQLite3CoreTests class methodsFor: 'code coverage'!classNamesNotUnderTest	^ #( ManifestSQLite3CoreTests )! !!ManifestSQLite3CoreTests class methodsFor: 'code-critics'!ruleEmptyExceptionHandlerRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#SQLite3ConnectionTest #tearDown #false)) #'2022-05-10T08:25:11.111+02:00') #(#(#RGMethodDefinition #(#SQLite3BaseConnectionTest #tearDown #false)) #'2022-05-10T08:27:13.419+02:00') )! !!ManifestSQLite3CoreTests class methodsFor: 'code-critics'!ruleLiteralArrayContainsCommaRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#SQLite3BaseConnectionTest #deactivatedTestTracing #false)) #'2022-05-10T08:24:31.021+02:00') )! !!ManifestSQLite3CoreTests class methodsFor: 'code-critics'!ruleLiteralArrayContainsSuspiciousTrueFalseOrNilRuleV1FalsePositive	^ #(#(#(#RGMetaclassDefinition #(#'ManifestSQLite3CoreTests class' #ManifestSQLite3CoreTests)) #'2022-05-10T08:26:37.973+02:00') )! !"SQLite3-Core-Tests"!!SQLite3Row methodsFor: '*SQLite3-Inspector-Extensions'!inspectionSQLite3Row	<inspectorPresentationOrder: 10 title: 'SQlite3 - Contents'>	| presenter |	presenter := SpTablePresenter new.	presenter items: (Array with: self).	self columnNames do: [:each |		presenter addColumn: (SpStringTableColumn title: each evaluated: [ :assoc | self at: each ])	].	^presenter! !!SQLite3Database methodsFor: '*SQLite3-Inspector-Extensions'!inspectionSQLite3Tables	<inspectorPresentationOrder: 10 title: 'Sqlite3 - Tables'>	^ SpTablePresenter new		items: self tables;		addColumn: (SpStringTableColumn title: 'Name' evaluated: [ :assoc | assoc name ]);		addColumn: (SpStringTableColumn title: 'Number of rows' evaluated: [ :assoc | assoc numberOfRows ]);		yourself! !!AbstractFileReference methodsFor: '*SQLite3-Inspector-Extensions'!databaseSize	|s|	s := self size.	s / 1024 > 1024 ifTrue: [ ^ ((s / 1024 / 1024) roundDownTo: 0.01) asString, ' MB' ].	^ ((s / 1024) roundDownTo: 0.01) asString, ' KB'! !!AbstractFileReference methodsFor: '*SQLite3-Inspector-Extensions'!inspectionSQLite3Info	<inspectorPresentationOrder: -2 title: 'SQLite3 - Info'>	| label1 label2 |	label1 := SpLabeledPresenter		          label: 'Database file:'		          input: (SpTextInputFieldPresenter new text: self fullName).	label2 := SpLabeledPresenter		          label: 'Database size:'		          input: (SpTextInputFieldPresenter new text: self databaseSize).	^ SpPresenter new		  layout: (SpBoxLayout newTopToBottom				   add: label1;					add: label2;				   yourself);		  yourself! !!AbstractFileReference methodsFor: '*SQLite3-Inspector-Extensions'!inspectionSQLite3InfoContext: aContext	^ aContext active: self isSQlite3Database! !!AbstractFileReference methodsFor: '*SQLite3-Inspector-Extensions'!inspectionSQLite3Tables	<inspectorPresentationOrder: -1 title: 'SQLite3 - Tables'>	^ SpTablePresenter new			items: (SQLite3Database tableInfoFor: self fullName);			addColumn: (SpStringTableColumn title: 'Table Name' evaluated: [ :assoc | assoc name ]);			addColumn: (SpStringTableColumn title: 'Number of Rows' evaluated: [ :assoc | assoc numberOfRows ]);			yourself! !!AbstractFileReference methodsFor: '*SQLite3-Inspector-Extensions'!inspectionSQLite3TablesContext: aContext	^ aContext active: self isSQlite3Database! !!AbstractFileReference methodsFor: '*SQLite3-Inspector-Extensions'!isSQlite3Database	"Return true if the reference is an SQLite3 database file"	^ self isFile and: [		  self extension = 'db' and: [			  (self readStreamDo: [ :s | s next: 16 ])			  = ('SQLite format 3' , Character null asString) ] ]! !!SQLite3Table methodsFor: '*SQLite3-Inspector-Extensions'!inspectionSQLite3Columns	<inspectorPresentationOrder: 13 title: 'SQLite3 - Columns'>	^ SpTablePresenter new		items: self columns;		addColumn: (SpStringTableColumn title: 'Column Name' evaluated: [ :each | each name ]);		addColumn: (SpStringTableColumn title: 'Column Type' evaluated: [ :each | each type ]);		addColumn: (SpStringTableColumn title: 'Non-empty values' evaluated: [ :each | each hasNotNullConstraint ifTrue: ['NOT NULL'] ifFalse: [''] ]);		yourself! !!SQLite3Table methodsFor: '*SQLite3-Inspector-Extensions'!inspectionSQLite3Data	<inspectorPresentationOrder: 11 title: 'SQLite3 - Data'>	| presenter |	presenter := SpTablePresenter new.	presenter items: self rows.	self columnNames do: [:col |		presenter addColumn: (SpStringTableColumn title: col evaluated: [ :each | each at: col ])	 ].	^presenter! !!SQLite3Table methodsFor: '*SQLite3-Inspector-Extensions'!inspectionSQLite3Schema	<inspectorPresentationOrder: 10 title: 'SQLite3 - Schema'>	^ SpTextPresenter new		text: self schema;		yourself! !!SQLite3Table methodsFor: '*SQLite3-Inspector-Extensions'!inspectionSQLite3TableProperties	<inspectorPresentationOrder: 40 title: 'SQLite3 - Table Properties'>	^ SpTablePresenter new		items: self properties associations;		addColumn: (SpStringTableColumn title: 'Property' evaluated: [ :assoc | assoc key ]);		addColumn: (SpStringTableColumn title: 'Value' evaluated: [ :assoc | assoc value ]);		yourself! !!BaselineOfTeapot methodsFor: 'baselines'!baseline: spec	<baseline>	spec for: #common do: [		self setUpDependencies: spec.		spec			package: 'Teapot-Core' with: [ spec requires: #( 'NeoJSON' ) ];			package: 'Teapot-Tools' with: [ spec requires: 'Teapot-Core' ].		spec			for: #( #'pharo7.x' #'pharo8.x' #'pharo9.x' )			do: [ spec package: 'Teapot-Tests' with: [ spec requires: 'Teapot-Core' ] ].		spec			for: #( #'pharo10.x' #'pharo11.x' #'pharo12.x' )			do: [ spec package: 'Teapot-Tests' with: [ spec requires: #( 'Teapot-Core' 'Zinc-Zodiac' ) ] ].		spec			group: 'Tests' with: #( 'Teapot-Tests' );			group: 'Tools' with: #( 'Teapot-Tools' );			group: 'Deployment' with: #( 'Teapot-Core' );			group: 'Development' with: #( 'Tests' 'Tools' );			group: 'default' with: 'Development'		]! !!BaselineOfTeapot methodsFor: 'baselines'!setUpDependencies: spec	spec		baseline: 'NeoJSON' with: [			spec				repository: 'github://svenvc/NeoJSON';				loads: #( 'core' )			];		baseline: 'ZincHTTPComponents' with: [ spec repository: 'github://svenvc/zinc' ];		project: 'Zinc-Zodiac' copyFrom: 'ZincHTTPComponents' with: [ spec loads: 'Zinc-Zodiac-Core' ]! !"BaselineOfTeapot"!!BaselineOfNeoJSON commentStamp: '' prior: 0!I am BaselineOfNeoJSON, I load the code for the NeoJSON project.I am a BaselineOf.!!BaselineOfNeoJSON methodsFor: 'baselines'!baseline: spec	<baseline>	spec		for: #common		do: [ spec				package: 'Neo-JSON-Core';				package: 'Neo-JSON-Tests' with: [ spec requires: #('Neo-JSON-Core') ];				group: 'default' with: #('core' 'tests');				group: 'core' with: #('Neo-JSON-Core');				group: 'tests' with: #('Neo-JSON-Tests') ].	spec		for: #pharo		do: [ spec				package: 'Neo-JSON-Pharo-Core' with: [ spec requires: #('Neo-JSON-Core') ];				package: 'Neo-JSON-Pharo-Tests' with: [ spec requires: #('Neo-JSON-Tests') ];				package: 'Neo-JSON-Pharo-Examples' with: [ spec requires: #('Neo-JSON-Core') ];				group: 'core' with: #('Neo-JSON-Core' 'Neo-JSON-Pharo-Core');				group: 'tests' with: #('Neo-JSON-Tests' 'Neo-JSON-Pharo-Tests');				group: 'examples' with: #('Neo-JSON-Pharo-Examples') ].! !"BaselineOfNeoJSON"!!BaselineOfZincHTTPComponents commentStamp: 'SvenVanCaekenberghe 7/5/2020 16:32' prior: 0!I am BaselineOfZincHTTPComponents.I am a BaselineOf.I am used to load the Zinc HTTP Components project from GitHub as in   Metacello new    repository: 'github://svenvc/zinc/repository';    baseline: 'ZincHTTPComponents';    load.The following groups are available to load: - default (Core & Tests) - Core (Zinc-HTTP Zinc-HTTP-Examples Zinc-Zodiac-Core) - Tests (Zinc-Tests Zinc-Character-Encoding-Tests Zinc-Resource-Meta-Tests Zodiac-Tests Zinc-Zodiac-Tests) - Character-Encoding - Resource-Meta - Zodiac - AWS - WebDAV - WebSocket - SSO-OAuth1 - SSO-OAuth2 - SSO-OpenID - SSO-Demo - SSO (SSO-OAuth1 SSO-OAuth2 SSO-OpenID SSO-Demo Zinc-SSO-Demo) - WWS (Zinc-WWS-Server Zinc-WWS-Client) - REST - Server-Sent-EventsSee also https://github.com/svenvc/zincPart of Zinc HTTP Components.!!BaselineOfZincHTTPComponents methodsFor: 'baselines' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!baseline: spec	<baseline>	spec for: #common do: [		spec baseline: 'NeoJSON' with: [ spec repository: 'github://svenvc/NeoJSON:master/repository' ].		spec baseline: 'XMLParser' with: [ spec repository: 'github://pharo-contributions/XML-XMLParser:master/src' ].		spec package: 'Zodiac-Core' with: [ spec repository: 'github://svenvc/zodiac:master/repository' ].		spec package: 'Zodiac-Tests' with: [ spec repository: 'github://svenvc/zodiac:master/repository' ].		spec			package: 'Zinc-Character-Encoding-Core';			package: 'Zinc-Character-Encoding-Tests' with: [ spec requires: 'Zinc-Character-Encoding-Core' ];			package: 'Zinc-Resource-Meta-Core' with: [ spec requires: 'Zinc-Character-Encoding-Core' ];			package: 'Zinc-Resource-Meta-Tests' with: [ spec requires: 'Zinc-Resource-Meta-Core' ];			package: 'Zinc-HTTP' with: [ 				spec postLoadDoIt: #recompileZnLogEventHierarchy; requires: #('Zinc-Character-Encoding-Core' 'Zinc-Resource-Meta-Core') ];			package: 'Zinc-HTTP-Examples' with: [ spec requires: #('Zinc-HTTP') ];			package: 'Zinc-Tests' with: [ spec requires: 'Zinc-HTTP' ];			package: 'Zinc-Zodiac-Core' with: [ spec requires: #('Zinc-HTTP' 'Zodiac-Core') ];			package: 'Zinc-Zodiac-Tests' with: [ spec requires:  #('Zinc-Zodiac-Core') ].		spec			package: 'Zinc-AWS' with: [ spec requires: #('Zinc-HTTP' 'XMLParser') ];			package: 'Zinc-REST' with: [ spec requires: #('Zinc-HTTP' 'NeoJSON') ];			package: 'Zinc-WebSocket-Core' with: [ spec requires: 'Zinc-HTTP' ];			package: 'Zinc-WebSocket-Tests' with: [ spec requires: 'Zinc-WebSocket-Core' ];			package: 'Zinc-SSO-OAuth1-Core' with: [ spec requires: #('Zinc-HTTP' 'NeoJSON') ];			package: 'Zinc-SSO-OAuth2-Core' with: [ spec requires: #('Zinc-HTTP' 'NeoJSON') ];			package: 'Zinc-SSO-OpenID-Core' with: [ spec requires: #('Zinc-HTTP' 'XMLParser') ];			package: 'Zinc-SSO-Demo' with: [ spec requires: #('Zinc-SSO-OAuth1-Core' 'Zinc-SSO-OAuth2-Core' 'Zinc-SSO-OpenID-Core') ];			package: 'Zinc-SSO-OAuth1-Tests' with: [ spec requires: #('Zinc-SSO-OAuth1-Core') ];			package: 'Zinc-SSO-OpenID-Tests' with: [ spec requires: #('Zinc-SSO-OpenID-Core') ];			package: 'Zinc-WebDAV' with: [ spec requires: 'Zinc-HTTP' ];			package: 'Zinc-WWS-Server' with: [ spec requires: 'Zinc-HTTP' ];			package: 'Zinc-WWS-Client' with: [ spec requires: 'Zinc-HTTP' ];			package: 'Zinc-Server-Sent-Events' with: [ spec requires: 'Zinc-HTTP' ].		spec			group: 'default' with: #('Core' 'Tests');			group: 'Core' with: #('Zinc-HTTP' 'Zinc-HTTP-Examples' 'Zinc-Zodiac-Core');			group: 'Tests' with: #('Zinc-Tests' 'Zinc-Character-Encoding-Tests' 'Zinc-Resource-Meta-Tests' 'Zodiac-Tests' 'Zinc-Zodiac-Tests');			group: 'Character-Encoding' with: #('Zinc-Character-Encoding-Core' 'Zinc-Character-Encoding-Tests');			group: 'Resource-Meta' with: #('Zinc-Resource-Meta-Core' 'Zinc-Resource-Meta-Tests');			group: 'Zodiac' with: #('Zodiac-Core' 'Zodiac-Tests');			group: 'AWS' with: #('Zinc-AWS');			group: 'WebDAV' with: #('Zinc-WebDAV');			group: 'WebSocket' with: #('Zinc-WebSocket-Core' 'Zinc-WebSocket-Tests');			group: 'SSO-OAuth1' with: #('Zinc-SSO-OAuth1-Core' 'Zinc-SSO-OAuth1-Tests');			group: 'SSO-OAuth2' with: #('Zinc-SSO-OAuth2-Core');			group: 'SSO-OpenID' with: #('Zinc-SSO-OpenID-Core' 'Zinc-SSO-OpenID-Tests');			group: 'SSO-Demo' with: #('Zinc-SSO-OAuth1-Core' 'Zinc-SSO-OAuth2-Core' 'Zinc-SSO-OpenID-Core');			group: 'SSO' with: #('SSO-OAuth1' 'SSO-OAuth2' 'SSO-OpenID' 'SSO-Demo' 'Zinc-SSO-Demo');			group: 'WWS' with: #('Zinc-WWS-Server' 'Zinc-WWS-Client');			group: 'REST' with: #('Zinc-REST');			group: 'Server-Sent-Events' with: #('Zinc-Server-Sent-Events') ]! !!BaselineOfZincHTTPComponents methodsFor: 'doits' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!recompileZnLogEventHierarchy	"This is a hack, but somehow there is something wrong in the instance variables layout, 	which can only be fixed by recompiling, which should happen but doesn't, so force it."	ZnLogEvent withAllSubclassesDo: #recompile! !"BaselineOfZincHTTPComponents"!!NeoJSONFloatPrinter commentStamp: '' prior: 0!I am NeoJSONFloatPrinter.I print Float numbers in a compact, human friendly format.The following (default) parameters are used: - base 10 - hardcoded (for now) - precision 5 digits - decimal point - hardcoded (for now) - exponent e - hardcoded (for now) - NaN, Inf and -Inf - hardcoded (for now) - lower 1e-4 - upper 1e6 - decimal notation for abs values inside abs [ lower, upper ] - scientific notation for abs values outside [ lower, upper ] - no padding, no trailing zeros in fraction part - only negative sign, never a positive sign - no thousands separators - no engineering notationSee my class side for configuration examples.My public interface is in the printing protocol.!!NeoJSONMapper commentStamp: '' prior: 0!I am NeoJSONMapper.I hold a mapping from schema identifiers to objects that known how to read or write instances from or to JSON.Schema identifiers are either Smalltalk classes or Symbols.I offer a builder interface to construct mappings. The standard object mapping represents a Smalltalk object as a map, mapping some or all instance variables, or a set of accessors (getter/setter methods). Furthermore, for each value an optional schema can be specified.Using a custom mapping, a reader and/or writer block can deal with special cases such as specific collection types with an optional schema for the elements, or a direct mapping of semi primitive types such as Date or DateAndTime.A mapping can be specified explicitely on a mapper, or can be resolved using the #neoJsonMapping: class method.Here are some examples:	mapper mapAllInstVarsFor: Point.	mapper for: TestObject do: [ :mapping |		mapping mapInstVars: #(id name).		(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.		(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.		(mapping mapInstVar: #bytes) valueSchema: ByteArray ].	mapper for: DateAndTime customDo: [ :mapping |		mapping decoder: [ :string | DateAndTime fromString: string ].		mapping encoder: [ :dateAndTime | dateAndTime printString ] ].	mapper for: #ArrayOfPoints customDo: [ :mapping |		mapping listOfElementSchema: Point ].  	mapper for: ByteArray customDo: [ :mapping |		mapping listOfType: ByteArray ]!!NeoJSONReader commentStamp: '' prior: 0!I am NeoJSONReader.I am a NeoJSONMapper.I parse a JSON representation from a textual stream into Smalltalk objects.Primitive types are automatically mapped to their Smalltalk counterpart: Numbers, Strings, Booleans and UndefinedObject.When parsing using #next, lists normally become Arrays and maps become Dictionaries.An alternative listClass or mapClass can be specified.When parsing using #nextAs: a schema can be specified. This schema defines a mapping to be used.Here are some examples:	NeoJSONReader fromString: ' [ 1,2,3 ] '.	NeoJSONReader fromString: ' [ 3.14159, true, false, null, "string" ] '.	NeoJSONReader fromString: ' { "x" : 1, "y" : 2 } '.		(NeoJSONReader on: ' { "x" : 1, "y" : 2 } ' readStream)		mapInstVarsFor: Point;		nextAs: Point.					(NeoJSONReader on: '[ { "x" : 1, "y" : 2 }, { "x" : 3, "y" : 4 } ]' readStream)		mapInstVarsFor: Point;		for: #ArrayOfPoints customDo: [ :mapping |			mapping listOfElementSchema: Point ];		nextAs: #ArrayOfPoints.	(NeoJSONReader on: '[ { "x" : 1, "y" : 2 }, { "x" : 3, "y" : 4 } ]' readStream)		mapInstVarsFor: Point;		nextListAs: Point.!!NeoJSONWriter commentStamp: '' prior: 0!I am NeoJSONWriter.I am a NeoJSONMapper.I write a JSON representation of Smalltalk objects to a textual stream.Objects implementing #neoJsonOn: can be encoded.A number of primitive types, like Strings, Numbers, Booleans and UndefinedObject are treated specially.Collection are encoded as lists, except for Dictionaries that are encoded as maps.All other objects need a mapping to help in doing the encoding.Here are some examples:	NeoJSONWriter toString: #(1 2 3).	NeoJSONWriter toString: { Float pi. true. false. 'string' }.	NeoJSONWriter toStringPretty: (Dictionary new at: #x put: 1; at: #y put: 2; yourself).		String streamContents: [ :stream |		(NeoJSONWriter on: stream)			prettyPrint: true;			mapInstVarsFor: Point;			nextPut: (Array with: 1@3 with: -1@3) ].	!!NeoJSONMapping commentStamp: '' prior: 0!I am NeoJSONMapping, an abstract superclass for mapping definitions.!!NeoJSONCustomMapping commentStamp: '' prior: 0!I am NeoJSONCustomMapping.I read the next JSON value and turn it into a Smalltalk object using a converter block.!!NeoJSONObjectMapping commentStamp: '' prior: 0!I am NeoJSONObjectMapping.I describe how instances of a Smalltalk class are mapped to a JSON map.I do this using set of NeoJSONPropertyMappings.I know the Smalltalk class that I am a mapping for. This class is the schema identifier and is used to instanciate new objects.A mapping can be based on any combination of instance variables or accessors (getter/setter pairs). I offer a builder interface to constuct property mappings.!!NeoJSONPropertyMapping commentStamp: '' prior: 0!I am NeoJSONPropertyMapping.I describe how a property of a Smalltalk class maps to a JSON property.A property is either an instance variable or getter/setter pair.I hold a getter and setter block to do the actual work. The property name is used in JSON.Optionally, the schema for the value of my property can be specified. This is then used recursively.!!NeoJSONStreamingWriter commentStamp: '' prior: 0!I am NeoJSONStreamingWriter.I help in writing streamed maps and lists.This is an internal class used by NeoJSONWriter to deal with interleaving elements and separators as well as pretty printing.!!NeoJSONMappingNotFound commentStamp: '' prior: 0!I am NeoJSONMappingNotFound. I am signalled when no mapping is found for a schema.Portability comment: In Pharo,  I could technically subclass from NotFound directly, avoid all my defined methods and only keep #messageText and #standardMessageText. However, NotFound exception does not exist in other dialects. To keep NeoJSON as portable as possible we duplicate some Pharo code into myself. !!NeoJSONParseError commentStamp: '' prior: 0!I am NeoJSONParseError.I am an Error.I am signalled when JSON input is not valid while parsing.!!NeoJSONArray commentStamp: '' prior: 0!I am NeoJSONArray.I am an Array.I am often used in combination with NeoJSONObject, to represent the result of parsing JSON.  I support path access for nested instances of me, using #atPath: and #atPath:put: Used in its generic way, NeoJSONParser will return Arrays and Dictionaries.Returning NeoJSONArrays and NeoJSONObjects, simple subclasses, allows to add some convenience methods.!!NeoJSONObject commentStamp: '' prior: 0!I am NeoJSONObject.I am an OrderedDictionary.I behave more like a JavaScript object. I return nil for missing keys. I allow any property to be read or set by using a normal accessor message.The following are equivalent:	self foo.	self at: #foo.As are the following	self foo: 1. 	self at: #foo put: 1.	Except that in the first case, self is returned.I can optionally be used by NeoJSONReader as mapClass (see #mapClass:).For output, I act just like my superclass (it is thus not necessary to do any conversions).Example:	NeoJSONObject fromString: '{"foo":1,"bar":-2}'.	NeoJSONObject new foo: 1; bar: -2.	{ #x -> 100. #y -> 200 } as: NeoJSONObject.	(NeoJSONObject new data: (NeoJSONObject new id: #sensor1; value: 37.5)) asString.I use JSON as my printed representation. To convert me to JSON, use #printString or #asString.Additionally, I support path access for nested instances of me, using #atPath: and #atPath:put:The first is special because it returns nil as soon as a key is missing. The second is special because it creates extra levels (instances of me) as needed to follow the path of keys.	NeoJSONObject new atPath: #(one two three) put: 42; yourself.	NeoJSONObject new atPath: #(one two three) put: 42; atPath: #(one two three).The fact that I am an OrderedDictionary means to I maintain the order of keys. This is meant as a convenience feature only as the official JSON specification clearly states "An object is an unordered set of name/value pairs".I work together with NeoJSONArray.!!NeoJSONFloatPrinter class methodsFor: 'instance creation'!lowPrecision	^ self new		precision: 2;		lower: 1e-2;		upper: 1e5;		yourself! !!NeoJSONFloatPrinter class methodsFor: 'instance creation'!scientificOnly	^ self new		lower: 0;		upper: 0;		yourself! !!NeoJSONFloatPrinter methodsFor: 'constants'!decimalPoint	^ $.! !!NeoJSONFloatPrinter methodsFor: 'constants'!exponent	^ $e! !!NeoJSONFloatPrinter methodsFor: 'constants'!infinite	^ 'Inf'! !!NeoJSONFloatPrinter methodsFor: 'initialize-release'!initialize	super initialize.	base := 10.	precision := 5.	lower := 1e-4.	upper := 1e6! !!NeoJSONFloatPrinter methodsFor: 'initialize-release'!lower: number	lower := number! !!NeoJSONFloatPrinter methodsFor: 'constants'!nan	^ 'NaN'! !!NeoJSONFloatPrinter methodsFor: 'initialize-release'!precision: numberOfDigits	self assert: (numberOfDigits between: 1 and: 20).	precision := numberOfDigits! !!NeoJSONFloatPrinter methodsFor: 'printing'!print: float	^ String new: 16 streamContents: [ :out | 			self print: float on: out ]! !!NeoJSONFloatPrinter methodsFor: 'private'!print: float decimalOn: stream	stream print: float asInteger.	stream nextPut: self decimalPoint.	self 		print: (float fractionPart * (base raisedTo: precision)) rounded 		fractionOn: stream! !!NeoJSONFloatPrinter methodsFor: 'private'!print: fractionPart fractionOn: stream	| zeros |	zeros := 0. "leading zeros are significant, trailing zeros are not printed"	precision to: 1 by: -1 do: [ :position | | digit |		digit := fractionPart digitAt: position base: base.		digit = 0			ifTrue: [ zeros := zeros +1 ]			ifFalse: [				zeros > 0 ifTrue: [ 					zeros timesRepeat: [ stream nextPut: $0 ]. 					zeros := 0 ].				stream nextPut: digit asCharacterDigit ] ]! !!NeoJSONFloatPrinter methodsFor: 'printing'!print: float on: stream	| int abs |	(float isZero or: [ float isFinite not ])		ifTrue: [ ^ self print: float specialOn: stream ].	self print: float signOn: stream.	((abs := float abs) between: lower and: upper)		ifTrue: [ 			(int := abs asInteger) = abs 				ifTrue: [ int printOn: stream ]				ifFalse: [ self print: abs decimalOn: stream ] ]		ifFalse: [ self print: abs scientificOn: stream ]! !!NeoJSONFloatPrinter methodsFor: 'private'!print: float scientificOn: stream	| exponent mantissa |	exponent := (float ln / base ln) floor.	mantissa := float / (base raisedTo: exponent).	self print: mantissa decimalOn: stream.	stream		nextPut: self exponent;		print: exponent! !!NeoJSONFloatPrinter methodsFor: 'private'!print: float signOn: stream	float sign = -1		ifTrue: [ stream nextPut: $- ]! !!NeoJSONFloatPrinter methodsFor: 'private'!print: float specialOn: stream	float isZero		ifTrue: [ 			stream nextPut: $0 ]		ifFalse: [			float isNaN 				ifTrue: [ 					stream nextPutAll: self nan ]				ifFalse: [					self print: float signOn: stream.					stream nextPutAll: self infinite ] ]! !!NeoJSONFloatPrinter methodsFor: 'printing'!printFloat: float on: stream	self print: float on: stream! !!NeoJSONFloatPrinter methodsFor: 'initialize-release'!upper: number	upper := number! !!NeoJSONMapper methodsFor: 'private'!customMappingFor: schemaName	^ self mappings		at: schemaName		ifAbsentPut: [ 			NeoJSONCustomMapping new				schemaName: schemaName;				yourself ]! !!NeoJSONMapper methodsFor: 'mapping'!for: schemaName customDo: block	"Execute the code in block to further customize the mapping for schemaName.	Create and add a new custom mapping for schemaName if necessary."		| mapping |	mapping := self customMappingFor: schemaName.	block value: mapping.	^ mapping! !!NeoJSONMapper methodsFor: 'mapping'!for: smalltalkClass do: block	"Execute the code in block to further customize the mapping for schemaName.	Create and add a new standard object mapping for schemaName if necessary."		| mapping |	mapping := self objectMappingFor: smalltalkClass.	block value: mapping.	^ mapping! !!NeoJSONMapper methodsFor: 'convencience'!mapAllInstVarsFor: smalltalkClass	"Map the instance variables of smalltalkClass and all its super classes"	| mapping |	mapping := self objectMappingFor: smalltalkClass.	mapping mapAllInstVars.	^ mapping! !!NeoJSONMapper methodsFor: 'convencience'!mapInstVarsFor: smalltalkClass	"Map the instance variables of smalltalkClass"	| mapping |	mapping := self objectMappingFor: smalltalkClass.	mapping mapInstVars.	^ mapping! !!NeoJSONMapper methodsFor: 'accessing'!mappingFor: schema	^ self 		mappingFor: schema 		ifAbsent: [ NeoJSONMappingNotFound signalFor: schema in: self ]! !!NeoJSONMapper methodsFor: 'accessing'!mappingFor: schema ifAbsent: block	(self mappings includesKey: schema)		ifFalse: [ self resolveMappingFor: schema ].	^ self mappings		at: schema		ifAbsent: block! !!NeoJSONMapper methodsFor: 'private'!mappings	^ mappings		ifNil: [ mappings := Dictionary new ]! !!NeoJSONMapper methodsFor: 'private'!objectMappingFor: smalltalkClass	^ self mappings		at: smalltalkClass		ifAbsentPut: [ 			NeoJSONObjectMapping new				subjectClass: smalltalkClass;				yourself ]! !!NeoJSONMapper methodsFor: 'private'!resolveMappingFor: class	(class respondsTo: #neoJsonMapping:)		ifTrue: [ 			class perform: #neoJsonMapping: with: self ]! !!NeoJSONReader class methodsFor: 'example'!exampleCoordinatesCustomParsing	<gtExample>	| reader |	reader := self on: self exampleCoordinatesJSON readStream.	reader mapAllInstVarsFor: Point.	reader for: #ArrayOfPoints customDo: [ :mapping |		mapping listOfElementSchema: Point ].	^ reader nextAs: #ArrayOfPoints ! !!NeoJSONReader class methodsFor: 'example'!exampleCoordinatesGenericParsing	<gtExample>	^ self fromString: self exampleCoordinatesJSON! !!NeoJSONReader class methodsFor: 'example'!exampleCoordinatesJSON	<gtExample>	^ '[{"x":0,"y":0},{"x":1,"y":2},{"x":2,"y":4},{"x":3,"y":6},{"x":4,"y":8}]'! !!NeoJSONReader class methodsFor: 'convenience'!fromString: string	^ (self on: string readStream) next! !!NeoJSONReader class methodsFor: 'convenience'!fromString: string as: schema	^ (self on: string readStream) nextAs: schema! !!NeoJSONReader class methodsFor: 'instance creation'!on: readStream	"Initialize on readStream, which should be a character stream that 	implements #next, #peek, #atEnd and (optionally) #close."	^ self new		on: readStream;		yourself! !!NeoJSONReader methodsFor: 'testing'!atEnd	^ readStream atEnd! !!NeoJSONReader methodsFor: 'initialize-release'!close	readStream ifNotNil: [		readStream close.		readStream := nil ]! !!NeoJSONReader methodsFor: 'private'!consumeWhitespace	"Strip whitespaces from the input stream."	[ readStream atEnd not and: [ readStream peek isSeparator ] ]		whileTrue: [ 			readStream next ]! !!NeoJSONReader methodsFor: 'private'!error: text	NeoJSONParseError signal: text! !!NeoJSONReader methodsFor: 'private'!expectChar: character	"Expect character and consume input and optional whitespace at the end,	 throw an error otherwise."	(self matchChar: character)		ifFalse: [ self error: character asString, ' expected' ]! !!NeoJSONReader methodsFor: 'parsing'!failIfNotAtEnd	self atEnd		ifFalse: [ self error: 'extraneous input detected' ]! !!NeoJSONReader methodsFor: 'initialize-release'!initialize 	super initialize.	propertyNamesAsSymbols := false! !!NeoJSONReader methodsFor: 'accessing'!listClass	"Return the collection type to use for JSON lists"		^ listClass ifNil: [ Array ]! !!NeoJSONReader methodsFor: 'initialize-release'!listClass: collectionClass	listClass := collectionClass! !!NeoJSONReader methodsFor: 'accessing'!mapClass	"Return the collection type to use for JSON maps"		^ mapClass ifNil: [ Dictionary ]! !!NeoJSONReader methodsFor: 'initialize-release'!mapClass: collectionClass	mapClass := collectionClass! !!NeoJSONReader methodsFor: 'private'!match: string do: block	"Try to read and consume string and execute block if successful.	Else do nothing (but do not back up)"	(string allSatisfy: [ :each | readStream peekFor: each ])		ifTrue: [ 			self consumeWhitespace.			block value ]! !!NeoJSONReader methodsFor: 'private'!matchChar: character	"Tries to match character, consume input and 	answer true if successful and consumes whitespace at the end.	When character does not match, return false and leave stream untouched."	^ (readStream peekFor: character)		ifTrue: [ 			self consumeWhitespace.			true ]		ifFalse: [ false ]! !!NeoJSONReader methodsFor: 'accessing'!next	"Primary interface to parse a JSON value.	Return either primitives, a listClass or a mapClass instance."		^ self 		consumeWhitespace; 		parseValue! !!NeoJSONReader methodsFor: 'accessing'!nextAs: schema	"Secondary interface to parse JSON.	Return an object according to schema.	If schema is nil, act like #next"		| mapping |	schema ifNil: [ ^ self next ].	self consumeWhitespace.	mapping := self mappingFor: schema.	^ mapping readFrom: self! !!NeoJSONReader methodsFor: 'accessing'!nextListAs: schema	"Secondary interface to parse JSON.	Return a list of objects, each element according to schema."		^ self listClass streamContents: [ :stream |			self parseListDo: [ 				stream nextPut: (self nextAs: schema) ] ]! !!NeoJSONReader methodsFor: 'initialize-release'!on: aReadStream	"Initialize on aReadStream, which should be a character stream that 	implements #next, #peek, #atEnd and (optionally) #close."		readStream := aReadStream! !!NeoJSONReader methodsFor: 'parsing'!parseCharacter	| char |	(char := readStream next) = $\ 		ifFalse: [ ^ char ].	('/"\' includes: (char := readStream next))		ifTrue: [ ^ char ].	('bfnrt' includes: char)		ifTrue: [ ^ self unescapeChar: char ].	char = $u		ifTrue: [ ^ self parseCharacterHex ].	char 		ifNil: [ self error: 'invalid escape, end of file' ]		ifNotNil: [ self error: 'invalid escape character \' , char asString ]! !!NeoJSONReader methodsFor: 'private'!parseCharacterHex	| value codePoint |	value := self parseCharacterHex4Value.	(value < 16rD800 or: [ value > 16rDBFF ])		ifTrue: [ codePoint := value ]		ifFalse: [ | leadSurrogate trailSurrogate |			"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"			"See https://tools.ietf.org/html/rfc7159#section-7"			leadSurrogate := value.			trailSurrogate := self parseTrailingSurrogateHexEscape.			codePoint := (leadSurrogate - 16rD800) * 16r400 + (trailSurrogate - 16rDC00).			codePoint := 16r10000 + codePoint.			codePoint > 16r10FFFF 				ifTrue: [ self error: 'Character Unicode code point outside encoder range' ] ].	^ Character codePoint: codePoint! !!NeoJSONReader methodsFor: 'private'!parseCharacterHex4Value	| value |	value := self parseCharacterHexDigit.	3 timesRepeat: [ 		value := (value << 4) + self parseCharacterHexDigit ].	^ value! !!NeoJSONReader methodsFor: 'private'!parseCharacterHexDigit	| digit |	readStream atEnd 		ifFalse: [ 			digit := readStream next asInteger.			(digit between: "$0" 48 and: "$9" 57)				ifTrue: [ ^ digit - 48 ].			(digit between: "$A" 65 and: "$F" 70)				ifTrue: [ ^ digit - 55 ].			(digit between: "$a" 97 and: "$f" 102)				ifTrue: [ ^ digit - 87 ] ].	self error: 'hex-digit expected'! !!NeoJSONReader methodsFor: 'private'!parseConstantDo: block	"Parse and consume either true|false|nil|null and execute block 	or else do nothing (but do not back up).	Hand written implementation to avoid the use of #position:"		(readStream peek = $t)		ifTrue: [			^ self match: 'true' do: [ block value: true ] ].	(readStream peek = $f)		ifTrue: [			^ self match: 'false' do: [ block value: false ] ].	(readStream peek = $n)		ifTrue: [			^ self match: 'null' do: [ block value: nil ] ]! !!NeoJSONReader methodsFor: 'parsing'!parseList	^ self listClass 		streamContents: [ :stream |			self parseListElementsDo: [ :each |				stream nextPut: each ] ]		! !!NeoJSONReader methodsFor: 'parsing'!parseListDo: block	self expectChar: $[.	(self matchChar: $]) 		ifTrue: [ ^ self ].	[ readStream atEnd ] 		whileFalse: [			block value.			(self matchChar: $]) 				ifTrue: [ ^ self ].			(self matchChar: $,)				ifFalse: [ self error: ', or ] expected' ] ].	self error: 'incomplete list'! !!NeoJSONReader methodsFor: 'parsing'!parseListElementsDo: block	self parseListDo: [ 		block value: self parseValue ]! !!NeoJSONReader methodsFor: 'parsing'!parseMap	| map |	map := self mapClass new.	self parseMapKeysAndValuesDo: [ :key :value |		map at: key put: value ].	^ map! !!NeoJSONReader methodsFor: 'parsing'!parseMapDo: block	self expectChar: ${.	(self matchChar: $})		ifTrue: [ ^ self ].	[ readStream atEnd ] whileFalse: [		block value.		(self matchChar: $}) 			ifTrue: [ ^ self ].		(self matchChar: $,)			ifFalse: [ self error: ', or } expected' ] ].	self error: 'incomplete map'! !!NeoJSONReader methodsFor: 'parsing'!parseMapKeysAndValuesDo: block	self parseMapKeysDo: [ :key |		block value: key value: self parseValue ]! !!NeoJSONReader methodsFor: 'parsing'!parseMapKeysDo: block	self parseMapDo: [ | key |		key := self parsePropertyName.		self expectChar: $:.		block value: key ]! !!NeoJSONReader methodsFor: 'parsing'!parseNumber	| negated number isFloat |	negated := readStream peekFor: $-.	number := self parseNumberInteger.	isFloat := (readStream peekFor: $.)		ifTrue: [ number := number + self parseNumberFraction. true ]		ifFalse: [ false ].	((readStream peekFor: $e) or: [ readStream peekFor: $E ])		ifTrue: [ number := number * self parseNumberExponent ].	isFloat ifTrue: [ number := number asFloat ].	negated		ifTrue: [ number := number negated ].	self consumeWhitespace.	^ number! !!NeoJSONReader methodsFor: 'parsing'!parseNumberExponent	| number negated |	number := 0.	(negated := readStream peekFor: $-)		ifFalse: [ readStream peekFor: $+ ].	(readStream atEnd or: [ readStream peek isDigit not ])		ifTrue: [ self error: 'number exponent expected' ].	[ readStream atEnd not and: [ readStream peek isDigit ] ]		whileTrue: [ number := 10 * number + readStream next digitValue ].	negated		ifTrue: [ number := number negated ].	number positive 		ifTrue: [ number > Float emax ifTrue: [ self error: 'number exponent too large' ] ]		ifFalse: [ number < Float emin ifTrue: [ self error: 'number exponent too small' ] ].	^ 10 raisedTo: number! !!NeoJSONReader methodsFor: 'parsing'!parseNumberFraction	| number power |	number := 0.	power := 1.	[ readStream atEnd not and: [ readStream peek isDigit ] ] 		whileTrue: [			number := 10 * number + readStream next digitValue.			power := power * 10 ].	^ number / power! !!NeoJSONReader methodsFor: 'parsing'!parseNumberInteger	| number |	number := nil.	[ readStream atEnd not and: [ readStream peek isDigit ] ] 		whileTrue: [ 			number := 10 * (number ifNil: [ 0 ]) + readStream next digitValue ].	number ifNil: [ self error: 'Integer digit expected' ].	^ number! !!NeoJSONReader methodsFor: 'parsing'!parsePropertyName	| name |	name := self parseValue.	^ name isString		ifTrue: [ 			propertyNamesAsSymbols 				ifTrue: [ name asSymbol ]				ifFalse: [ name ] ]		ifFalse: [ 			self error: 'property name must be a string, not ', name asString ]! !!NeoJSONReader methodsFor: 'parsing'!parseString	| result |	(readStream peekFor: $")		ifFalse: [ self error: '" expected' ].	result := self stringStreamContents: [ :stream | 		[ readStream atEnd or: [ readStream peek = $" ] ] 			whileFalse: [ stream nextPut: self parseCharacter ] ].	self expectChar: $".	^ result! !!NeoJSONReader methodsFor: 'private'!parseTrailingSurrogateHexEscape	(readStream next = $\ and: [ readStream next = $u ])		ifTrue: [ ^ self parseCharacterHex4Value ]		ifFalse: [ self error: 'trailing surrogate hex escape expected' ]! !!NeoJSONReader methodsFor: 'parsing'!parseValue	| char |	readStream atEnd ifFalse: [ 		char := readStream peek.		char = ${			ifTrue: [ ^ self parseMap ].		char = $[			ifTrue: [ ^ self parseList ].		char = $"			ifTrue: [ ^ self parseString ].		(char = $- or: [ char isDigit ])			ifTrue: [ ^ self parseNumber ].		self parseConstantDo: [ :value | ^ value ] ].	self error: 'invalid input: ', char asString! !!NeoJSONReader methodsFor: 'initialize-release'!propertyNamesAsSymbols: boolean	propertyNamesAsSymbols := boolean! !!NeoJSONReader methodsFor: 'private'!stringStreamClass	"Answer the class of the collection used for the stringStream of receiver.		NOTE: It is String, but if receiver's readStream is over 	another class of String, then this provides compatibility for that."	^ readStream collectionSpecies! !!NeoJSONReader methodsFor: 'private'!stringStreamContents: block	"Like String streamContents: block	but reusing the underlying buffer for improved efficiency"	stringStream ifNil: [ 		stringStream := (self stringStreamClass new: 32) writeStream ].	stringStream reset.	block value: stringStream.	^ stringStream contents! !!NeoJSONReader methodsFor: 'private'!unescapeChar: char	"Handle one of the named character escapes, b, f, n, r or t. Else fail."		char = $b		ifTrue: [ ^ Character backspace ].	char = $f		ifTrue: [ ^ Character newPage ].	char = $n		ifTrue: [ ^ Character lf ].	char = $r		ifTrue: [ ^ Character cr ].	char = $t		ifTrue: [ ^ Character tab ].	self error: 'Unknown escape char: ', (String with: char)! !!NeoJSONReader methodsFor: 'accessing'!upToEnd	"Parse and collect JSON values from my stream until it ends, returning the collection.	This supports Newline delimited JSON (application/x-ndjson) & JSON Lines (application/jsonl).	Warning: though each element is valid JSON, taken as a whole the result is non-valid JSON."		^ Array streamContents: [ :out |		[ self atEnd ] whileFalse: [ out nextPut: self next ] ]! !!NeoJSONWriter class methodsFor: 'example'!exampleCoordinates	<gtExample>	^ { 0@0 . 1@2. 2@4. 3@6 . 4@8}! !!NeoJSONWriter class methodsFor: 'example'!exampleCoordinatesCustomWriting	<gtExample>	^ String streamContents: [ :out |		| writer |		writer := self on: out.		writer mapAllInstVarsFor: Point.		writer nextPut: self exampleCoordinates ]! !!NeoJSONWriter class methodsFor: 'example'!exampleCoordinatesGeneric	<gtExample>	^ (0 to: 4) collect: [ :each | { 'x' -> each . 'y' -> (each * 2) } asDictionary ] ! !!NeoJSONWriter class methodsFor: 'example'!exampleCoordinatesGenericWriting	<gtExample>	^ self toString: self exampleCoordinatesGeneric! !!NeoJSONWriter class methodsFor: 'instance creation'!on: writeStream	"Initialize on writeStream, which should be a character stream that 	implements #nextPut:, #nextPutAll:, #space and (optionally) #close."	^ self new		on: writeStream;		yourself! !!NeoJSONWriter class methodsFor: 'convenience'!toString: object	^ String streamContents: [ :stream |			(self on: stream) nextPut: object ]! !!NeoJSONWriter class methodsFor: 'convenience'!toStringPretty: object	^ String streamContents: [ :stream |			(self on: stream)				prettyPrint: true; 				nextPut: object ]! !!NeoJSONWriter methodsFor: 'initialize-release'!asciiOnly: boolean	"Set whether I should escape all non ASCII characters or not"		asciiOnly := boolean! !!NeoJSONWriter methodsFor: 'initialize-release'!close	"Close the stream that I write to"		writeStream ifNotNil: [		writeStream close.		writeStream := nil ]! !!NeoJSONWriter methodsFor: 'private'!doesCodePointNeedEscaping: code	code < 32 ifTrue: [ ^ true ].	( code = 34 or: [ code = 92 ]) ifTrue: [ ^ true ].	^ asciiOnly and: [ code > 126 ]	! !!NeoJSONWriter methodsFor: 'private'!encodeChar: char	| code |	code := char codePoint.	(self doesCodePointNeedEscaping: code)		ifTrue: [ self escapeChar: code ]		ifFalse: [ writeStream nextPut: char ]! !!NeoJSONWriter methodsFor: 'private'!encodeKey: key	key isString ifFalse: [ ^ self error: 'JSON key names in objects must be strings' ].	self nextPut: key.	self prettyPrintSpace.	writeStream nextPut: $:.	self prettyPrintSpace! !!NeoJSONWriter methodsFor: 'private'!encodeKey: key value: value	self encodeKey: key.	self nextPut: value! !!NeoJSONWriter methodsFor: 'private'!encodeKey: key value: value as: valueSchema	self encodeKey: key.	self nextPut: value as: valueSchema! !!NeoJSONWriter methodsFor: 'private'!escapeChar: code	code = 34		ifTrue: [ ^ writeStream nextPutAll: '\"' ].	code = 92		ifTrue: [ ^ writeStream nextPutAll: '\\' ].	code = 47		ifTrue: [ ^ writeStream nextPutAll: '\/' ].	code = 8		ifTrue: [ ^ writeStream nextPutAll: '\b' ].	code = 12		ifTrue: [ ^ writeStream nextPutAll: '\f' ].			code = 10		ifTrue: [ ^ writeStream nextPutAll: '\n' ].			code = 13		ifTrue: [ ^ writeStream nextPutAll: '\r' ].			code = 9		ifTrue: [ ^ writeStream nextPutAll: '\t' ].			self escapeUnicode: code! !!NeoJSONWriter methodsFor: 'private'!escapeUnicode4: codePoint	writeStream nextPutAll: '\u'.	codePoint printOn: writeStream base: 16 nDigits: 4! !!NeoJSONWriter methodsFor: 'private'!escapeUnicode: codePoint	codePoint <= 16rFFFF		ifTrue: [ self escapeUnicode4: codePoint ]		ifFalse: [ 			codePoint <= 16r10FFFF				ifTrue: [ | leadSurrogate trailSurrogate shifted |					"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"					"See https://tools.ietf.org/html/rfc7159#section-7"					shifted := codePoint - 16r10000.					leadSurrogate := 16rD800 + (shifted // 16r400).					trailSurrogate := 16rDC00 + (shifted \\ 16r400).					self escapeUnicode4: leadSurrogate.					self escapeUnicode4: trailSurrogate ]				ifFalse: [ self error: 'Character Unicode code point outside encoder range' ] ]! !!NeoJSONWriter methodsFor: 'initialize-release'!floatPrinter: anObject	"Set the float print, an object that implements #printFloat:on:	By default, I am my own float printer"		floatPrinter := anObject! !!NeoJSONWriter methodsFor: 'private'!indentedDo: block	level := level + 1.	block value.	level := level - 1! !!NeoJSONWriter methodsFor: 'initialize-release'!initialize	super initialize.	self newLine: OSPlatform current lineEnding.	self prettyPrint: false.	self asciiOnly: false.	self writeNil: false.	self floatPrinter: self.	level := 0! !!NeoJSONWriter methodsFor: 'private'!listElementSeparator	writeStream nextPut: $,.	self newlineIndent! !!NeoJSONWriter methodsFor: 'private'!mapElementSeparator	writeStream nextPut: $,.	self newlineIndent! !!NeoJSONWriter methodsFor: 'initialize-release'!newLine: string	"Set the newline string that I should use when pretty printing"		newLine := string! !!NeoJSONWriter methodsFor: 'accessing'!newline	"Write a newline on the stream that I wrap.	What gets written depends on the configuration, see #newLine:"		writeStream nextPutAll: newLine! !!NeoJSONWriter methodsFor: 'private'!newlineIndent	prettyPrint		ifTrue: [ 			self newline.			level timesRepeat: [ writeStream nextPut: Character tab ] ]! !!NeoJSONWriter methodsFor: 'accessing'!nextPut: anObject	"Primary interface. Write a JSON representation of anObject to my stream."		anObject neoJsonOn: self! !!NeoJSONWriter methodsFor: 'accessing'!nextPut: anObject as: schema	"Secondary interface to write JSON.	Write objects according to schema."		| mapping |	(schema isNil or: [ anObject isNil ]) ifTrue: [ ^ self nextPut: anObject ].	mapping := self mappingFor: schema.	^ mapping writeObject: anObject on: self! !!NeoJSONWriter methodsFor: 'accessing'!nextPutAll: aCollection	"Write a separate JSON representation of all objects in aCollection to my stream.	This supports Newline delimited JSON (application/x-ndjson) & JSON Lines (application/jsonl).	Warning: though each element is valid JSON, taken as a whole the result is non-valid JSON."		aCollection do: [ :each |		self nextPut: each.		self newline ]! !!NeoJSONWriter methodsFor: 'initialize-release'!on: aWriteStream	"Initialize on aWriteStream, which should be a character stream that 	implements #nextPut:, #nextPutAll:, #space and (optionally) #close."	writeStream := aWriteStream! !!NeoJSONWriter methodsFor: 'initialize-release'!prettyPrint: boolean	"Set whether I should pretty print the JSON that I write"	prettyPrint := boolean! !!NeoJSONWriter methodsFor: 'private'!prettyPrintSpace	prettyPrint		ifTrue: [ writeStream nextPut: Character space ]! !!NeoJSONWriter methodsFor: 'printing'!printFloat: float on: stream	"See NeoJSONFloatPrinter for a custom float printer"		float printOn: stream! !!NeoJSONWriter methodsFor: 'writing'!writeBoolean: boolean	boolean printOn: writeStream! !!NeoJSONWriter methodsFor: 'writing'!writeFloat: float	floatPrinter printFloat: float on: writeStream! !!NeoJSONWriter methodsFor: 'writing'!writeInteger: integer	integer printOn: writeStream	! !!NeoJSONWriter methodsFor: 'writing'!writeList: collection	self writeListStreamingDo: [ :jsonListWriter |		collection do: [ :each |			jsonListWriter writeElement: each ] ]! !!NeoJSONWriter methodsFor: 'writing'!writeListStreamingDo: block	writeStream nextPut: $[.	self writeStreamingDo: block.	writeStream nextPut: $]! !!NeoJSONWriter methodsFor: 'writing'!writeMap: keyValueCollection	self writeMapStreamingDo: [ :jsonMapWriter |		keyValueCollection keysAndValuesDo: [ :key :value |			jsonMapWriter writeKey: key value: value ] ]! !!NeoJSONWriter methodsFor: 'writing'!writeMapStreamingDo: block	writeStream nextPut: ${.	self writeStreamingDo: block.	writeStream nextPut: $}! !!NeoJSONWriter methodsFor: 'accessing'!writeNil	"Return whether I will write nil/null properties of objects or skip them."		^ writeNil! !!NeoJSONWriter methodsFor: 'initialize-release'!writeNil: boolean	"Set whether I will write nil/null properties of objects or skip them."		writeNil := boolean! !!NeoJSONWriter methodsFor: 'writing'!writeNull	writeStream nextPutAll: 'null'! !!NeoJSONWriter methodsFor: 'writing'!writeObject: anObject	| mapping |	mapping := self mappingFor: anObject class.	mapping		writeObject: anObject		on: self! !!NeoJSONWriter methodsFor: 'writing'!writeStreamingDo: block	| mapWriter |	mapWriter := NeoJSONStreamingWriter on: self.	self indentedDo: [		block value: mapWriter ].	mapWriter wasUsed		ifTrue: [ self newlineIndent ]		ifFalse: [ self prettyPrintSpace ]! !!NeoJSONWriter methodsFor: 'writing'!writeString: string	writeStream nextPut: $".	1 to: string size do: [ :index |		self encodeChar: (string at: index) ].	writeStream nextPut: $"! !!NeoJSONCustomMapping methodsFor: 'mapping'!decoder: block	"Set a decoder block that accepts the next object representation read 	and converts it into the actual object to be returned."	self reader: [ :jsonReader | | representation |		representation := jsonReader next.		block value: representation ]! !!NeoJSONCustomMapping methodsFor: 'mapping'!encoder: block	"Set a encoder block that accepts the next object to be written 	and converts it into the actual representation to be written."	self writer: [ :jsonWriter :anObject | | representation |		representation := block value: anObject.		jsonWriter nextPut: representation ]! !!NeoJSONCustomMapping methodsFor: 'accessing'!identifier	^ schemaName ! !!NeoJSONCustomMapping methodsFor: 'mapping'!listOfElementSchema: elementSchema	"Set the reader to a block that will create an instance of the	standard listClass while reading a list of elements of type elementSchema.	Pass down the elementSchema to the elements in the writer."	self reader: [ :jsonReader |		jsonReader listClass streamContents: [ :stream |			jsonReader parseListDo: [ | element |				element := jsonReader nextAs: elementSchema.				stream nextPut: element ] ] ].	self writer: [ :jsonWriter :list | 		jsonWriter writeListStreamingDo: [ :listWriter |			list do: [ :each |				listWriter writeElement: each as: elementSchema ] ] ]! !!NeoJSONCustomMapping methodsFor: 'mapping'!listOfType: collectionClass	"Set the reader to a block that will create an instance of collectionClass 	using #streamContents: while reading a list of elements.	Set the writer to write the list's elements."	self reader: [ :jsonReader |		collectionClass streamContents: [ :stream |			jsonReader parseListDo: [ | element |				element := jsonReader next.				stream nextPut: element ] ] ].	self writer: [ :jsonWriter :list | 		jsonWriter writeListStreamingDo: [ :listWriter |			list do: [ :each |				listWriter writeElement: each ] ] ]! !!NeoJSONCustomMapping methodsFor: 'mapping'!listOfType: collectionClass andElementSchema: elementSchema	"Set the reader to a block that will create an instance of collectionClass 	using #streamContents: while reading a list of elements of type elementSchema.	Pass down the elementSchema to the elements in the writer."	self reader: [ :jsonReader |		collectionClass streamContents: [ :stream |			jsonReader parseListDo: [ | element |				element := jsonReader nextAs: elementSchema.				stream nextPut: element ] ] ].	self writer: [ :jsonWriter :list | 		jsonWriter writeListStreamingDo: [ :listWriter |			list do: [ :each | 				listWriter writeElement: each as: elementSchema ] ] ]! !!NeoJSONCustomMapping methodsFor: 'mapping'!mapWithValueSchema: valueSchema	"Set the reader to a block that will create an instance of the	standard mapClass while reading values of type valueSchema,	with standard keys"	self reader: [ :jsonReader | | map |		map := jsonReader mapClass new.		jsonReader parseMapKeysDo: [ :key | | value |				value := jsonReader nextAs: valueSchema.				map at: key put: value ].		map ].	self writer: [ :jsonWriter :map | 		jsonWriter writeMapStreamingDo: [ :mapWriter |			map keysAndValuesDo: [ :key :value | 				mapWriter writeKey: key value: value as: valueSchema ] ] ]! !!NeoJSONCustomMapping methodsFor: 'parsing'!readFrom: jsonReader	^ reader 		ifNil: [ jsonReader next ]		ifNotNil: [ reader value: jsonReader ]! !!NeoJSONCustomMapping methodsFor: 'accessing'!reader: block	"Set the reader to block, a 1 argument block that when given 	a jsonReader as argument reads the object that I represent.	When there is no reader block, the default #next will be used."		reader := block! !!NeoJSONCustomMapping methodsFor: 'accessing'!schemaName: schema	schemaName := schema! !!NeoJSONCustomMapping methodsFor: 'writing'!writeObject: anObject on: jsonWriter	writer 		ifNil: [ anObject neoJsonOn: jsonWriter ]		ifNotNil: [ writer value: jsonWriter value: anObject ]! !!NeoJSONCustomMapping methodsFor: 'accessing'!writer: block	"Set the writer to block, a 2 argument block that when given: a jsonWriter 	and the object to write will write the object that I represent.	When there is no writer block, the default #neoJsonOn: will be used."		writer := block! !!NeoJSONMapping methodsFor: 'accessing'!identifier	self subclassResponsibility ! !!NeoJSONMapping methodsFor: 'printing'!printOn: stream	super printOn: stream.	stream nextPut: $(; print: self identifier; nextPut: $)! !!NeoJSONMapping methodsFor: 'parsing'!readFrom: jsonReader	self subclassResponsibility ! !!NeoJSONMapping methodsFor: 'writing'!writeObject: anObject on: jsonWriter	self subclassResponsibility ! !!NeoJSONObjectMapping methodsFor: 'initialize-release'!allowNil	"Set that I will allow nil/null values when I read/expect an object"		allowNil := true! !!NeoJSONObjectMapping methodsFor: 'accessing'!identifier	^ subjectClass ! !!NeoJSONObjectMapping methodsFor: 'initialize-release'!initialize	super initialize.	properties := OrderedCollection new.	allowNil := false! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapAccessor: accessor	^ self mapAccessor: accessor to: accessor ! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapAccessor: accessor mutator: mutator to: propertyName	^ self 		mapProperty: propertyName		getter: [ :object | object perform: accessor ]		setter: [ :object :value | object perform: mutator with: value ] ! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapAccessor: accessor to: propertyName	^ self 		mapProperty: propertyName		getter: [ :object | object perform: accessor ]		setter: [ :object :value | object perform: accessor asMutator with: value ] ! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapAccessors: accessors	^ accessors collect: [ :each | self mapAccessor: each ]! !!NeoJSONObjectMapping methodsFor: 'convenience'!mapAllInstVars	^ self mapInstVars: subjectClass allInstVarNames! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapInstVar: instVarName	^ self mapInstVar: instVarName to: instVarName ! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapInstVar: instVarName to: propertyName	| index |	index := 		"For portability reasons, do not use instVarIndexFor:ifAbsent: 		(it doesn't exist in all Smalltalk dialects) but the below approach.		Also, convert to symbols for portability reasons"		(subjectClass allInstVarNames collect: [ :each | each asSymbol ]) 			indexOf: instVarName asSymbol 			ifAbsent: [ self error: 'Inst var not found: ', instVarName printString ].	^ self 		mapProperty: propertyName asString		getter: [ :object | object instVarAt: index ]		setter: [ :object :value | object instVarAt: index put: value ] 	! !!NeoJSONObjectMapping methodsFor: 'convenience'!mapInstVars	^ self mapInstVars: subjectClass instVarNames! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapInstVars: instVarNames	^ instVarNames collect: [ :each | self mapInstVar: each ]! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapProperty: propertyName getter: readBlock setter: writeBlock	| propertyMapping |	propertyMapping := NeoJSONPropertyMapping new.	propertyMapping 		propertyName: propertyName;		getter: readBlock;		setter: writeBlock.	properties removeAllSuchThat: [ :each | each propertyName = propertyMapping propertyName ].	properties addLast: propertyMapping.	^ propertyMapping ! !!NeoJSONObjectMapping methodsFor: 'accessing'!propertyNamed: propertyName ifAbsent: block	| symbolPropertyName |	symbolPropertyName := propertyName asSymbol.	^ properties detect: [ :each | each propertyName = symbolPropertyName ] ifNone: block! !!NeoJSONObjectMapping methodsFor: 'parsing'!readFrom: jsonReader	| anObject |	anObject := subjectClass new.	allowNil ifTrue: [ 		jsonReader parseConstantDo: [ :value | 			^ value ifNotNil: [ jsonReader error: 'Unexpected boolean constant' ] ] ].	jsonReader parseMapKeysDo: [ :key |		(self propertyNamed: key ifAbsent: [ nil ])			ifNil: [				"read, skip & ignore value"				jsonReader next ]			ifNotNil: [ :mapping |				mapping readObject: anObject from: jsonReader ] ].	^ anObject! !!NeoJSONObjectMapping methodsFor: 'accessing'!subjectClass: smalltalkClass	subjectClass := smalltalkClass! !!NeoJSONObjectMapping methodsFor: 'writing'!writeObject: anObject on: jsonWriter	jsonWriter writeMapStreamingDo: [ :jsonMapWriter |		properties do: [ :each |			each writeObject: anObject on: jsonMapWriter ] ]! !!NeoJSONPropertyMapping methodsFor: 'accessing'!getter: block	getter := block! !!NeoJSONPropertyMapping methodsFor: 'printing'!printOn: stream	super printOn: stream.	stream nextPut: $(; print: propertyName; nextPut: $)! !!NeoJSONPropertyMapping methodsFor: 'accessing'!propertyName	^ propertyName ! !!NeoJSONPropertyMapping methodsFor: 'accessing'!propertyName: symbolOrString	propertyName := symbolOrString asSymbol! !!NeoJSONPropertyMapping methodsFor: 'parsing'!readObject: anObject from: jsonReader	| value |	value := jsonReader nextAs: valueSchema.	setter value: anObject value: value! !!NeoJSONPropertyMapping methodsFor: 'accessing'!setter: block	setter := block! !!NeoJSONPropertyMapping methodsFor: 'accessing'!valueSchema: schemaName	valueSchema := schemaName! !!NeoJSONPropertyMapping methodsFor: 'writing'!writeObject: anObject on: jsonMapWriter	| value |	value := getter value: anObject.	(value notNil or: [ jsonMapWriter writeNil ])		ifTrue: [ jsonMapWriter writeKey: propertyName value: value as: valueSchema ] ! !!NeoJSONStreamingWriter class methodsFor: 'instance creation'!on: jsonWriter	^ self new		on: jsonWriter;		yourself! !!NeoJSONStreamingWriter methodsFor: 'initialize-release'!initialize	super initialize.	first := true! !!NeoJSONStreamingWriter methodsFor: 'initialize-release'!on: aJSONWriter	jsonWriter := aJSONWriter! !!NeoJSONStreamingWriter methodsFor: 'testing'!wasUsed	^ first not! !!NeoJSONStreamingWriter methodsFor: 'writing'!writeElement: value	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter listElementSeparator ].	jsonWriter nextPut: value ! !!NeoJSONStreamingWriter methodsFor: 'writing'!writeElement: value as: valueSchema	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter listElementSeparator ].	jsonWriter nextPut: value as: valueSchema! !!NeoJSONStreamingWriter methodsFor: 'writing'!writeKey: key value: value	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter mapElementSeparator ].	jsonWriter encodeKey: key value: value ! !!NeoJSONStreamingWriter methodsFor: 'writing'!writeKey: key value: value as: valueSchema	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter mapElementSeparator ].	jsonWriter encodeKey: key value: value as: valueSchema! !!NeoJSONStreamingWriter methodsFor: 'accessing'!writeNil	^ jsonWriter writeNil! !!Object methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeObject: self! !!Number methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeFloat: self asFloat! !!Dictionary methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeMap: self! !!UndefinedObject methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeNull! !!String methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeString: self! !!Boolean methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeBoolean: self! !!NeoJSONMappingNotFound class methodsFor: 'instance creation'!signalFor: anObject	"Create and signal an exception for anObject in the default receiver."		^ self new		object: anObject;		signal! !!NeoJSONMappingNotFound class methodsFor: 'instance creation'!signalFor: anObject in: aCollection	"Create and signal an exception for anObject in aCollection."	^ self new		object: anObject;		collection: aCollection;		signal! !!NeoJSONMappingNotFound methodsFor: 'accessing'!collection	"Return the collection where something is not found in"		^ collection! !!NeoJSONMappingNotFound methodsFor: 'accessing'!collection: aCollection	"Set the collection where something is not found in"		collection := aCollection! !!NeoJSONMappingNotFound methodsFor: 'accessing'!messageText	"Overwritten with standard text. To ease portability to other Smalltalk dialects we do not access the instVar 'messageText' as not all dialects have it. Not caching the value on the instVar shouldn't bring any performance hit in this case. "		^ self standardMessageText ! !!NeoJSONMappingNotFound methodsFor: 'accessing'!object	"Return the object that was not found"		^ object! !!NeoJSONMappingNotFound methodsFor: 'accessing'!object: anObject	"Set the object that was not found"		object := anObject! !!NeoJSONMappingNotFound methodsFor: 'private'!standardMessageText	^ String streamContents: [ :stream |		stream << 'No mapping found for '.		stream print: self object.		stream << ' in '.		stream print: self collection class ]! !!NeoJSONArray class methodsFor: 'example'!exampleNumbers	<gtExample>	| numbers |	numbers := self new: 128 withAll: nil.	0 to: 127 do: [ :n | 		numbers			at: n + 1			put: (NeoJSONObject new					integer: n;					decimal: (n printStringBase: 10);					octal: (n printStringBase: 8);					hexadecimal: (n printStringBase: 16);					binary: (n printStringBase: 2);					roman: n printStringRoman;					words: n asWords;					prime: n isPrime;					character: n asCharacter asString) ].	^ numbers! !!NeoJSONArray class methodsFor: 'example'!exampleSimple	<gtExample>	^ self withAll: { 0 . 1 . Float pi. 'string' . true . false. nil }! !!NeoJSONArray methodsFor: 'adding'!at: index add: object	^ index = '-'		ifTrue: [ self addLast: object ]		ifFalse: [ self insert: object before: index ]! !!NeoJSONArray methodsFor: 'accessing'!atPath: keyCollection	"Use each key in keyCollection recursively, return nil when a key is missing.	Note how keys can also be indexes to arrays."	| value |	value := self.	keyCollection do: [ :each |		value := value at: each ifAbsent: [ ^ nil ] ].	^ value! !!NeoJSONArray methodsFor: 'adding'!atPath: keyCollection add: newValue	"Use each key in keyCollection recursively, create new levels when needed.	Note how keys can also be indexes to arrays.	This variant will insert/add to arrays"	| target |	keyCollection ifEmpty: [ ^ self ].	target := self.	keyCollection allButLastDo: [ :each |		target := target 			at: each			ifAbsent: [ target at: each add: target species new ] ].	^ target at: keyCollection last add: newValue! !!NeoJSONArray methodsFor: 'accessing'!atPath: keyCollection put: newValue	"Use each key in keyCollection recursively, create new levels when needed.	Note how keys can also be indexes to arrays."	| target |	keyCollection ifEmpty: [ ^ self ].	target := self.	keyCollection allButLastDo: [ :each |		target := target 			at: each			ifAbsent: [ target at: each put: target species new ] ].	^ target at: keyCollection last put: newValue! !!NeoJSONArray methodsFor: 'accessing'!findPath: conditionBlock	"Find and return the first path to an object in the graph that I represent 	for which conditionBlock holds. Return nil when not found."	(conditionBlock value: self) ifTrue: [ ^ #(()) ].	self doWithIndex: [ :value :index |		(conditionBlock value: value) ifTrue: [ ^ { index } ].		(value isCollection and: [ value isString not ]) ifTrue: [			(value findPath: conditionBlock) ifNotNil: [ :subPath |				^ { index } , subPath ] ] ].	^ nil! !!NeoJSONArray methodsFor: 'accessing'!findPaths: conditionBlock	"Find and return all paths to objects in the graph that I represent 	for which conditionBlock holds. Return an empty collection when none are found."	| found |	found := OrderedCollection new.		self doWithIndex: [ :value :index |		(conditionBlock value: value) ifTrue: [ found add: { index } ].		(value isCollection and: [ value isString not ]) ifTrue: [			(value findPaths: conditionBlock) do: [ :subPath |				found add: { index } , subPath ] ] ].	^ found! !!NeoJSONArray methodsFor: 'print'!printOn: stream	"I use my JSON representation when printing myself"	[ (NeoJSONWriter on: stream) nextPut: self ]		on: Error		do: [ :exception |			stream				nextPutAll: ' Error printing JSON: ';				print: exception ]! !!NeoJSONArray methodsFor: 'removing'!removeKey: index	"Polymorphic with NeoJSONObject: remove the element at index"	^ self removeAt: index! !!Integer methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeInteger: self! !!NeoJSONObject class methodsFor: 'example'!exampleCoordinates	<gtExample>	^ (0 to: 4) 		collect: [ :each | self new x: each; y: each * 2 ]		as: NeoJSONArray! !!NeoJSONObject class methodsFor: 'example'!exampleCoordinatesParsing	<gtExample>	| result |	result := self fromString: NeoJSONReader exampleCoordinatesJSON.	self assert: result equals: self exampleCoordinates.	^ result! !!NeoJSONObject class methodsFor: 'example'!exampleCoordinatesWriting	<gtExample>	^ self exampleCoordinates printString! !!NeoJSONObject class methodsFor: 'example'!exampleMagnitudeClassHierarchy	<gtExample>	| builder |	builder := [ :aClass | 		NeoJSONObject new			name: aClass name;			superclass: aClass superclass name;			instanceVariables: aClass instVarNames;			category: aClass category;			totalInstanceVariablesCount: aClass allInstVarNames size;			methodCount: aClass methods size;			totalMethodCount: aClass allMethods size;			subclasses: (aClass subclasses 								collect: [ :aSubclass | builder value: aSubclass ] 								as: NeoJSONArray) ].	^ builder value: Magnitude! !!NeoJSONObject class methodsFor: 'example'!exampleNested	<gtExample>	^ self exampleSimple array: NeoJSONArray exampleSimple! !!NeoJSONObject class methodsFor: 'example'!exampleNestedRoundtrip	<gtExample>	| json result|	json := self exampleNested printString.	result := self fromString: json.	self assert: result equals: self exampleNested.	^ result! !!NeoJSONObject class methodsFor: 'example'!exampleSimple	<gtExample>	^ self new		foo: 100;		bar: 200! !!NeoJSONObject class methodsFor: 'example'!exampleSimpleJSON	<gtExample>	^ '{"foo":100,"bar":200}'! !!NeoJSONObject class methodsFor: 'example'!exampleSimpleParsing	<gtExample>	| result |	result := self fromString: self exampleSimpleJSON.	self assert: result equals: self exampleSimple.	^ result! !!NeoJSONObject class methodsFor: 'example'!exampleSimpleUsage	<gtExample>	| simple |	simple := NeoJSONObject exampleSimple.	self assert: simple foo equals: (simple at: #foo).	self assert: (simple foo: -1) equals: (simple at: #foo put: -1; yourself).	self assert: (simple includesKey: #baz) not.	self assert: simple baz equals: nil.	^ simple! !!NeoJSONObject class methodsFor: 'example'!exampleSimpleWriting	<gtExample>	| result |	result := self exampleSimple printString.	self assert: result equals: self exampleSimpleJSON.	^ result! !!NeoJSONObject class methodsFor: 'convenience'!fromStream: readStream	"Parse stream as JSON, so that maps become instances of me and lists instances of NeoJSONArray"	^ (NeoJSONReader on: readStream readStream)			mapClass: self;			listClass: NeoJSONArray;			propertyNamesAsSymbols: true;			next! !!NeoJSONObject class methodsFor: 'convenience'!fromString: string	"Parse string as JSON, so that maps become instances of me and lists instances of NeoJSONArray"	^ self fromStream: string readStream! !!NeoJSONObject class methodsFor: 'convenience'!readFrom: readStream	"Parse stream as JSON, so that maps become instances of me and lists instances of NeoJSONArray"	^ self fromStream: readStream! !!NeoJSONObject methodsFor: 'accessing'!at: key	"I return nil for missing keys.	My superclass would signal a KeyNotFound."	^ self at: key ifAbsent: [ nil ]! !!NeoJSONObject methodsFor: 'add'!at: key add: object	^ self at: key put: object! !!NeoJSONObject methodsFor: 'nested dictionaries'!at: firstKey at: secondKey	"I return nil for missing keys.	My superclass would signal a KeyNotFound."	^ self atPath: { firstKey. secondKey }! !!NeoJSONObject methodsFor: 'nested dictionaries'!at: firstKey at: secondKey put: value	"Store value under secondKey in nested object under firstKey, create new level when needed"	^ self atPath: { firstKey. secondKey } put: value! !!NeoJSONObject methodsFor: 'accessing'!at: key ifPresent: aPresentBlock ifAbsentPut: anAbsentBlock	"Lookup the given key in the receiver. If it is present, answer the	value of evaluating the first block optionally with the value associated with the key.	Otherwise store and return the result of evaluating the second block as the new value of the key."	"Overwritten to patch a bug in the superclass implementation in Pharo 7 and 8.	This problem was fixed in Pharo 9 where this overwrite is no longer necessary but harmless."	^ self		at: key		ifPresent: aPresentBlock		ifAbsent: [ self at: key put: anAbsentBlock value ]! !!NeoJSONObject methodsFor: 'accessing'!atPath: keyCollection	"Use each key in keyCollection recursively, return nil when a key is missing.	Note how keys can also be indexes to arrays."	| value |	value := self.	keyCollection do: [ :each |		value := value at: each ifAbsent: [ ^ nil ] ].	^ value! !!NeoJSONObject methodsFor: 'accessing'!atPath: keyCollection add: newValue	"Use each key in keyCollection recursively, create new levels when needed.	Note how keys can also be indexes to arrays.	This variant will insert/add to arrays."	| target |	keyCollection ifEmpty: [ ^ self ].	target := self.	keyCollection allButLastDo: [ :each |		target := target 			at: each			ifAbsent: [ target at: each add: target species new ] ].	^ target at: keyCollection last add: newValue! !!NeoJSONObject methodsFor: 'accessing'!atPath: keyCollection put: newValue	"Use each key in keyCollection recursively, create new levels when needed.	Note how keys can also be indexes to arrays."	| target |	keyCollection ifEmpty: [ ^ self ].	target := self.	keyCollection allButLastDo: [ :each |		target := target 			at: each			ifAbsent: [ target at: each put: target species new ] ].	^ target at: keyCollection last put: newValue! !!NeoJSONObject methodsFor: 'reflective operations'!doesNotUnderstand: message	"Overwritten so that 'self foo' becomes 'self at: #foo'	and 'self foo: 1' becomes 'self at: #foo put: 1' except that self is returned"	| key |	key := message selector.	key isUnary		ifTrue: [ ^ self at: key ].	^ (key isKeyword and: [ key numArgs = 1 ])		ifTrue: [ self at: key allButLast asSymbol put: message arguments first; yourself ]		ifFalse: [ super doesNotUnderstand: message ]! !!NeoJSONObject methodsFor: 'accessing'!findPath: conditionBlock	"Find and return the first path to an object in the graph that I represent 	for which conditionBlock holds. Return nil when not found."	(conditionBlock value: self) ifTrue: [ ^ #(()) ].	self keysAndValuesDo: [ :key :value |		(conditionBlock value: value) ifTrue: [ ^ { key } ].		(value isCollection and: [ value isString not ]) ifTrue: [			(value findPath: conditionBlock) ifNotNil: [ :subPath |				^ { key } , subPath ] ] ].	^ nil! !!NeoJSONObject methodsFor: 'accessing'!findPaths: conditionBlock	"Find and return all paths to objects in the graph that I represent 	for which conditionBlock holds. Return an empty collection when none are found."	| found |	found := OrderedCollection new.	self keysAndValuesDo: [ :key :value |		(conditionBlock value: value) ifTrue: [ found add: { key } ].		(value isCollection and: [ value isString not ]) ifTrue: [			(value findPaths: conditionBlock) do: [ :subPath |				found add: { key } , subPath ] ] ].	^ found! !!NeoJSONObject methodsFor: 'accessing'!name	"Overwritten to make this accessor available as key"	^ self at: #name! !!NeoJSONObject methodsFor: 'printing'!printOn: stream	"I use my JSON representation when printing myself"	[ (NeoJSONWriter on: stream) nextPut: self ]		on: Error		do: [ :exception |			stream				nextPutAll: ' Error printing JSON: ';				print: exception ]! !!NeoJSONObject methodsFor: 'accessing'!removeAtPath: keyCollection	"Use each key in keyCollection recursively and remove the final key.	Note how keys can also be indexes to arrays."	| target |	keyCollection ifEmpty: [ ^ self ].	target := self.	keyCollection allButLastDo: [ :each |		target := target at: each ifAbsent: [ ^ self ] ].	^ target removeKey: keyCollection last! !!NeoJSONObject methodsFor: 'evaluating'!value	"Overwritten to make this accessor available as key"	^ self at: #value! !!Collection methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeList: self! !"Neo-JSON-Core"!!OrderedDictionary methodsFor: '*neo-json-pharo-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeMap: self! !!SmallDictionary methodsFor: '*neo-json-pharo-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeMap: self! !!NeoJSONBenchmarkTests commentStamp: '' prior: 0!I am NeoJSONBenchmarkTests.This test is obviously dependent on hardware, but the margin is quite high.!!NeoJSONExamplesTests commentStamp: '' prior: 0!NeoJSONExamplesTests runs a couple of examples as tests!!NeoJSONFloatPrinterTests commentStamp: '' prior: 0!I am NeoJSONFloatPrinterTests, the collection of unit tests for NeoJSONFloatPrinter.!!NeoJSONMappingTests commentStamp: '' prior: 0!I am NeoJSONMappingTests, testing more exotic kinds of mapping constructs.!!NeoJSONObjectTests commentStamp: '' prior: 0!I am NeoJSONObjectTests, I hold unit tests for NeoJSONObject.!!NeoJSONReaderTests commentStamp: '' prior: 0!I am NeoJSONReaderTests, a test suite for NeoJSONReader.!!NeoJSONWriteReadTests commentStamp: '' prior: 0!I am NeoJSONWriteReadTests.!!NeoJSONWriteReadAsciiOnlyTests commentStamp: '' prior: 0!I am NeoJSONWriteReadAsciiOnlyTests.!!NeoJSONWriteReadMockStreamTests commentStamp: '' prior: 0!I am NeoJSONWriteReadMockStreamTests.!!NeoJSONWriteReadPrettyPrintedTests commentStamp: '' prior: 0!I am NeoJSONWriteReadPrettyPrintedTests.!!NeoJSONWriterTests commentStamp: '' prior: 0!I am NeoJSONWriterTests, a test suite for NeoJSONWriter.!!NeoJSONBenchmark commentStamp: '' prior: 0!I am NeoJSONBenchmark.I hold 1000 objects of the form Dictionary('color'->'green' 'enabled'->false 'id'->1 'name'->'Name-1' 'value'->0.002 ) in an Array.I hold the JSON serialization of that as a String of the form '[{"value":0.002,"enabled":false,"name":"Name-1","color":"green","id":1}, ...| benchmark |benchmark := NeoJSONBenchmark new.[benchmark read] bench.| benchmark |benchmark := NeoJSONBenchmark new.[benchmark write] bench.| benchmark |benchmark := NeoJSONBenchmark new.[benchmark read] timeToRun.| benchmark |benchmark := NeoJSONBenchmark new.[benchmark write] timeToRun.!!NeoJSONMockStream commentStamp: '' prior: 0!I am NeoJSONMockStream.I wrap another stream to validate the limited API used.!!NeoJSONTestObject1 commentStamp: '' prior: 0!I am NeoJSONTestObject1.I repesent a domain model object.I have the following properties:- id <Integer>- name <String>- timestamp <DateAndTime>- points <Array of: Point>- bytes <ByteArray>My JSON representation is like this:- id <Number>- name <String>- created-at <ISO8601 String>- points <Array of: <Map x,y>- bytes <Array of: Number>!!NeoJSONTestObject2 commentStamp: '' prior: 0!I am NeoJSONTestObject2.Instance Variables	data:		<String>	height:		<Integer>	id:			<Integer>	width:		<Integer>Used for benchmarking and other tests.!!NeoJSONTestObject3 commentStamp: '' prior: 0!I am NeoJSONTestObject3, a subclass of NeoJSONTestObject2.Instance Variables	color:			<String>	transparent :	<Boolean>I am used for inheritance testing.!!NeoJSONValidation commentStamp: '' prior: 0!I am NeoJSONValidation, a set of tests to validate NeoJSON against some external rules.Both positive & negative tests are includes.Some of these are implementation choices.http://seriot.ch/parsing_json.phphttps://github.com/nst/JSONTestSuitehttps://github.com/nst/JSONTestSuite.git  test_parsing  test_transformhttps://github.com/miloyip/nativejson-benchmarkhttps://github.com/miloyip/nativejson-benchmark.git  data/jsonchecker  data/roundtripThis can only be run with the correct setup (checkout/config).  NeoJSONValidation new runNativeJsonBenchmarkRoundTrip.  NeoJSONValidation new runNativeJsonBenchmarkJsonCheckerPasses.  NeoJSONValidation new runNativeJsonBenchmarkJsonCheckerFailures.  NeoJSONValidation new runJsonTestSuiteTestParsingPasses.  NeoJSONValidation new runJsonTestSuiteTestParsingFailures.  NeoJSONValidation new runJsonTestSuiteTestParsingInfo.Logging goes to a file, neo-json-validation.log!!NeoJSONBenchmarkTests methodsFor: 'testing'!testObject2	| json |	json := NeoJSONWriter toString: NeoJSONTestObject2 new.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject2)		equals: NeoJSONTestObject2 new! !!NeoJSONBenchmarkTests methodsFor: 'testing'!testPrettyPrinted	| benchmark |	benchmark := NeoJSONBenchmark new.	self		assert: benchmark writePrettyPrintedRead		equals: benchmark read! !!NeoJSONBenchmarkTests methodsFor: 'testing'!testRead	| benchmark |	benchmark := NeoJSONBenchmark new.	benchmark read! !!NeoJSONBenchmarkTests methodsFor: 'testing'!testWrite	| benchmark |	benchmark := NeoJSONBenchmark new.	benchmark write! !!NeoJSONExamplesTests methodsFor: 'tests'!testMultiInstances	"Newline delimited JSON (application/x-ndjson) - https://github.com/ndjson/ndjson-spec"	"JSON Lines (application/jsonl) - https://jsonlines.org"	| data json |		data := (1 to: 10) collect: [ :each |		{ #number -> each } asDictionary ].		json := String streamContents: [ :out |		(NeoJSONWriter on: out) nextPutAll: data ].		self assert: (NeoJSONReader on: json readStream) upToEnd equals: data.		self assert: (NeoJSONReader on: json readStream) next equals: data first.	self deny: ((NeoJSONReader on: json readStream) next; atEnd)! !!NeoJSONExamplesTests methodsFor: 'tests'!testPoints	| points json result |		points := Array with: 1@2 with: 3@4 with: 5@6.		json := String streamContents: [ :out |		(NeoJSONWriter on: out)			prettyPrint: true;			mapInstVarsFor: Point;			nextPut: points ].			result := (NeoJSONReader on: json readStream)		mapInstVarsFor: Point;		for: #ListOfPoints customDo: [ :mapping |			mapping listOfElementSchema: Point ];		nextAs: #ListOfPoints.		self assert: result equals: points.				result := (NeoJSONReader on: json readStream)		mapInstVarsFor: Point;		nextListAs: Point.		self assert: result equals: points.			result := (NeoJSONReader on: json readStream)		mapInstVarsFor: Point;		for: #OrderedCollectionOfPoints customDo: [ :mapping |			mapping listOfType: OrderedCollection andElementSchema: Point ];		nextAs: #OrderedCollectionOfPoints.		self assert: result equals: points asOrderedCollection.! !!NeoJSONExamplesTests methodsFor: 'tests'!testRectanglePoints	| rectangle rectangleJson result |	rectangle := Rectangle origin: 3 @ 4 extent: 5 @ 6.	rectangleJson := String streamContents: [ :stream | 		(NeoJSONWriter on: stream)			prettyPrint: true;			mapInstVarsFor: Point;			mapInstVarsFor: Rectangle;			nextPut: rectangle ].	result := (NeoJSONReader on: rectangleJson readStream)		mapInstVarsFor: Point;		for: Rectangle do: [ :mapping | 			(mapping mapInstVar: #origin) valueSchema: Point.			(mapping mapInstVar: #corner) valueSchema: Point ];		nextAs: Rectangle.	self assert: result equals: rectangle.	result := (NeoJSONReader on: rectangleJson readStream)		mapInstVarsFor: Point;		for: Rectangle do: [ :mapping | 			mapping mapInstVars do: [ :each | each valueSchema: Point ] ];		nextAs: Rectangle.			self assert: result equals: rectangle ! !!NeoJSONExamplesTests methodsFor: 'tests'!testRectanglePointsWithNils	self		assert: 			(String streamContents: [ :stream | 				(NeoJSONWriter on: stream)					for: Point do: [ :mapping | mapping mapAllInstVars ];					for: Rectangle do: [ :mapping | 						(mapping mapInstVar: #origin) valueSchema: Point.						(mapping mapInstVar: #corner) valueSchema: Point ];					nextPut: Rectangle new ])		equals: '{}'.	self		assert:			(String streamContents: [ :stream | 				(NeoJSONWriter on: stream)					for: Point do: [ :mapping | mapping mapAllInstVars ];					for: Rectangle	do: [ :mapping | 						(mapping mapInstVar: #origin) valueSchema: Point.						(mapping mapInstVar: #corner) valueSchema: Point ];					writeNil: true;					nextPut: Rectangle new ])		equals: '{"origin":null,"corner":null}'.! !!NeoJSONFloatPrinterTests methodsFor: 'running'!setUp	super setUp.	printer := NeoJSONFloatPrinter new! !!NeoJSONFloatPrinterTests methodsFor: 'tests'!testDecimalNotation	self assert: (printer print: 1.5) equals: '1.5'.	self assert: (printer print: -1.5) equals: '-1.5'.	self assert: (printer print: 0.5) equals: '0.5'.	self assert: (printer print: -0.5) equals: '-0.5'.	self assert: (printer print: (1/3) asFloat) equals: '0.33333'.	self assert: (printer print: (-1/3) asFloat) equals: '-0.33333'.	self assert: (printer print: 0.00123) equals: '0.00123'.	self assert: (printer print: -0.00123) equals: '-0.00123'.	self assert: (printer print: 0.00012) equals: '0.00012'.	self assert: (printer print: -0.00012) equals: '-0.00012'.	self assert: (printer print: 123456.12345) equals: '123456.12345'.	self assert: (printer print: -123456.12345) equals: '-123456.12345'.! !!NeoJSONFloatPrinterTests methodsFor: 'tests'!testInteger	self assert: (printer print: 1.0) equals: '1'.	self assert: (printer print: 0.0) equals: '0'.	self assert: (printer print: -1.0) equals: '-1'.	self assert: (printer print: 123.0) equals: '123'.	self assert: (printer print: 123456.0) equals: '123456'.	! !!NeoJSONFloatPrinterTests methodsFor: 'tests'!testLowPrecision	printer := NeoJSONFloatPrinter lowPrecision.	self assert: (printer print: (4/3) asFloat) equals: '1.33'.	self assert: (printer print: 12345.66) equals: '12345.66'.	self assert: (printer print: -123456.77) equals: '-1.23e5'.	self assert: (printer print: Float pi) equals: '3.14'.	self assert: (printer print: Float e negated) equals: '-2.72'.	"the earth's mass in kg"	self assert: (printer print: 5.9724e24) equals: '5.97e24'.	"mass of electron in kg"	self assert: (printer print: 9.10938356e-31) equals: '9.11e-31'.! !!NeoJSONFloatPrinterTests methodsFor: 'tests'!testScientificNotation	self assert: (printer print: 1234567.5) equals: '1.23457e6'. "note the rounding"	self assert: (printer print: -1234567.5) equals: '-1.23457e6'. "note the rounding"	self assert: (printer print: 0.0000123) equals: '1.23e-5'.	self assert: (printer print: -0.0000123) equals: '-1.23e-5'.! !!NeoJSONFloatPrinterTests methodsFor: 'tests'!testScientificOnly	printer := NeoJSONFloatPrinter scientificOnly.	self assert: (printer print: (4/3) asFloat) equals: '1.33333e0'.	self assert: (printer print: 12345.66) equals: '1.23457e4'.	self assert: (printer print: Float pi) equals: '3.14159e0'.	self assert: (printer print: Float e negated) equals: '-2.71828e0'.	"the earth's mass in kg"	self assert: (printer print: 5.9724e24) equals: '5.9724e24'.	"mass of electron in kg"	self assert: (printer print: 9.10938356e-31) equals: '9.10938e-31'.! !!NeoJSONFloatPrinterTests methodsFor: 'tests'!testSpecialValues	self assert: (printer print: Float zero) equals: '0'.	self assert: (printer print: Float nan) equals: 'NaN'.	self assert: (printer print: Float infinity) equals: 'Inf'.	self assert: (printer print: Float infinity negated) equals: '-Inf'.! !!NeoJSONFloatPrinterTests methodsFor: 'tests'!testWellKnownConstants	self assert: (printer print: Float pi) equals: '3.14159'.	self assert: (printer print: Float e) equals: '2.71828'.	"the earth's mass in kg"	self assert: (printer print: 5.9724e24) equals: '5.9724e24'.	"mass of electron in kg"	self assert: (printer print: 9.10938356e-31) equals: '9.10938e-31'.	"planck's constant in Js"	self assert: (printer print: 1.05457e-34) equals: '1.05457e-34'.	"speed of light in m/s"	self assert: (printer print: 2.99792e8) equals: '2.99792e8'.	"charge of electron in C"	self assert: (printer print: -1.60218e-19) equals: '-1.60218e-19'.	"boltzmann's constant in J/K"	self assert: (printer print: 1.38065e-23) equals: '1.38065e-23'.! !!NeoJSONMappingTests methodsFor: 'testing'!testDynamicTyping	| data customMapping json result |	data := Array with: 'foo'->1 with: #('foo' 2).	"The idea is to map a key value combination as either a classic association or a simple pair, 	using key & value properties as well as a type property to distinguish between the two"	customMapping := [ :mapper |		mapper 			for: #AssocOrPair customDo: [ :mapping |				mapping					encoder: [ :x | 						x isArray 							ifTrue: [ Dictionary new at: 'type' put: 'pair'; at: 'key' put: x first; at: 'value' put: x second; yourself ] 							ifFalse: [ Dictionary new at: 'type' put: 'assoc'; at: 'key' put: x key; at: 'value' put: x value; yourself ] ];					decoder: [ :x |						(x at: 'type') = 'pair'							ifTrue: [ Array with: (x at: 'key') with: (x at: 'value') ]							ifFalse: [ (x at: 'key') -> (x at: 'value')] ] ];			for: #ArrayOfAssocOrPair customDo: [ :mapping |				mapping listOfType: Array andElementSchema: #AssocOrPair ];			yourself ].	json := String streamContents: [ :out |		(customMapping value: (NeoJSONWriter on: out)) nextPut: data as: #ArrayOfAssocOrPair ].	result := (customMapping value: (NeoJSONReader on: json readStream)) nextAs: #ArrayOfAssocOrPair.	self assert: result equals: data! !!NeoJSONMappingTests methodsFor: 'testing'!testSymbolOrStringInstVarMapping	| data out1 out2 result1 result2 |	data := Array with: 1@2 with: 3@4.	out1 := String streamContents: [ :out |		(NeoJSONWriter on: out)			for: Point do: [ :mapping | mapping mapInstVars: #(x y) ];			nextPut: data ].	result1 := (NeoJSONReader on: out1 readStream)		for: Point do: [ :mapping | mapping mapInstVars: #(x y) ];		nextListAs: Point.	self assert: result1 equals: data.	out2 := String streamContents: [ :out |		(NeoJSONWriter on: out)			for: Point do: [ :mapping | mapping mapInstVars: #('x' 'y') ];			nextPut: data ].	result2 := (NeoJSONReader on: out1 readStream)		for: Point do: [ :mapping | mapping mapInstVars: #('x' 'y') ];		nextListAs: Point.	self assert: result2 equals: data! !!NeoJSONMappingTests methodsFor: 'testing'!testVirtualTransferObject	| data customMapping extraJson json result |	data := NeoJSONObject new data: (Array with: 1@1 with: 2@2).	extraJson := '{"foo":1,"data":[{"x":1,"y":1},{"x":2,"y":2,"z":-1}]}'.	"The idea here is that we are not interested in the top level object just in its data property, 	which should be of a specific type, hence we create a virtual transfer object"	customMapping := [ :mapper |		mapper			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			for: #ArrayOfPoints customDo: [ :mapping |				mapping listOfElementSchema: Point ];			for: #TransferObject do: [ :mapping |				mapping subjectClass: NeoJSONObject.				(mapping mapAccessor: #data) valueSchema: #ArrayOfPoints ];			yourself ].	"By using NeoJSONObject accessors (#data & #data:) are translated to generic #at:[put:] messages.	A longer alternative is 	(mapping mapProperty: #data getter: [ :obj | obj at: #data ] setter: [ :obj :x | obj at: #data put: x]) valueSchema: #ArrayOfPoints	where the blocks give you the flexibility to use a plain Dictionary for example"	result := (customMapping value: (NeoJSONReader on: extraJson readStream)) nextAs: #TransferObject.	self assert: result equals: data.	json := String streamContents: [ :out |		(customMapping value: (NeoJSONWriter on: out)) nextPut: data as: #TransferObject ].	result := (customMapping value: (NeoJSONReader on: json readStream)) nextAs: #TransferObject.	self assert: result equals: data! !!NeoJSONObjectTests methodsFor: 'accessing'!exampleJSONSchema	^ NeoJSONObject fromString: '{  "$id" : "https://example.com/schemas/address",  "type" : "object",  "properties" : {    "street_address" : { "$anchor" : "street_address", "type" : "string" },    "city" : { "type" : "string" },    "state" : { "type" : "string" }  },   "required" : ["street_address", "city", "state"],  "$defs" : {    "country" : { "type" : "object", "$anchor" : "country", "enum" : ["us","canada","gb"] }  }}'! !!NeoJSONObjectTests methodsFor: 'testing'!testArray	| jsonArray array |	jsonArray := '[1,2,3]'.	array := NeoJSONObject fromString: jsonArray.	self assert: array asString equals: jsonArray.	self assertCollection: array hasSameElements: #(1 2 3).	array at: 1 add: 0.	array at: #- add: 4.	self assertCollection: array hasSameElements: #(0 1 2 3 4).	array removeKey: 5.	array removeKey: 1.	self assertCollection: array hasSameElements: #(1 2 3)! !!NeoJSONObjectTests methodsFor: 'testing'!testAtAt	| object |	object := NeoJSONObject new.	self assert: (object at: #foo) isNil.	self assert: (object at: #foo at: #bar) isNil.	object at: #foo at: #bar put: 123.	self assert: (object at: #foo) notNil.	self assert: (object at: #foo at: #bar) equals: 123.	self assert: object foo bar equals: 123.	object at: #foo at: #bar put: -1.	self assert: (object at: #foo at: #bar) equals: -1.	self assert: (object at: #foo at: #foo) isNil! !!NeoJSONObjectTests methodsFor: 'testing'!testAtPath	| object |	object := NeoJSONObject newFrom:  (Array with:  #one -> ( NeoJSONObject newFrom:  (Array with:  #two -> ( NeoJSONObject newFrom: (Array with:  #three -> 42) ) ) )).	self assert: (object atPath: #(one two three)) equals: 42.	self assert: (object atPath: #(one two three)) equals: object one two three.		self assert: (object atPath: #(missing)) equals: nil.	self assert: (object atPath: #(one missing)) equals: nil.	self assert: (object atPath: #(one two missing)) equals: nil.	self assert: (object atPath: #(one two missing)) equals: object one two missing.		object := NeoJSONObject newFrom:  (Array with: #foo -> 42).	self assert: (object atPath: #(foo)) equals: 42.	self assert: (object atPath: #(foo)) equals: object foo.	self assert: (object atPath: #(foo)) equals: (object at: #foo).	self assert: (object atPath: #()) equals: object.	! !!NeoJSONObjectTests methodsFor: 'testing'!testAtPathPut	| object |	object := NeoJSONObject new.	object atPath: #(one test) put: 42.	self assert: (object atPath: #(one test)) equals: 42.	self assert: object one test equals: 42.	object atPath: #(one two three) put: #foo.	self assert: (object atPath: #(one two three)) equals: #foo.	self assert: object one two three equals: #foo.	object atPath: #(one two threeBis) put: #bar.	self assert: (object atPath: #(one two threeBis)) equals: #bar.	self assert: object one two threeBis equals: #bar.		self assert: object foo isNil.	self assert: (object atPath: #() put: 1) equals: object.	self assert: (object atPath: #(foo) put: 1) equals: 1.	self assert: (object atPath: #(foo)) equals: 1.	self assert: object foo equals: 1	 ! !!NeoJSONObjectTests methodsFor: 'testing'!testCRUD	| object |	object := NeoJSONObject new.	self assert: object isEmpty.	self assert: object foo equals: nil.	object foo: 123.	self assert: object foo equals: 123.	self assert: object printString equals: '{"foo":123}'.	object name: 'test'.	object value: Float pi.	self assert: object name equals: 'test'.	self assert: (object value closeTo: Float pi).	self assert: object keys asSet equals: #(foo name value) asSet.	object removeKey: #foo.	self assert: object foo equals: nil.	object removeAll.	self assert: object isEmpty! !!NeoJSONObjectTests methodsFor: 'testing'!testFindPath	| json path |	json := self exampleJSONSchema.		path := json findPath: [ :object | object isDictionary and: [ (object at: '$anchor') = 'street_address' ] ].	self deny: path isNil.	self assert: path equals: #(properties street_address).	self assert: ((json atPath: path) at: '$anchor') equals: 'street_address'.			path := json findPath: [ :object | object isDictionary and: [ (object at: 'foo') = 'bar' ] ].	self assert: path isNil.		path := json findPath: [ :object | object isDictionary and: [ (object at: '$anchor') = 'country' ] ].	self deny: path isNil.	self assert: path equals: #('$defs' country).	self assert: ((json atPath: path) at: '$anchor') equals: 'country'.		json := NeoJSONObject new at: '$anchor' put: 'top'; yourself.	self 		assert: (json findPath: [ :object | object isDictionary and: [ (object at: '$anchor') = 'top' ] ])		equals: #(())! !!NeoJSONObjectTests methodsFor: 'testing'!testFindPaths	| json paths |	json := self exampleJSONSchema.		paths := json findPaths: [ :object | object isDictionary and: [ object includesKey: '$anchor' ] ].	self deny: paths isEmpty.	self assert: paths asArray equals: #((properties street_address) ('$defs' country)).	self assert: ((json atPath: paths first) at: '$anchor') equals: 'street_address'.	self assert: ((json atPath: paths second) at: '$anchor') equals: 'country'.				paths := json findPaths: [ :object | object isDictionary and: [ (object at: 'foo') = 'bar' ] ].	self assert: paths isEmpty.		paths := json findPaths: [ :object | object isDictionary and: [ object includesKey: #type ] ].	self deny: paths isEmpty.	paths do: [ :path |		self assert: (#(string object) includes: ((json atPath: path) at: #type)) ].			paths := json findPaths: [ :_ | true ].	paths do: [ :each | 		self assert: (json atPath: each) notNil ]! !!NeoJSONObjectTests methodsFor: 'testing'!testJSON	| data  json object |	data := NeoJSONObject newFrom: (Array with: #foo->1 with: #bar->2 with: #str->'Str!!' with: #bool->true with: #flt->1.5).	json := NeoJSONWriter toString: data .	object := NeoJSONObject fromString: json.	self assert: object class equals: NeoJSONObject.	self assert: object equals: data.	json := (NeoJSONWriter toString: object).	self assert: (NeoJSONObject fromString: json) equals: object! !!NeoJSONObjectTests methodsFor: 'testing'!testPathAccess	| data |	data := NeoJSONObject fromString: '{"foo":1,"bar":2,"array":[{"a":1},{"b":2}]}'.	self assert: (data atPath: #(array 1 a)) equals: 1.	self assert: (data atPath: #(array 2 b)) equals: 2.	self assert: (data atPath: #(missing 1)) equals: nil.	data atPath: #(missing) put: 7.	self assert: (data atPath: #(missing)) equals: 7.	self assert: (data atPath: #(array 3)) equals: nil.	data := NeoJSONObject fromString: '[{"c":1},{"c":2},{"c":3}]'.	self assert: (data atPath: #(2 c)) equals: 2.	self assert: (data atPath: #(10 c)) equals: nil.	self assert: (data atPath: #(3 missing)) equals: nil.	data atPath: #(3 missing) put: #found.	self assert: (data atPath: #(3 missing)) equals: #found.	(data at: 3) removeKey: #missing.	self assert: (data atPath: #(3 missing)) equals: nil.	data atPath: #(3 missing x) put: #found.	self assert: (data atPath: #(3 missing x)) equals: #found.! !!NeoJSONReaderTests methodsFor: 'testing'!testAllowNil	self 		should: [ 			(NeoJSONReader on: 'null' readStream)				mapInstVarsFor: Point;				nextAs: Point ] 		raise: NeoJSONParseError.	self		assert: ((NeoJSONReader on: 'null' readStream)						mapInstVarsFor: Point;						for: Point do: [ :mapping | mapping allowNil ];						nextAs: Point)		equals: nil.	self		assert: ((NeoJSONReader on: '[ { "x" : 1, "y" : 2 }, null, { "x" : 3, "y" : -1 } ]' readStream)						mapInstVarsFor: Point;						for: Point do: [ :mapping | mapping allowNil ];						for: #ArrayOfPoints customDo: [ :mapping | mapping listOfElementSchema: Point ];						nextAs: #ArrayOfPoints)		equals: (Array with: 1 @ 2 with: nil with: 3 @ -1).! !!NeoJSONReaderTests methodsFor: 'testing'!testArrayOfPoints	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			for: #ArrayOfPoints customDo: [ :mapping |				mapping listOfElementSchema: Point ];			nextAs: #ArrayOfPoints ].	self assert: (reader value: '[ { "x":1, "y":2 }, { "x":-1, "y":-2 } ]') equals: (Array with: 1@2 with: -1@ -2) . 	self assert: (reader value: '[ ]') equals: #().	self assert: (reader value: '[ { } ]') equals: (Array with: Point new)! !!NeoJSONReaderTests methodsFor: 'testing'!testArrayOfPointsUsingNextListAs	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			mapInstVarsFor: Point;			nextListAs: Point ].	self assert: (reader value: '[ { "x":1, "y":2 }, { "y":-2, "x":-1 } ]') equals: (Array with: 1@2 with: -1@ -2) . 	self assert: (reader value: '[ ]') equals: #().	self assert: (reader value: '[ { } ]') equals: (Array with: Point new) ! !!NeoJSONReaderTests methodsFor: 'testing'!testAssociation	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Association do: [ :mapping |				mapping mapAccessors: #(key value) ]; 			nextAs: Association ].	self assert: (reader value: '{"key":"foo","value":42}') equals: 'foo' -> 42. 	self assert: (reader value: '{}') equals: Association new! !!NeoJSONReaderTests methodsFor: 'testing'!testBooleans	self assert: (NeoJSONReader on: 'true' readStream) next equals: true.	self assert: (NeoJSONReader on: 'false' readStream) next equals: false.	self should: [ (NeoJSONReader on: 'tru' readStream) next ] raise: NeoJSONParseError.	self should: [ (NeoJSONReader on: 'falsE' readStream) next ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing'!testByteArray	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: ByteArray customDo: [ :mapping |				mapping listOfType: ByteArray ];			nextAs: ByteArray ].	self assert: (reader value: '[ 1, 2, 3 ]') equals: #[1 2 3].	self assert: (reader value: '[ ]') equals: ByteArray new! !!NeoJSONReaderTests methodsFor: 'testing'!testDate	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: Date customDo: [ :mapping |				mapping decoder: [ :string | Date fromString: string ] ];			nextAs: Date ].	self assert: (reader value: ' "2012-06-08" ') equals: (Date fromString: '2012-06-08') ! !!NeoJSONReaderTests methodsFor: 'testing'!testDateAndTime 	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: DateAndTime customDo: [ :mapping |				mapping decoder: [ :string | DateAndTime fromString: string ] ];			nextAs: DateAndTime ].	self 		assert: (reader value: ' "2012-02-14T16:40:18+01:00" ') 		equals: (DateAndTime year: 2012 month: 2 day: 14 hour: 16 minute: 40 second: 18 offset: 1 hour)! !!NeoJSONReaderTests methodsFor: 'testing'!testFloats	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: ((reader value: '123.0') closeTo: 123.0).	self assert: ((reader value: '-123.0') closeTo: -123.0).	self assert: ((reader value: '123.0e0') closeTo: 123.0).	self assert: ((reader value: '123e6') closeTo: 123e6).	self assert: ((reader value: '123e+6') closeTo: 123e6).	self assert: ((reader value: '123e-6') closeTo: 123e-6).	self assert: ((reader value: '123E6') closeTo: 123e6).	self assert: ((reader value: '123E+6') closeTo: 123e6).	self assert: ((reader value: '123E-6') closeTo: 123e-6).	self assert: ((reader value: '-123e6') closeTo: -123e6).	self assert: ((reader value: '-123e-6') closeTo: -123e-6).	self assert: ((reader value: '-123E6') closeTo: -123e6).	self assert: ((reader value: '-123E-6') closeTo: -123e-6).	self assert: ((reader value: '3.14159') closeTo: Float pi).	self assert: ((reader value: '0.123e6') closeTo: 0.123e6).	self assert: ((reader value: '0.123e-6') closeTo: 0.123e-6).	self assert: ((reader value: '-0.123E6') closeTo: -0.123e6).	self assert: ((reader value: '-0.123E-6') closeTo: -0.123e-6).! !!NeoJSONReaderTests methodsFor: 'testing'!testIntegers	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '123') equals: 123.	self assert: (reader value: '00123') equals: 123.	self assert: (reader value: '-123') equals: -123.	self assert: (reader value: '-0123') equals: -123.	self assert: (reader value: '0') equals: 0.	self assert: (reader value: '-0') equals: 0.	self assert: (reader value: '00') equals: 0.	self assert: (reader value: ' 123	') equals: 123.	self should: [ reader value: '+1' ] raise: NeoJSONParseError.	self should: [ reader value: ' - ' ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing'!testLists	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '[1,2,3]') equals: #(1 2 3).	self assert: (reader value: '[]') equals: #().	self assert: (reader value: ' [ 1 , 2 , 3 ] ') equals: #(1 2 3).	self assert: (reader value: ' [ ] ') equals: #().	self should: [ reader value: '[1,]' ] raise: NeoJSONParseError. 	self should: [ reader value: '[' ] raise: NeoJSONParseError.	self should: [ reader value: ']' ] raise: NeoJSONParseError.	self should: [ reader value: '[}' ] raise: NeoJSONParseError! !!NeoJSONReaderTests methodsFor: 'testing'!testMaps	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '{"x":1,"y":2}') equals: (Dictionary newFromPairs: #( 'x' 1 'y' 2)).	self assert: (reader value: '{}') equals: Dictionary new.	self assert: (reader value: ' { "x" : 1 , "y" : 2 } ' ) equals: (Dictionary newFromPairs: #( 'x' 1 'y' 2)).	self assert: (reader value: ' { } ') equals: Dictionary new.	self should: [ reader value: '{"foo":}' ] raise: NeoJSONParseError. 	self should: [ reader value: '{"foo":9,}' ] raise: NeoJSONParseError. 	self should: [ reader value: '{9:true,}' ] raise: NeoJSONParseError. 	self should: [ reader value: '{' ] raise: NeoJSONParseError.	self should: [ reader value: '}' ] raise: NeoJSONParseError.	self should: [ reader value: '{]' ] raise: NeoJSONParseError! !!NeoJSONReaderTests methodsFor: 'testing'!testNextStringAsHex	| string |	string := (NeoJSONReader on: '"466F6F2062617221"' readStream)		for: #StringAsHex			customDo: [ :mapping | 					mapping						encoder: [ :x | x asByteArray hex asUppercase ];						decoder: [ :x | (ByteArray readHexFrom: x) asString ] ];		nextAs: #StringAsHex.	self assert: string equals: 'Foo bar!!'! !!NeoJSONReaderTests methodsFor: 'testing'!testNonBMPCharacterDecoding	"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"	| string object |	string := 16r1D11E asCharacter asString. "MUSICAL SYMBOL G CLEF"	object := (NeoJSONReader fromString: '"\uD834\uDD1E"').	self assert: object equals: string.		"UTF-16 surrogate pairs might be invalid, make sure an error is raised"	self should: [ NeoJSONReader fromString: '"\udbff\ue000"' ] raise: NeoJSONParseError! !!NeoJSONReaderTests methodsFor: 'testing'!testNull	self assert: (NeoJSONReader on: 'null' readStream) next equals: nil.	self assert: (NeoJSONReader on: '	null ' readStream) next equals: nil.	self should: [ (NeoJSONReader on: '	nil ' readStream) next ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing'!testOrderedCollection	| json list |	json := '[ 1, 2, 3 ]'.	list := (NeoJSONReader on: json readStream) 		listClass: OrderedCollection;		next.	self 		assert: list 		equals: (OrderedCollection with: 1 with: 2 with: 3).	self 		assert: list class 		equals: OrderedCollection! !!NeoJSONReaderTests methodsFor: 'testing'!testOrderedCollectionOfPoints	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			for: #OrderedCollectionOfPoints customDo: [ :mapping |				mapping listOfType: OrderedCollection andElementSchema: Point ];			nextAs: #OrderedCollectionOfPoints ].	self assert: (reader value: '[ { "x":1, "y":2 }, { "x":-1, "y":-2 } ]') equals: (Array with: 1@2 with: -1@ -2) asOrderedCollection. 	self assert: (reader value: '[ ]') equals: OrderedCollection new.	self assert: (reader value: '[ { } ]') equals: (OrderedCollection with: Point new)! !!NeoJSONReaderTests methodsFor: 'testing'!testParseErrors	self should: [ NeoJSONReader fromString: 'zero' ] raise: NeoJSONParseError.	self should: [ NeoJSONReader fromString: '#' ] raise: NeoJSONParseError.	self should: [ NeoJSONReader fromString: '@' ] raise: NeoJSONParseError.		self should: [ (NeoJSONReader on: '[1,2,3]true' readStream) next; failIfNotAtEnd ] raise: NeoJSONParseError.	self should: [ (NeoJSONReader on: '{"foo":1}"extra"' readStream) next; failIfNotAtEnd ] raise: NeoJSONParseError.	self should: [ (NeoJSONReader on: '[]"extra"' readStream) next; failIfNotAtEnd ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing'!testPoint	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) nextAs: Point ].	self should: [ reader value: '{"x":1,"y":2}' ] raise: NeoJSONMappingNotFound! !!NeoJSONReaderTests methodsFor: 'testing'!testPoint1	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapProperty: 'x' getter: [ :point | point x ] setter: [ :point :value | point setX: value setY: point y ].				mapping mapProperty: 'y' getter: [ :point | point y ] setter: [ :point :value | point setX: point x setY: value ]. ];			nextAs: Point ].	self assert: (reader value: '{"x":1,"y":2}') equals: 1@2. 	self assert: (reader value: '{}') equals: Point new! !!NeoJSONReaderTests methodsFor: 'testing'!testPoint2	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			mapAllInstVarsFor: Point;			nextAs: Point ].	self assert: (reader value: '{"x":1,"y":2}') equals: 1@2. 	self assert: (reader value: '{}') equals: Point new! !!NeoJSONReaderTests methodsFor: 'testing'!testPoint3	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			nextAs: Point ].	self assert: (reader value: '{"x":1,"y":2}') equals: 1@2. 	self assert: (reader value: '{}') equals: Point new! !!NeoJSONReaderTests methodsFor: 'testing'!testPointUsingAsString	| point |	point := (NeoJSONReader on: '{"x":"1","y":"2"}' readStream)		for: Point			do: [ :mapping | 					(mapping 						mapProperty: #x 						getter: [ :object | object x ] 						setter: [ :object :value | object setX: value setY: object y ])						valueSchema: #AsString.					(mapping						mapProperty: #y						getter: [ :object | object y ]						setter: [ :object :value | object setX: object x setY: value ]) 						valueSchema: #AsString ];		for: #AsString			customDo: [ :mapping | 					mapping						encoder: [ :x | x asString ];						decoder: [ :x | x asNumber ] ];		nextAs: Point.	self assert: point equals: 1 @ 2! !!NeoJSONReaderTests methodsFor: 'testing'!testPropertyNamesAsSymbols	| json map |	json := '{ "x" : true, "y" : false, "key-1" : 1 }'.	map := (NeoJSONReader on: json readStream) 		propertyNamesAsSymbols: true; 		next.	self 		assert: map 		equals: (Dictionary new at: #x put: true; at: #y put: false; at: #'key-1' put: 1; yourself).	self assert: (map keys allSatisfy: [ :each | each isSymbol ])! !!NeoJSONReaderTests methodsFor: 'testing'!testSmallDictionary	| json map smallDictionaryClass |	json := '{ "x" : true, "y" : false, "key-1" : 1 }'.	smallDictionaryClass := Smalltalk at: #SmallDictionary ifAbsent: [ Dictionary ].	map := (NeoJSONReader on: json readStream) 		mapClass: smallDictionaryClass;		next.	self 		assert: map 		equals: (smallDictionaryClass new at: 'x' put: true; at: 'y' put: false; at: 'key-1' put: 1; yourself).	self 		assert: map class 		equals: smallDictionaryClass! !!NeoJSONReaderTests methodsFor: 'testing'!testStrings	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '"foo"') equals: 'foo'.	self assert: (reader value: '""') equals: ''.	self assert: (reader value: '"Foo BAR"') equals: 'Foo BAR'.	self assert: (reader value: '" foo "') equals: ' foo '.	self assert: (reader value: '"\u00E9l\u00E8ve en Fran\u00E7ais"') equals: 'élève en Français'.	self 		assert: (reader value: '"\"\\\/\t\r\n\f\b"') 		equals: (String withAll: ( OrderedCollection new 			add: $";			add: $\; 			add: $/;			add: Character tab;			add: Character cr;			add: Character lf;			add: Character newPage; 			add: Character backspace;			yourself )).	self should: [ reader value: '"open' ] raise: NeoJSONParseError.	self should: [ reader value: '"\uAA"' ] raise: NeoJSONParseError.	self should: [ reader value: '"\uZZ"' ] raise: NeoJSONParseError.	self should: [ reader value: '"\x"' ] raise: NeoJSONParseError.	self should: [ reader value: ' " ' ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing'!testSymbol	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: Symbol customDo: [ :mapping |				mapping decoder: [ :string | string asSymbol ] ];			nextAs: Symbol ].	self assert: (reader value: ' "foo" ') equals: #foo.	self assert: (reader value: ' "FOO-1" ') equals: #'FOO-1'! !!NeoJSONReaderTests methodsFor: 'testing'!testTime	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: Time customDo: [ :mapping |				mapping decoder: [ :string | Time fromString: string ] ];			nextAs: Time ].	self assert: (reader value: ' "14:30:08" ') equals: (Time hour: 14 minute: 30 second: 8)! !!NeoJSONWriteReadAsciiOnlyTests methodsFor: 'private'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) asciiOnly: true; nextPut: object ].	^ (NeoJSONReader on: json readStream) next ! !!NeoJSONWriteReadMockStreamTests methodsFor: 'private'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: (NeoJSONMockStream on: stream))			prettyPrint: true;			nextPut: object ].	^ (NeoJSONReader on: (NeoJSONMockStream on: json readStream)) next ! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing'!testDictionaryOfObject2	| data json reader |	data := Dictionary new.	data 		at: 'one' put: NeoJSONTestObject2 example1;		at: 'two' put: NeoJSONTestObject2 example1.	json := NeoJSONWriter toStringPretty: data.	reader := NeoJSONReader on: json readStream.	reader for: #DictionaryOfObject2 customDo: [ :mapping |		mapping mapWithValueSchema: NeoJSONTestObject2 ].  	self 		assert: (reader nextAs: #DictionaryOfObject2)		equals: data! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing'!testObject1	| json |	json := NeoJSONWriter toStringPretty: NeoJSONTestObject1 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject1)		equals: NeoJSONTestObject1 example1! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing'!testObject2	| json |	json := NeoJSONWriter toStringPretty: NeoJSONTestObject2 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject2)		equals: NeoJSONTestObject2 example1! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing'!testObject3	| json |	json := NeoJSONWriter toStringPretty: NeoJSONTestObject3 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject3)		equals: NeoJSONTestObject3 example1! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'private'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) 			prettyPrint: true;			nextPut: object ].	^ (NeoJSONReader on: json readStream) next ! !!NeoJSONWriteReadTests methodsFor: 'testing'!testDictionaryOfObject2	| data json reader |	data := Dictionary new.	data 		at: 'one' put: NeoJSONTestObject2 example1;		at: 'two' put: NeoJSONTestObject2 example1.	json := NeoJSONWriter toString: data.	reader := NeoJSONReader on: json readStream.	reader for: #DictionaryOfObject2 customDo: [ :mapping |		mapping mapWithValueSchema: NeoJSONTestObject2 ].  	self 		assert: (reader nextAs: #DictionaryOfObject2)		equals: data! !!NeoJSONWriteReadTests methodsFor: 'testing'!testFloats	| objects |	objects := OrderedCollection new add: Float pi; add: 1.0; add: -1.0; add: 0.0; add: 1.5e6; add: -1.5e6; add: 1.5e-6; add: -1.5e-6; yourself.	(self writeRead: objects) 		with: objects 		do: [ :first :second | self assert: (first closeTo: second) ]! !!NeoJSONWriteReadTests methodsFor: 'testing'!testIntegers	| objects |	objects := Array with: 1 with: -1 with: 0 with: 123467890 with: -1234567890.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing'!testLists	| objects |	objects := Array with: #(1 2 3) with: #() with: #( 'foo' 'bar').	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing'!testMaps	| objects |	objects := Array 		with: Dictionary new		with: (Dictionary with: 'x' -> 1)		with: (Dictionary newFromPairs: #( 'foo' true 'bar' false 'zero' 0 'null' nil 'string' 'Hello World!!' )).	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing'!testObject1	| json |	json := NeoJSONWriter toString: NeoJSONTestObject1 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject1)		equals: NeoJSONTestObject1 example1! !!NeoJSONWriteReadTests methodsFor: 'testing'!testObject2	| json |	json := NeoJSONWriter toString: NeoJSONTestObject2 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject2)		equals: NeoJSONTestObject2 example1! !!NeoJSONWriteReadTests methodsFor: 'testing'!testObject3	| json |	json := NeoJSONWriter toString: NeoJSONTestObject3 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject3)		equals: NeoJSONTestObject3 example1! !!NeoJSONWriteReadTests methodsFor: 'testing'!testSpecials	| objects |	objects := Array with: true with: false with: nil.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing'!testStrings	| objects |	objects := OrderedCollection new		add: 'foo'; add: 'Foo BAR'; add: ''; add: '	\\'''; 		add: 'élève en Français';		add: (Character codePoint: 12354) asString; "HIRAGANA LETTER A" 		yourself;		asArray.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'private'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) nextPut: object ].	^ (NeoJSONReader on: json readStream) next ! !!NeoJSONWriterTests methodsFor: 'testing'!testAsciiOnlyStrings	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				asciiOnly: true;				nextPut: object ] ].	self assert: (writer value: 'élève français') equals: '"\u00E9l\u00E8ve fran\u00E7ais"'.	self assert: (writer value: 'foo') equals: '"foo"'.	self assert: (writer value: 'Foo BAR') equals: '"Foo BAR"'.	self assert: (writer value: '') equals: '""'.	self		assert: (writer value: (String withAll: ( OrderedCollection new 			add: $";			add: $\; 			add: $/;			add: Character tab;			add: Character cr;			add: Character lf;			add: Character newPage; 			add: Character backspace;			yourself )))		equals: '"\"\\/\t\r\n\f\b"'! !!NeoJSONWriterTests methodsFor: 'testing'!testAssociation	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Association do: [ :mapping |					mapping mapAccessors: #(key value) ]; 				nextPut: object ] ].	self assert: (writer value: 'foo' -> 42) equals: '{"key":"foo","value":42}'.	self assert: (writer value: Association new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing'!testBooleans	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: true) equals: 'true'.	self assert: (writer value: false) equals: 'false'.! !!NeoJSONWriterTests methodsFor: 'testing'!testByteArray	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: #[1 2 3]) equals: '[1,2,3]'.	self assert: (writer value: #[]) equals: '[]'! !!NeoJSONWriterTests methodsFor: 'testing'!testDate	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Date customDo: [ :mapping |					mapping encoder: [ :date | date yyyymmdd ] ];				nextPut: object ] ].	self assert: (writer value: (Date fromString: '2012-06-08')) equals: '"2012-06-08"'! !!NeoJSONWriterTests methodsFor: 'testing'!testDateAndTime 	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: DateAndTime customDo: [ :mapping |					mapping encoder: [ :dateAndTime | dateAndTime printString ] ];				nextPut: object ] ].	self 		assert: (writer value: (DateAndTime year: 2012 month: 2 day: 14 hour: 16 minute: 40 second: 18 offset: 1 hour)) 		equals: '"2012-02-14T16:40:18+01:00"'! !!NeoJSONWriterTests methodsFor: 'testing'!testFloatPrinter	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				floatPrinter: NeoJSONFloatPrinter new;				nextPut: object ] ].	self assert: (writer value: 123.0) equals: '123'.	self assert: (writer value: -123.0) equals: '-123'.	self assert: (writer value: 0.0) equals: '0'.	self assert: (writer value: 1.50) equals: '1.5'.	self assert: (writer value: -1.25) equals: '-1.25'.	self assert: (writer value: Float pi) equals: '3.14159'.	self assert: (writer value: 9.10938356e-31) equals: '9.10938e-31'.	self assert: (writer value: 5.9724e24) equals: '5.9724e24'.	self assert: (writer value: 1234567890.1234567890) equals: '1.23457e9'.	self assert: (writer value: (1/3) asFloat) equals: '0.33333'.! !!NeoJSONWriterTests methodsFor: 'testing'!testFloats	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: 123.0) equals: '123.0'.	self assert: (writer value: -123.0) equals: '-123.0'.	self assert: (writer value: 0.0) equals: '0.0'.! !!NeoJSONWriterTests methodsFor: 'testing'!testIntegers	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: 123) equals: '123'.	self assert: (writer value: -123) equals: '-123'.	self assert: (writer value: 0) equals: '0'.! !!NeoJSONWriterTests methodsFor: 'testing'!testLists	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: #(1 2 3)) equals: '[1,2,3]'.	self assert: (writer value: #()) equals: '[]'.! !!NeoJSONWriterTests methodsFor: 'testing'!testListsExtra	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	#( OrderedCollection LinkedList ByteArray IntegerArray SortedCollection ) do: [ :each |		Smalltalk at: each ifPresent: [ :collectionClass |			self assert: (writer value: (collectionClass withAll: #(1 2 3))) equals: '[1,2,3]'.			self assert: (writer value: collectionClass new) equals: '[]' ] ]! !!NeoJSONWriterTests methodsFor: 'testing'!testMapKeysMustBeStrings	self should: [ NeoJSONWriter toString: { 1->#a } asDictionary ] raise: Error.	self should: [ NeoJSONWriter toString: { true->#a } asDictionary ] raise: Error.	self should: [ NeoJSONWriter toString: { nil->#a } asDictionary ] raise: Error.	self should: [ NeoJSONWriter toString: { #()->#a } asDictionary ] raise: Error.	self should: [ NeoJSONWriter toString: { Dictionary new->#a } asDictionary ] raise: Error.	self should: [ NeoJSONWriter toString: { Float pi->#a } asDictionary ] raise: Error.! !!NeoJSONWriterTests methodsFor: 'testing'!testMaps	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: ((writer value: (Dictionary newFromPairs: #( 'x' 1 'y' 2))) includesSubstring: '"x":1').	self assert: ((writer value: (Dictionary newFromPairs: #( 'x' 1 'y' 2))) includesSubstring: '"y":2').	self assert: (writer value: Dictionary new) equals: '{}'.! !!NeoJSONWriterTests methodsFor: 'testing'!testMapsExtra	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: (IdentityDictionary newFromPairs: #( 'x' 1))) equals: '{"x":1}'.	self assert: (writer value: IdentityDictionary new) equals: '{}'.	#( SmallDictionary OrderedDictionary OrderedIdentityDictionary ) do: [ :each |		| dictionaryClass |		dictionaryClass := Smalltalk at: each ifAbsent: [ nil ].		dictionaryClass ifNotNil: [				self assert: (writer value: (dictionaryClass new at: 'x' put: 1; at: 'y' put: 2; yourself)) equals: '{"x":1,"y":2}'.			self assert: (writer value: dictionaryClass new) equals: '{}'] ]! !!NeoJSONWriterTests methodsFor: 'testing'!testNextPutStringAsHex	| output |	output := String		streamContents: [ :out | 			(NeoJSONWriter on: out)				for: #StringAsHex					customDo: [ :mapping | 							mapping								encoder: [ :x | x asByteArray hex asUppercase ];								decoder: [ :x | (ByteArray readHexFrom: x) asString ] ];				nextPut: 'Foo bar!!' as: #StringAsHex ].	self assert: output equals: '"466F6F2062617221"'! !!NeoJSONWriterTests methodsFor: 'testing'!testNonBMPCharacterEncoding	"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"	| string json |	string := 16r1D11E asCharacter asString. "MUSICAL SYMBOL G CLEF"	json := String streamContents: [ :out |		(NeoJSONWriter on: out) asciiOnly: true; nextPut: string ].	self assert: json equals: '"\uD834\uDD1E"'! !!NeoJSONWriterTests methodsFor: 'testing'!testNull	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: nil) equals: 'null'! !!NeoJSONWriterTests methodsFor: 'testing'!testPoint	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self should: [ writer value: 1@2 ] raise: NeoJSONMappingNotFound! !!NeoJSONWriterTests methodsFor: 'testing'!testPoint1	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Point do: [ :mapping |					mapping mapProperty: 'x' getter: [ :point | point x ] setter: [ :point :value | point x: value ].					mapping mapProperty: 'y' getter: [ :point | point y ] setter: [ :point :value | point y: value ]. ];				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing'!testPoint2	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				mapAllInstVarsFor: Point;				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing'!testPoint3	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Point do: [ :mapping |					mapping mapInstVars: #(x y) ];				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing'!testPointUsingAsString	| output |	output := String		streamContents: [ :out | 			(NeoJSONWriter on: out)				for: Point					do: [ :mapping | 							(mapping 								mapProperty: #x 								getter: [ :object | object x ] 								setter: [ :object :value | object setX: value setY: object y ])								valueSchema: #AsString.							(mapping								mapProperty: #y								getter: [ :object | object y ]								setter: [ :object :value | object setX: object x setY: value ]) 								valueSchema: #AsString ];				for: #AsString					customDo: [ :mapping | 							mapping								encoder: [ :x | x asString ];								decoder: [ :x | x asNumber ] ];				nextPut: 1 @ 2 ].	self assert: output equals: '{"x":"1","y":"2"}'! !!NeoJSONWriterTests methodsFor: 'testing'!testPointWriteNil	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				writeNil: true;				mapAllInstVarsFor: Point;				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{"x":null,"y":null}'! !!NeoJSONWriterTests methodsFor: 'testing'!testPreservePropertyOrder	| writer testObject |	(testObject := NeoJSONTestObject2 new)		id: 123;		width: 100;		height: 50;		data: 'test'.	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: NeoJSONTestObject2 do: [ :mapping | mapping mapInstVars: #(id width height data) ];				nextPut: object ] ].	self assert: (writer value: testObject) equals: '{"id":123,"width":100,"height":50,"data":"test"}'.	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: NeoJSONTestObject2 do: [ :mapping | mapping mapInstVars: #(width height data id) ];				nextPut: object ] ].	self assert: (writer value: testObject) equals: '{"width":100,"height":50,"data":"test","id":123}'.	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: NeoJSONTestObject2 do: [ :mapping | mapping mapInstVars: #(data id height width) ];				nextPut: object ] ].	self assert: (writer value: testObject) equals: '{"data":"test","id":123,"height":50,"width":100}'.! !!NeoJSONWriterTests methodsFor: 'testing'!testStrings	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: 'foo') equals: '"foo"'.	self assert: (writer value: 'Foo BAR') equals: '"Foo BAR"'.	self assert: (writer value: '') equals: '""'.	self		assert: (writer value: (String withAll: ( OrderedCollection new 			add: $";			add: $\; 			add: $/;			add: Character tab;			add: Character cr;			add: Character lf;			add: Character newPage; 			add: Character backspace;			yourself )))		equals: '"\"\\/\t\r\n\f\b"'! !!NeoJSONWriterTests methodsFor: 'testing'!testSymbol	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: #foo) equals: '"foo"'.	self assert: (writer value: #'FOO-1') equals: '"FOO-1"'! !!NeoJSONWriterTests methodsFor: 'testing'!testTime	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Time customDo: [ :mapping |					mapping encoder: [ :time | time printString ] ];				nextPut: object ] ].	self assert: ((writer value: (Time fromSeconds: 52208)) includesSubstring: '2:30:08')! !!NeoJSONBenchmark methodsFor: 'initialize-release'!initialize	super initialize.	objects := Array new: 1000.	1 to: 1000 do: [ :each |		| map |		(map := Dictionary new)			at: 'id' put: each;			at: 'name' put: 'Name-', each asString;			at: 'enabled' put: (#( true false) at: (each \\ 2) + 1);			at: 'color' put: (#( 'red' 'green' 'blue' ) at: (each \\ 3) + 1);			at: 'value' put: each + each / 1000.0.		objects at: each put: map ].	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) nextPut: objects ]		! !!NeoJSONBenchmark methodsFor: 'public'!read	^ (NeoJSONReader on: json readStream) next! !!NeoJSONBenchmark methodsFor: 'public'!write	^ String streamContents: [ :stream |		(NeoJSONWriter on: stream) nextPut: objects ]! !!NeoJSONBenchmark methodsFor: 'public'!writePrettyPrintedRead	| output |	output := String streamContents: [ :stream |		(NeoJSONWriter on: stream) 			prettyPrint: true;			nextPut: objects ].	^ (NeoJSONReader on: output readStream) 		next! !!NeoJSONMockStream class methodsFor: 'instance creation'!on: stream	^ self new		stream: stream;		yourself! !!NeoJSONMockStream methodsFor: 'testing'!atEnd	^ stream atEnd! !!NeoJSONMockStream methodsFor: 'accessing'!close	^ stream close! !!NeoJSONMockStream methodsFor: 'accessing'!collectionSpecies	^ stream collectionSpecies! !!NeoJSONMockStream methodsFor: 'accessing'!next	^ stream next! !!NeoJSONMockStream methodsFor: 'accessing'!nextPut: character	^ stream nextPut: character! !!NeoJSONMockStream methodsFor: 'accessing'!nextPutAll: string	^ stream nextPutAll: string! !!NeoJSONMockStream methodsFor: 'accessing'!peek	^ stream peek! !!NeoJSONMockStream methodsFor: 'accessing'!peekFor: char	^ stream peekFor: char! !!NeoJSONMockStream methodsFor: 'accessing'!space	^ stream space! !!NeoJSONMockStream methodsFor: 'initialize-release'!stream: anObject	stream := anObject! !!NeoJSONTestObject1 class methodsFor: 'instance creation'!example1	^ self new		id: 123;		name: 'Example1';		timestamp: (DateAndTime year: 2012 month: 06 day: 08 hour: 14 minute: 30 second: 15 offset: 1 hour);		points: (Array with: 1@2 with: 3@4);		bytes: #[ 2 4 6 8 ];		yourself! !!NeoJSONTestObject1 class methodsFor: 'accessing'!neoJsonMapping: mapper	mapper for: self do: [ :mapping |		mapping mapInstVars: #(id name).		(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.		(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.		(mapping mapInstVar: #bytes) valueSchema: ByteArray ].	mapper for: DateAndTime customDo: [ :mapping |		mapping decoder: [ :string | DateAndTime fromString: string ].		mapping encoder: [ :dateAndTime | dateAndTime printString ] ].	mapper for: #ArrayOfPoints customDo: [ :mapping |		mapping listOfElementSchema: Point ].  	mapper mapAllInstVarsFor: Point.	mapper for: ByteArray customDo: [ :mapping |		mapping listOfType: ByteArray ]! !!NeoJSONTestObject1 methodsFor: 'comparing'!= anObject	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ id = anObject id		and: [			name = anObject name				and: [					timestamp = anObject timestamp						and: [							points = anObject points								and: [ bytes = anObject bytes ] ] ] ]! !!NeoJSONTestObject1 methodsFor: 'accessing'!bytes	^ bytes! !!NeoJSONTestObject1 methodsFor: 'accessing'!bytes: byteArray	bytes := byteArray! !!NeoJSONTestObject1 methodsFor: 'comparing'!hash	^ id hash bitXor: (name hash bitXor: (timestamp hash bitXor: (points hash bitXor: bytes hash)))! !!NeoJSONTestObject1 methodsFor: 'accessing'!id	^ id! !!NeoJSONTestObject1 methodsFor: 'accessing'!id: integer	id := integer! !!NeoJSONTestObject1 methodsFor: 'accessing'!name	^ name! !!NeoJSONTestObject1 methodsFor: 'accessing'!name: string	name := string! !!NeoJSONTestObject1 methodsFor: 'accessing'!points	^ points! !!NeoJSONTestObject1 methodsFor: 'accessing'!points: arrayOfPoints	points := arrayOfPoints ! !!NeoJSONTestObject1 methodsFor: 'accessing'!timestamp	^ timestamp! !!NeoJSONTestObject1 methodsFor: 'accessing'!timestamp: dateAndTime 	timestamp := dateAndTime ! !!NeoJSONTestObject2 class methodsFor: 'testing'!benchmark10k	"self benchmark10k"		self benchmark: 10000! !!NeoJSONTestObject2 class methodsFor: 'testing'!benchmark10kAsDictionary	"self benchmark10kAsDictionary"		self benchmarkAsDictionary: 10000! !!NeoJSONTestObject2 class methodsFor: 'testing'!benchmark200k	"self benchmark200k"		self benchmark: 200000! !!NeoJSONTestObject2 class methodsFor: 'testing'!benchmark: count	"self benchmark: 1000"		| collection json size |	collection := Array new: count withAll: self example1.	size := 2 + (count * (NeoJSONWriter toString: self example1) size) + count - 1.	Transcript 		cr;		<< ('Serializing {1} objects took ms ' format: (Array with: count) );		show: [ json := String new: size streamContents: [ :stream |								(NeoJSONWriter on: stream) nextPut: collection ] ] timeToRun.	Transcript 		cr;		<< ('Deserializing {1} objects took ms ' format: (Array with: count) );		show: [ NeoJSONReader fromString: json ] timeToRun.! !!NeoJSONTestObject2 class methodsFor: 'testing'!benchmarkAsDictionary: count	"self benchmarkAsDictionary: 1000"		| collection json size |	collection := Array new: count withAll: self example1 asDictionary.	size := 2 + (count * (NeoJSONWriter toString: self example1 asDictionary) size) + count - 1.	Transcript 		cr;		<< ('Serializing {1} objects took ms ' format: (Array with: count) );		show: [ json := String new: size streamContents: [ :stream |								(NeoJSONWriter on: stream) nextPut: collection ] ] timeToRun.	Transcript 		cr;		<< ('Deserializing {1} objects took ms ' format: (Array with: count) );		show: [ NeoJSONReader fromString: json ] timeToRun.! !!NeoJSONTestObject2 class methodsFor: 'instance creation'!example1	^ self new		id: 13;		width: 250;		height: 110;		data: (String new: 512 withAll: $a);		yourself! !!NeoJSONTestObject2 class methodsFor: 'accessing'!neoJsonMapping: mapper	"For inheritance mapping to work, the schema/classname must be self,	but the instance variables have to be enumerated manually per class"	mapper for: self do: [ :mapping |		mapping mapInstVars: #(id width height data) ] ! !!NeoJSONTestObject2 methodsFor: 'comparing'!= anObject	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ id = anObject id		and: [			height = anObject height				and: [					width = anObject width						and: [							data = anObject data ] ] ]! !!NeoJSONTestObject2 methodsFor: 'converting'!asDictionary	^ Dictionary new		at: #id put: id;		at: #height put: height;		at: #width put: width;		at: #data put: data;		yourself! !!NeoJSONTestObject2 methodsFor: 'accessing'!data	^ data! !!NeoJSONTestObject2 methodsFor: 'accessing'!data: anObject	data := anObject! !!NeoJSONTestObject2 methodsFor: 'comparing'!hash	^ id hash bitXor: (width hash bitXor: (height hash bitXor: data hash))! !!NeoJSONTestObject2 methodsFor: 'accessing'!height	^ height! !!NeoJSONTestObject2 methodsFor: 'accessing'!height: anObject	height := anObject! !!NeoJSONTestObject2 methodsFor: 'accessing'!id	^ id! !!NeoJSONTestObject2 methodsFor: 'accessing'!id: anObject	id := anObject! !!NeoJSONTestObject2 methodsFor: 'accessing'!width	^ width! !!NeoJSONTestObject2 methodsFor: 'accessing'!width: anObject	width := anObject! !!NeoJSONTestObject3 class methodsFor: 'instance creation'!example1	^ super example1		data: (String new: 8 withAll: $a);		color: 'red';		transparent: true;		yourself! !!NeoJSONTestObject3 class methodsFor: 'accessing'!neoJsonMapping: mapper	"For inheritance mapping to work, the schema/classname must be self,	but the instance variables have to be enumerated manually per class"		super neoJsonMapping: mapper.	mapper for: self do: [ :mapping |		mapping mapInstVars: #(color transparent) ]! !!NeoJSONTestObject3 methodsFor: 'comparing'!= anObject	^ super = anObject 		and: [ color = anObject color			and: [ transparent = anObject transparent ] ]! !!NeoJSONTestObject3 methodsFor: 'converting'!asDictionary	^ super asDictionary		at: #color put: color;		at: #transparent put: transparent;		yourself! !!NeoJSONTestObject3 methodsFor: 'accessing'!color	^ color! !!NeoJSONTestObject3 methodsFor: 'accessing'!color: anObject	color := anObject! !!NeoJSONTestObject3 methodsFor: 'accessing'!transparent	^ transparent! !!NeoJSONTestObject3 methodsFor: 'accessing'!transparent: anObject	transparent := anObject! !!NeoJSONValidation methodsFor: 'private'!closeLog	logStream ifNotNil: [ 		logStream close.		logStream := nil ].	^ self logFile exists		ifTrue: [ self logFile contents ] 		ifFalse: [ 'log file is empty' ]! !!NeoJSONValidation methodsFor: 'private'!ensureLog	logStream ifNil: [ 		logStream := self logFile ensureDelete; writeStream. 		logStream setToEnd ]	! !!NeoJSONValidation methodsFor: 'accessing'!gitDirectory	^ gitDirectory ifNil: [ gitDirectory := FileLocator home / #Develop / #git ]! !!NeoJSONValidation methodsFor: 'accessing'!gitDirectory: fileReference	gitDirectory := fileReference! !!NeoJSONValidation methodsFor: 'accessing'!jsonTestSuiteDirectory	^ self gitDirectory / #JSONTestSuite! !!NeoJSONValidation methodsFor: 'accessing'!jsonTestSuiteTestParsingDirectory	^ self jsonTestSuiteDirectory / 'test_parsing'! !!NeoJSONValidation methodsFor: 'accessing'!jsonTestSuiteTestParsingFailFiles	^ self jsonTestSuiteTestParsingDirectory childrenMatching: 'n_*.json'! !!NeoJSONValidation methodsFor: 'accessing'!jsonTestSuiteTestParsingInfoFiles	^ self jsonTestSuiteTestParsingDirectory childrenMatching: 'i_*.json'! !!NeoJSONValidation methodsFor: 'accessing'!jsonTestSuiteTestParsingPassFiles	^ self jsonTestSuiteTestParsingDirectory childrenMatching: 'y_*.json'! !!NeoJSONValidation methodsFor: 'accessing'!jsonTestSuiteTestTransformDirectory	^ self jsonTestSuiteDirectory / 'test_transform'! !!NeoJSONValidation methodsFor: 'private'!log: message	self ensureLog.	logStream nextPutAll: message; lf; flush! !!NeoJSONValidation methodsFor: 'private'!logFile	^ 'neo-json-validation.log' asFileReference! !!NeoJSONValidation methodsFor: 'accessing'!nativeJsonBenchmarkDataDirectory	^ self nativeJsonBenchmarkDirectory / #data! !!NeoJSONValidation methodsFor: 'accessing'!nativeJsonBenchmarkDirectory	^ self gitDirectory / 'nativejson-benchmark'! !!NeoJSONValidation methodsFor: 'accessing'!nativeJsonBenchmarkJsonCheckerDirectory	^ self nativeJsonBenchmarkDataDirectory / #jsonchecker! !!NeoJSONValidation methodsFor: 'accessing'!nativeJsonBenchmarkJsonCheckerFailFiles	^ self nativeJsonBenchmarkJsonCheckerDirectory childrenMatching: 'fail*.json'! !!NeoJSONValidation methodsFor: 'accessing'!nativeJsonBenchmarkJsonCheckerPassFiles	^ self nativeJsonBenchmarkJsonCheckerDirectory childrenMatching: 'pass*.json'! !!NeoJSONValidation methodsFor: 'accessing'!nativeJsonBenchmarkRoundTripDirectory	^ self nativeJsonBenchmarkDataDirectory / #roundtrip! !!NeoJSONValidation methodsFor: 'accessing'!nativeJsonBenchmarkRoundTripFiles	^ self nativeJsonBenchmarkRoundTripDirectory children! !!NeoJSONValidation methodsFor: 'running'!runJsonTestSuiteTestParsingFailures	^ self		validateFiles: self jsonTestSuiteTestParsingFailFiles 		usingTest: [ :file | 			| data success |			success := false.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next; failIfNotAtEnd ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := true ].			success ]! !!NeoJSONValidation methodsFor: 'running'!runJsonTestSuiteTestParsingInfo	^ self		validateFiles: self jsonTestSuiteTestParsingInfoFiles 		usingTest: [ :file | 			| data success |			success := true.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := false ].			success ]! !!NeoJSONValidation methodsFor: 'running'!runJsonTestSuiteTestParsingPasses	^ self		validateFiles: self jsonTestSuiteTestParsingPassFiles 		usingTest: [ :file | 			| data success |			success := true.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := false ].			success ]! !!NeoJSONValidation methodsFor: 'running'!runNativeJsonBenchmarkJsonCheckerFailures	^ self		validateFiles: self nativeJsonBenchmarkJsonCheckerFailFiles		usingTest: [ :file | 			| data success |			success := false.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next; failIfNotAtEnd ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := true ].			success ]! !!NeoJSONValidation methodsFor: 'running'!runNativeJsonBenchmarkJsonCheckerPasses	^ self		validateFiles: self nativeJsonBenchmarkJsonCheckerPassFiles		usingTest: [ :file | 			| data success |			success := true.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := false ].			success ]! !!NeoJSONValidation methodsFor: 'running'!runNativeJsonBenchmarkRoundTrip	^ self 		validateFiles: self nativeJsonBenchmarkRoundTripFiles		usingTest: [ :file |			| data json |			data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ].			json := NeoJSONWriter toString: data.			json = file contents ]! !!NeoJSONValidation methodsFor: 'private'!validateFiles: files usingTest: block	| total succeeded failed |	total := succeeded := failed := 0.	files do: [ :file | 		| success |		self log: 'Running ' , file pathString.		self log: ([ file contents contractTo: 64 ] on: Error do: [ :exception | exception printString ]).		success := [ block value: file ]			on: Error			do: [ :exception | self log: '  Errored. ' , exception printString. false ].		total := total + 1.		success			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed := failed + 1 ].		self log: (success ifTrue: [ '  Succeeded' ] ifFalse: [ '  Failed' ]); log: '' ].	self log: ('{1} total = {2} succeeded + {3} failed' format: (Array with: total with: succeeded with: failed) ).	^ self closeLog! !"Neo-JSON-Tests"!!ZdcUtils commentStamp: 'Anonymous 6/16/2024 18:13' prior: 0!I am ZdcUtils.!!ZdcAbstractSocketStream methodsFor: 'stream in' stamp: 'CompatibleUserName 6/16/2024 11:15:59' prior: 90061328!skip: count	"Skip over count bytes.	This is an inefficient abstract implementation skipping bytes one by one."	count < 0 ifTrue: [ self error: 'cannot skip backwards' ].	count timesRepeat: [ self next ]! !!ZdcAbstractSocketStream methodsFor: 'private - socket' stamp: 'CompatibleUserName 6/16/2024 11:15:59' prior: 90065964!socketWaitForSendDone	"Compatibility shim for Pharo <11, where #waitForSendDone: returns a boolean	indicating success, rather than signaling exceptions on failure.	A true return (in P11) or nothing/self (in P12) both indicate success,	so check for specifically false."	(socket waitForSendDoneFor: self timeout) == false ifTrue: [		ConnectionTimedOut signal: 'Data send timed out.' ]! !!ZdcPluginSSLSession methodsFor: 'initialization' stamp: 'CompatibleUserName 6/16/2024 11:15:59' prior: 90109619!initialize	"Initialize the receiver"	[ handle := self primitiveSSLCreate ]		on: (ZdcUtils exceptionSet: #( #SocketError #PrimitiveFailed ))		do: [ :exception |			"Give a more human friendly error message"			ZdcPluginMissing signal ].	self logging: false! !!ZdcSimpleSocketStream methodsFor: 'private - out' stamp: 'CompatibleUserName 6/16/2024 11:15:59' prior: 90135497!flushBytes: bytes startingAt: offset count: count	"Ask the socket to write count bytes starting from offset. Wait. Fail if not successful"	| writeCount |	self isConnected ifFalse: [ ConnectionClosed signal: 'Cannot write data' ].	writeCount := 0.	[ | written |		written := self socketSendData: bytes startingAt: offset + writeCount count: count - writeCount.		(writeCount := writeCount + written) = count ] whileFalse: [		self socketWaitForSendDone ]! !!ZdcUtils class methodsFor: 'converting' stamp: 'CompatibleUserName 6/16/2024 11:15:59'!exceptionSet: classNames	^ classNames inject: ExceptionSet new into: [ :set :each |		  (Smalltalk globals includesKey: each)			  ifTrue: [				  set					  add: (Smalltalk at: each);					  yourself ]			  ifFalse: [ set ] ]! !!ZdcOptimizedSocketStream methodsFor: 'stream out' stamp: 'CompatibleUserName 6/16/2024 11:15:59' prior: 90101819!next: count putAll: collection startingAt: offset	"Write count bytes from collection starting at offset. Overwritten, optimized"	| totalWritten |	writeBuffer isFull ifTrue: [ self flushWriteBuffer ].	totalWritten := 0.	[ | toWrite |		toWrite := (count - totalWritten) min: writeBuffer availableForWriting.		writeBuffer next: toWrite putAll: collection startingAt: offset + totalWritten.		totalWritten := totalWritten + toWrite.		totalWritten = count ] whileFalse: [ self flushWriteBuffer ]! !!ZdcOptimizedSocketStream methodsFor: 'stream in' stamp: 'CompatibleUserName 6/16/2024 11:15:59' prior: 90101404!skip: count	"Skip over count bytes. Overwritten, optimized"	| skipCount |	count < 0 ifTrue: [ self error: 'cannot skip backwards' ].	skipCount := 0.	[ | leftToSkip skipping |		leftToSkip := count - skipCount.		skipping := readBuffer availableForReading min: leftToSkip.		readBuffer advanceReadPointer: skipping.	     (skipCount := skipCount + skipping) = count ] whileFalse: [ self fillReadBuffer ]! !"Zodiac-Core"!!ZdcPluginSSLSessionTest methodsFor: 'tests' stamp: 'CompatibleUserName 6/16/2024 11:15:59' prior: 90113679!testServerName	[ session serverName; serverName: nil ] 		on: (ZdcUtils exceptionSet: #( #SocketError #PrimitiveFailed )) 		do: [ ^ self skip ].	self assert: session serverName equals: nil.	session serverName: 'pharo.org'.	self assert: session serverName equals: 'pharo.org'.	session serverName: 'smalltalkhub.com'.	self assert: session serverName equals: 'smalltalkhub.com'.	session serverName: nil.	self assert: session serverName equals: nil! !"Zodiac-Tests"!!ZnLossyUTF8Encoder commentStamp: '<historical>' prior: 0!I am ZnLossyUTF8Decoder.I am a ZnUTF8Decoder.I behave like my superclass but will not signal errors when I see illegal UTF-8 encoded input,instead I will output a Unicode Replacement Character (U+FFFD) for each error.In contrast to my superclass I can read any random byte sequence, decoding both legal and illegal UTF-8 sequences. Due to my stream based design and usage as well as my stateless implementation,  I will output multiple replacement characters when multiple illegal sequences occur.  My convenience method #decodeBytesSingleReplacement: shows how to decode bytes so that  only a single replacement character stands for any amount of illegal encoding between legal encodings. Part of Zinc HTTP Components.!!ZnBufferedReadWriteStream methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnBufferedReadWriteStream methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90314101!skip: anInteger	anInteger < 0 ifTrue: [ self error: 'cannot skip backwards' ].	self readingActionDo: [		readStream skip: anInteger ]! !!ZnBase64Encoder methodsFor: 'private' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90276129!isLegalCharacter: character	"Return true when character is part of my alphabet"	| code |	^ (code := character asciiValue) < 128			and: [ (inverse at: code + 1) isNotNil ]! !!Stream methodsFor: '*Zinc-Character-Encoding-Core' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Since this the base stream, answer ourself."	^ self! !!Stream methodsFor: '*Zinc-Character-Encoding-Core' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!wrappedStream	"Answer the stream that the receiver wraps.	Since this the base stream, answer nil"	^ nil! !!SocketStream methodsFor: '*Zinc-Character-Encoding-Core' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Since this the base stream, answer ourself."	^ self! !!SocketStream methodsFor: '*Zinc-Character-Encoding-Core' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!wrappedStream	"Answer the stream that the receiver wraps.	Since this the base stream, answer nil"	^ nil! !!ZnPositionableReadStream methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnEncodedReadStream class methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!isAbstract	^ self == ZnEncodedReadStream! !!ZnEncodedReadStream methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!collectionSpecies	^ self subclassResponsibility! !!ZnEncodedReadStream methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90594423!skip: count	count < 0 ifTrue: [ self error: 'cannot skip backwards' ].	count timesRepeat: [ self next ]! !!ZnUTF16Encoder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!byteOrderMarkLE	"My little endian sequence of the Unicode BOM. See #byteOrderMark"		^ 16rFFFE! !!ZnUTF16Encoder methodsFor: 'encoding - decoding' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91017258!nextCodePointFromStream: stream	"Read and return the next integer code point from stream"	| word leadSurrogate trailSurrogate code |	word := self read16BitWordFromStream: stream.	((self processByteOrderMark: word) and: [ self ignoreByteOrderMark ])		ifTrue: [ word := self read16BitWordFromStream: stream ].	^ (word < 16rD800 or: [ word > 16rDBFF ])		ifTrue: [			word ]		ifFalse: [			leadSurrogate := word.			trailSurrogate := self read16BitWordFromStream: stream.			code := (leadSurrogate - 16rD800) * 16r400 + (trailSurrogate - 16rDC00).			16r10000 + code ]! !!ZnUTF16Encoder methodsFor: 'private' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91018755!processByteOrderMark: word	^ (word = self byteOrderMark or: [ word = self byteOrderMarkLE ])		ifTrue: [			word = self byteOrderMarkLE 				ifTrue: [ self swapEndianness ].			true ]		ifFalse: [ false ]! !!ZnBufferedWriteStream methodsFor: 'initialize-release' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnBufferedWriteStream methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!reset	self flushBuffer.	stream reset! !!ZnBufferedWriteStream methodsFor: 'initialize-release' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!wrappedStream	^ stream! !!ZnCharacterEncoder class methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!isAbstract	^ self == ZnCharacterEncoder! !!ZnCharacterEncoder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!endianness	^ #'N/A'! !!ZnCharacterEncoder methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!isStrict	^ false! !!ZnEndianSensitiveUTFEncoder class methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!isAbstract	^ self = ZnEndianSensitiveUTFEncoder! !!ZnEndianSensitiveUTFEncoder class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90601893!newForEncoding: string	"Return a new character encoder object for an encoding described by string.	Try to infer endianness from string, defaulting to big endian."	| encoder |	encoder := self new.	encoder identifier: string.	(string asLowercase endsWith: 'be') ifTrue: [ encoder beBigEndian ].	(string asLowercase endsWith: 'le') ifTrue: [ encoder beLittleEndian ].	^ encoder! !!ZnEndianSensitiveUTFEncoder methodsFor: 'comparing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90601069!= anObject	^ super = anObject and: [ self identifier == anObject identifier ]! !!ZnEndianSensitiveUTFEncoder methodsFor: 'comparing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90600750!hash	^ self identifier hash! !!ZnEndianSensitiveUTFEncoder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!identifier	^ identifier! !!ZnEndianSensitiveUTFEncoder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!identifier: anObject	identifier := anObject! !!ZnEndianSensitiveUTFEncoder methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90600865!printOn: stream	super printOn: stream.	stream nextPut: $(.	stream print: self identifier asString; space.	stream nextPutAll: endianness; nextPutAll: ' endian'.	stream nextPut: $)! !!ZnUTFEncoder class methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!isAbstract	^ self = ZnUTFEncoder ! !!ZnUTFEncoder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91037584!byteOrderMark	"The code point of the Unicode Byte-Order-Mark or BOM character.	This is the big endian sequence.	See https://en.wikipedia.org/wiki/Byte_order_mark"	^ 16rFEFF! !!ZnUTFEncoder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!ignoreByteOrderMark	"Return true when I ignore Unicode byte-order mark (BOM) occurences that I read (the default)."		^ ignoreByteOrderMark ifNil: [ ignoreByteOrderMark := true ]! !!ZnUTFEncoder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!ignoreByteOrderMark: boolean	"When boolean is true I ignore Unicode byte-order mark (BOM) occurences that I read (the default)."	ignoreByteOrderMark := boolean! !!ZnEncodedWriteStream class methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!isAbstract	^ self == ZnEncodedWriteStream! !!ZnBufferedReadStream methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90308049!back	"Move backwards one element and return it"	^ position > limit		ifTrue: [			stream back ]		ifFalse: [ | targetPosition bufferPosition char |			position = 1 ifTrue:				[ stream position = 0 ifTrue:					[ self error: 'Cannot move back from beginning' ]				ifFalse:					[ targetPosition := self position - 1.					"Assume that the caller may want to go back a few elements before reading forward again"					bufferPosition := targetPosition - 10 max: 0.					self position: bufferPosition.					self nextBuffer.					self position: targetPosition.					self peek ] ]			ifFalse:				[ char := buffer at: position.				position := position - 1.				char ] ]! !!ZnBufferedReadStream methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnBufferedReadStream methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90303786!readInto: collection startingAt: offset count: requestedCount	"Read requestedCount elements into collection starting at offset,	answering the number of elements read, there could be fewer elements available."	| countRead countYetToRead |	"First, read from elements already in my buffer."	countRead := self readFromBufferInto: collection startingAt: offset count: requestedCount.	countYetToRead := requestedCount - countRead.	countYetToRead > 0		ifTrue: [ "See if there are more elements to be read from the underlying stream"			| newOffset |			newOffset := offset + countRead.			(self shouldBufferReadOfCount: countYetToRead)				ifTrue: [					self nextBuffer.					limit > 0						ifTrue: [ countRead := countRead + (self readInto: collection startingAt: newOffset count: countYetToRead) ] ]				ifFalse: [					self discardBuffer.					countRead := countRead + (stream readInto: collection startingAt: newOffset count: countYetToRead) ] ].	^ countRead! !!ZnBufferedReadStream methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90299967!skip: count	"Skip over count elements.	This could be further optimzed."	count < 0 ifTrue: [ self error: 'cannot skip backwards' ].	count timesRepeat: [ self next ]! !!ZnNullEncoder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90811406!identifier	^ #null! !!ZnEncodedStream class methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!isAbstract	^ self == ZnEncodedStream! !!ZnEncodedStream methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!isBinary	^ false! !!ZnEncodedStream methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnEncodedStream methodsFor: 'initialization' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!reset	^ stream reset! !!ZnNewLineWriterStream methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnNewLineWriterStream methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!wrappedStream	^ stream! !!ZnLossyUTF8Encoder class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!handlesEncoding: string	"Return true when my instances handle the encoding described by string"	^ (self canonicalEncodingIdentifier: string) = 'utf8lossy'! !!ZnLossyUTF8Encoder class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!knownEncodingIdentifiers	^ #( utf8lossy )! !!ZnLossyUTF8Encoder methodsFor: 'convenience' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!decodeBytesSingleReplacement: bytes	"Decode bytes and return the resulting string.	This variant of #decodeBytes: will only ever use 	a single replacement character for each illegal UTF-8 sequence"	| byteStream replaced replacement char |	byteStream := bytes readStream.	replaced := false.	replacement := self replacementCodePoint asCharacter.	^ String streamContents: [ :stream |		[ byteStream atEnd ] whileFalse: [			char := self nextFromStream: byteStream.			char = replacement				ifTrue: [					replaced 						ifFalse: [							replaced := true.							stream nextPut: replacement ] ]				ifFalse: [					replaced := false.					stream nextPut: char ] ] ]! !!ZnLossyUTF8Encoder methodsFor: 'error handling' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!errorIllegalContinuationByte	^ self replacementCodePoint! !!ZnLossyUTF8Encoder methodsFor: 'error handling' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!errorIllegalLeadingByte	^ self replacementCodePoint! !!ZnLossyUTF8Encoder methodsFor: 'error handling' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!errorIncomplete	^ self replacementCodePoint! !!ZnLossyUTF8Encoder methodsFor: 'error handling' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!errorOutsideRange	^ self replacementCodePoint! !!ZnLossyUTF8Encoder methodsFor: 'error handling' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!errorOverlong	^ self replacementCodePoint! !!ZnLossyUTF8Encoder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!identifier	^ #utf8lossy! !!ZnLossyUTF8Encoder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!replacementCodePoint	"Return the code point for the Unicode Replacement Character U+FFFD"		^ 16rFFFD! !!ZnUTF8Encoder methodsFor: 'encoding - decoding' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91030151!ensureAtBeginOfCodePointOnStream: stream	"Ensure that the current position of stream is a the beginning of an encoded code point,	if not move further backwards. This is necessary when a position in the binary stream is set,	not knowing if that position is on a proper encoded character boundary."	"If we are at end-of-stream, we can't be in the middle of an encoded codepoint	(unless that codepoint is incomplete and thus invalid, which we won't worry about)"	stream atEnd ifTrue: [ ^ self ].	"Back up until we are not longer on a continuation byte but on a leading byte"	[ (stream peek bitAnd: 2r11000000) == 2r10000000 ] whileTrue: [ stream back ]! !!ZnUTF8Encoder methodsFor: 'encoding - decoding' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91027415!nextCodePointFromStream: stream	"Read and return the next integer code point from stream"	| code byte next |	(byte := stream next ifNil: [ ^ self errorIncomplete ]) < 128		ifTrue: [ ^ byte ].	(byte bitAnd: 2r11100000) == 2r11000000		ifTrue: [			code := byte bitAnd: 2r00011111.			((next := stream next ifNil: [ ^ self errorIncomplete ]) bitAnd: 2r11000000) == 2r10000000				ifTrue: [ code := (code bitShift: 6) + (next bitAnd: 2r00111111) ]				ifFalse: [ ^ self errorIllegalContinuationByte ].			code < 128 ifTrue: [ ^ self errorOverlong ].			^ code ].	(byte bitAnd: 2r11110000) == 2r11100000		ifTrue: [			code := byte bitAnd: 2r00001111.			2 timesRepeat: [				((next := stream next ifNil: [ ^ self errorIncomplete ]) bitAnd: 2r11000000) == 2r10000000					ifTrue: [ code := (code bitShift: 6) + (next bitAnd: 2r00111111) ]					ifFalse: [ ^ self errorIllegalContinuationByte ] ].			code < 2048 ifTrue: [ ^ self errorOverlong ].			(self isSurrogateCodePoint: code) ifTrue: [ ^ self errorOutsideRange ].			(code = self byteOrderMark and: [ self ignoreByteOrderMark ]) ifTrue: [				stream atEnd ifTrue: [ ^ self errorIncomplete ].				^ self nextCodePointFromStream: stream ].			^ code ].	(byte bitAnd: 2r11111000) == 2r11110000		ifTrue: [			code := byte bitAnd: 2r00000111.			3 timesRepeat: [				((next := stream next ifNil: [ ^ self errorIncomplete ]) bitAnd: 2r11000000) == 2r10000000					ifTrue: [ code := (code bitShift: 6) + (next bitAnd: 2r00111111) ]					ifFalse: [ ^ self errorIllegalContinuationByte ] ].			code < 65535 ifTrue: [ ^ self errorOverlong ].			code > self maximumUTFCode ifTrue: [ self errorOutsideRange ].			^ code ].	^ self errorIllegalLeadingByte! !!ZnUTF32Encoder methodsFor: 'private' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!byteOrderMarkLE	"My little endian sequence of the Unicode BOM. See #byteOrderMark"		^ 16rFFFE0000! !!ZnUTF32Encoder methodsFor: 'encoding - decoding' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91024279!nextCodePointFromStream: stream	"Read and return the next integer code point from stream"	| codePoint |	codePoint := self readCodePointFrom: stream.	((self processByteOrderMark: codePoint) and: [ self ignoreByteOrderMark ])		ifTrue: [ codePoint := self readCodePointFrom: stream ].	((self isSurrogateCodePoint: codePoint) or: [ codePoint > self maximumUTFCode ])		ifTrue: [ ^ self errorOutsideRange ].	^ codePoint! !!ZnUTF32Encoder methodsFor: 'private' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91023045!processByteOrderMark: codePoint	^ (codePoint = self byteOrderMark or: [ codePoint = self byteOrderMarkLE ])		ifTrue: [			codePoint = self byteOrderMarkLE 				ifTrue: [ self swapEndianness ].			true ]		ifFalse: [ false ]! !!ZnCharacterReadWriteStream methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90425191!skip: anInteger	anInteger < 0 ifTrue: [ self error: 'cannot skip backwards' ].	readStream skip: anInteger! !ZnUTF16Encoder removeSelector: #identifier!ZnUTF32Encoder removeSelector: #identifier!ZnEncodedWriteStream removeSelector: #isBinary!ZnEncodedReadStream removeSelector: #isBinary!"Zinc-Character-Encoding-Core"!!ZnBufferedReadStreamTest methodsFor: 'tests' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testBack	"Check that ZnBufferedReadStream>>#back behaves as expected"	<gtExample>	| stream source |	"Allocate a buffer larger than the default size (65536)"	self assert: ZnBufferedReadStream basicNew defaultBufferSize < 66000.	source := ByteArray new: 70000.	1 to: 70000 do: [ :i |		source at: i put: i \\ 256 ].	stream := ZnBufferedReadStream on: source readStream.	stream position: 1.	self assert: stream peek equals: (source at: 2).	self assert: stream back equals: (source at: 1).	"Position the stream beyond the end of the initial buffer"	stream position: 66000.	self assert: stream peek equals: (source at: 66001).	self assert: stream back equals: (source at: 66000).! !!ZnCharacterEncoderTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90405364!testKnownEncodingIdentifiers	| all minimal asciiString notSelfIdentifying|	all := ZnCharacterEncoder knownEncodingIdentifiers asSet.	minimal := #(utf8 latin1 null ascii iso88591) asSet.	"make sure at least a minimal set is present"	self assert: (all intersection: minimal) equals: minimal.	asciiString := String withAll: ($a to: $z) , ($A to: $Z) , ($0 to: $9).	"make sure that each identifier can be used to instanciate a decoder,	and that those decoders at least work on a ASCII string in both directions"	all do: [ :each |		| encoder bytes |		encoder := ZnCharacterEncoder newForEncoding: each.		bytes := encoder encodeString: asciiString.		self assert: (encoder decodeBytes: bytes) equals: asciiString ].	"make sure identifiers are preserved"	notSelfIdentifying := ZnCharacterEncoder knownEncodingIdentifiers reject: [ :each | 		each asZnCharacterEncoder identifier = each ].	self assert: notSelfIdentifying isEmpty! !!ZnCharacterEncoderTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testLossyUTF8	| encoder replacement |	encoder := ZnLossyUTF8Encoder new.	self assert: #utf8lossy asZnCharacterEncoder equals: encoder.	replacement := encoder replacementCodePoint asCharacter.	self 		assert: (#[65 160 66] decodeWith: encoder) 		equals: ({ $A. replacement . $B } as: String).	self 		assert: (#[16rE1 16rA0 16rC0] decodeWith: encoder) 		equals: replacement asString.	self 		assert: (encoder decodeBytes: #[16r41 16rA1 16rA2 16rA3 16r42]) 		equals: ({ $A. replacement . replacement . replacement . $B } as: String).	self 		assert: (encoder decodeBytesSingleReplacement: #[16r41 16rA1 16rA2 16rA3 16r42])		equals: ({ $A. replacement . $B } as: String).! !!ZnCharacterEncoderTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testLossyUTF8Random	| bytes string |	bytes := ((1 to: 10000) collect: [ :_ | 256 atRandom - 1 ]) asByteArray.	string := bytes decodeWith: ZnLossyUTF8Encoder new.	self assert: string isString! !!ZnCharacterEncoderTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testUTF8ByteOrderMarkSignificant	| input encoder result |	input := #[16r41 16rEF 16rBB 16rBF 16r42].	encoder := ZnUTF8Encoder new.	encoder ignoreByteOrderMark: false.	result := encoder decodeBytes: input.	self assert: result first equals: $A.	self assert: result second equals: encoder byteOrderMark asCharacter.	self assert: result third equals: $B! !!ZnBufferedWriteStreamTest methodsFor: 'tests' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testWritingReset	| file writeStream readStream |	file := 'test.txt' asFileReference ensureCreateFile.	writeStream := file binaryWriteStream.	writeStream nextPutAll: 'pedro'.	writeStream reset.	writeStream nextPutAll: 'pha'.	writeStream close.	readStream := file readStream.	self assert: readStream contents equals: 'pharo'! !!ZnCharacterStreamTest methodsFor: 'tests' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testReset	| stream |	stream := ZnCharacterReadStream on: 'abc' asByteArray readStream.	self assert: stream next equals: $a.	stream reset.	self assert: stream next equals: $a! !!ZnCharacterStreamTest methodsFor: 'tests' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90428385!testUTF8ReadStreamPositioning	| bytes stream |	bytes := 'élève' utf8Encoded.	stream := ZnCharacterReadStream on: bytes readStream.	self assert: stream position equals: 0.	stream position: 0.	self assert: stream next equals: $é.	stream position: 1.	self assert: stream next equals: $é.	stream position: 2.	self assert: stream next equals: $l.	stream position: 3.	self assert: stream next equals: $è.	stream position: 4.	self assert: stream next equals: $è.	stream position: 5.	self assert: stream next equals: $v.	stream position: 6.	self assert: stream next equals: $e.	stream position: 7.	self assert: stream atEnd.! !"Zinc-Character-Encoding-Tests"!!ZnDataUrl commentStamp: 'SvenVanCaekenberghe 10/6/2023 18:45' prior: 0!I am ZnDataUrl, I implement the Data URI scheme as defined in RFC 2397.I am like a URL/URI, but as an immediate value. As such I encapsulate a mime type and data. The data can optionally be base64 encoded, which is needed for non textual types.Note that there is a difference between my external and internal representation. See #printOn: and #parseFrom:References- https://en.wikipedia.org/wiki/Data_URI_scheme- https://datatracker.ietf.org/doc/html/rfc2397!!ZnMimeType methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90746349!hasParameters	^ parameters isNotNil and: [ parameters isNotEmpty ]! !!ZnMimeType methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90747708!isBinary	"Answers whether the contents of a resource described by me	should be considered as binary instead of textual."		| subParts |	self main = 'text'		ifTrue: [ ^ false ].	subParts := self sub substrings: '+-'.	(subParts anySatisfy: [ :subPart |				self class textSubTypeFragments includes: subPart ])		ifTrue: [ ^ false ].	(subParts anySatisfy: [ :subPart | 				self class textSubTypeFragments anySatisfy: [ :fragment | 						subPart includesSubstring: fragment ] ])		ifTrue: [ ^ false ].	^ true! !!ZnMimeType methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90746222!isCharSetUTF8	^ self charSet isNotNil and: [ self charSet sameAs: 'utf-8' ]! !!ZnDataUrl class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!bytes: bytes type: mimeType	"self bytes: #[71 73 70 56 55 97 48 0 48 0 240 0 0 0 0 0 255 255 255 44 0 0 0 0 48 0 48 0 0 2 240 140 143 169 203 237 223 0 156 14 72 139 115 176 180 171 12 134 30 20 150 166 52 46 231 42 166 9 139 26 167 43 175 81 73 111 56 217 142 102 215 243 128 92 193 201 48 117 209 8 49 57 29 19 168 20 30 142 20 77 204 231 228 84 159 185 98 37 42 173 113 121 99 153 74 135 240 222 184 215 15 231 34 214 26 193 27 180 184 142 74 150 191 76 248 59 38 146 71 199 39 167 119 53 147 5 245 244 115 19 167 40 248 224 7 56 184 118 40 167 88 103 100 23 201 35 117 249 242 113 6 87 101 230 6 122 57 137 149 151 134 151 216 182 137 197 106 104 213 90 138 84 250 23 152 137 247 73 186 154 251 147 75 131 138 211 147 52 188 57 52 67 133 212 183 11 202 59 58 220 119 120 170 246 232 172 23 205 76 212 226 28 71 185 68 123 12 28 46 158 237 184 211 100 51 123 141 157 173 197 216 148 5 163 222 213 174 44 191 94 94 63 127 87 31 229 85 179 95 44 166 236 241 225 135 30 29 110 6 10 0 0 59] type: ZnMimeType imageGif"		^ self new		mediaType: mimeType;		data: bytes;		base64Encoded: true;		yourself! !!ZnDataUrl class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!fromString: string	"Parse the external representation of a Data URI from string.	The general format being data:[<mediatype>][;base64],<data>"		"self fromString: 'data:image/gif;base64,R0lGODdhMAAwAPAAAAAAAP///ywAAAAAMAAwAAAC8IyPqcvt3wCcDkiLc7C0qwyGHhSWpjQu5yqmCYsapyuvUUlvONmOZtfzgFzByTB10QgxOR0TqBQejhRNzOfkVJ+5YiUqrXF5Y5lKh/DeuNcP5yLWGsEbtLiOSpa/TPg7JpJHxyendzWTBfX0cxOnKPjgBzi4diinWGdkF8kjdfnycQZXZeYGejmJlZeGl9i2icVqaNVailT6F5iJ90m6mvuTS4OK05M0vDk0Q4XUtwvKOzrcd3iq9uisF81M1OIcR7lEewwcLp7tuNNkM3uNna3F2JQFo97Vriy/Xl4/f1cf5VWzXyym7PHhhx4dbgYKAAA7'"		^ self new		parseFrom: string;		yourself! !!ZnDataUrl class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!text: string	"self text: 'Hello there !!'"		^ self new		mediaType: ZnMimeType textPlain;		data: string;		yourself! !!ZnDataUrl methodsFor: 'comparing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!= anObject	"Answer whether the receiver and anObject represent the same object."	self == anObject ifTrue: [ ^ true ].	self class = anObject class ifFalse: [ ^ false ].	^ mediaType = anObject mediaType and: [		  base64Encoded = anObject isBase64Encoded and: [			  data = anObject data ] ]! !!ZnDataUrl methodsFor: 'initialization' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!base64Encoded: boolean	base64Encoded := boolean! !!ZnDataUrl methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!data	"Answer the data that I hold, either a ByteArray or a String"		^ data! !!ZnDataUrl methodsFor: 'initialization' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!data: stringOrBytes	data := stringOrBytes! !!ZnDataUrl methodsFor: 'comparing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!hash	"Answer an integer value that is related to the identity of the receiver."	^ mediaType hash bitXor: (base64Encoded hash bitXor: data hash)! !!ZnDataUrl methodsFor: 'initialization' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!initialize	super initialize.	mediaType := 'text/plain;charset=ASCII' asZnMimeType.	base64Encoded := false.	data := #[]! !!ZnDataUrl methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!isBase64Encoded	"Am I using Base64 encoding ?"		^ base64Encoded! !!ZnDataUrl methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!isBinary	"Am I binary ?"		^ mediaType isBinary! !!ZnDataUrl methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!isEmpty	^ data isEmpty! !!ZnDataUrl methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!mediaType	"Answer the media type that described my content, a ZnMimeType"		^ mediaType! !!ZnDataUrl methodsFor: 'initialization' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!mediaType: mimeType	mediaType := mimeType asZnMimeType! !!ZnDataUrl methodsFor: 'parsing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!parseFrom: string	| commaIndex |	(string beginsWith: 'data:')		ifFalse: [ ^ self error: 'missing data: scheme' ].	(commaIndex := string indexOf: $,) isZero		ifTrue: [ ^ self error: 'missing comma in data: scheme' ].	commaIndex = string size 		ifTrue: [ ^ self ].	commaIndex > 7		ifTrue: [ mediaType := ZnMimeType fromString: (string copyFrom: 6 to: commaIndex - 1) ].	(base64Encoded := mediaType parameters includesKey: 'base64')		ifTrue: [ 			 mediaType removeParameter: 'base64' ].	data := string copyFrom: commaIndex + 1 to: string size.	data := base64Encoded 		ifTrue: [ 			ZnBase64Encoder new				decode: data ]		ifFalse: [			ZnPercentEncoder new 				characterEncoder: mediaType charSet asZnCharacterEncoder;				decode:	data ]! !!ZnDataUrl methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!printOn: stream	stream nextPutAll: 'data:'.	mediaType printOn: stream.	base64Encoded		ifTrue: [ 			stream nextPutAll: ';base64,'.			ZnBase64Encoder new 				encode: data readStream to: stream ]		ifFalse: [			stream nextPut: $,.			ZnPercentEncoder new 				characterEncoder: mediaType charSet asZnCharacterEncoder;				encode: data readStream to: stream ]! !!ZnDataUrl methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!scheme	"Answer my URL scheme"		^ #data! !!ZnUrl methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91068387!hasFragment	^ fragment isNotNil! !!ZnUrl methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91064618!hasHost	^ host isNotNil! !!ZnUrl methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91068220!hasPassword	^ password isNotNil! !!ZnUrl methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91070520!hasPath	^ segments isNotNil and: [ segments isNotEmpty ]! !!ZnUrl methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91057326!hasPort	^ port isNotNil! !!ZnUrl methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91066787!hasQuery	^ query isNotNil and: [ query isNotEmpty ]! !!ZnUrl methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91046686!hasScheme	^ scheme isNotNil! !!ZnUrl methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91069111!hasUsername	^ username isNotNil! !!ZnUrl methodsFor: 'parsing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91050320!parseFrom: string defaultScheme: defaultScheme	| start end index |	start := 1.	end := string size.	(index := string indexOf: $#) > 0		ifTrue: [			self fragment: (self decodePercent: (string copyFrom: index + 1 to: end)).			end := index - 1 ].	((index := (string indexOf: $?)) between: 1 and: end)		ifTrue: [			self query: (self parseQueryFrom: (ReadStream on: string from: index + 1 to: end)).			end := index - 1 ].	((index := string indexOfSubCollection: '://') > 0 and: [ index <= end ])		ifTrue: [			self scheme: (string copyFrom: 1 to: index - 1).			start := index + 3 ]		ifFalse: [			((index := string indexOf: $:) > 0					and: [ index <= end						and: [ self isSchemeNotUsingDoubleSlash: (string copyFrom: 1 to: index - 1) ] ])				ifTrue: [					self scheme: (string copyFrom: 1 to: index - 1).					start := index + 1 ]				ifFalse: [					defaultScheme ifNotNil: [ self scheme: defaultScheme ] ] ].	self hasScheme		ifTrue: [			(index := string indexOf: $/ startingAt: start) > 0				ifTrue: [					self parseAuthority: string from: start to: index - 1.					start := index ]				ifFalse: [					^ self parseAuthority: string from: start to: end ] ].	self parsePath: (ReadStream on: string from: start to: end)! !!ZnMultiValueDictionary methodsFor: 'private' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90793539!checkLimitForKey: aKey	"Signal an exception when the limit, if present, is exceeded."	(self limit isNotNil and: [ self size >= self limit and: [ (self includesKey: aKey) not ]])		ifTrue: [ (ZnTooManyDictionaryEntries limit: self limit) signal ]! !"Zinc-Resource-Meta-Core"!!ZnDataUrlTest methodsFor: 'tests' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testABriefNote	| dataUrl |	dataUrl := ZnDataUrl fromString: 'data:,A%20brief%20note'.	self assert: dataUrl data equals: 'A brief note'.	self deny: dataUrl isBase64Encoded.! !!ZnDataUrlTest methodsFor: 'tests' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testBinary	self		assert: (ZnDataUrl bytes: #[1 2 3] type: 'application/octet-stream')		equals: (ZnDataUrl bytes: #[1 2 3] type: 'application/octet-stream').	self		assert: (ZnDataUrl bytes: #[1 2 3] type: 'application/octet-stream') hash		equals: (ZnDataUrl bytes: #[1 2 3] type: 'application/octet-stream') hash.	self		assert: (ZnDataUrl bytes: #[1 2 3] type: 'application/octet-stream') printString		equals: (ZnDataUrl bytes: #[1 2 3] type: 'application/octet-stream') printString! !!ZnDataUrlTest methodsFor: 'tests' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testBinaryAll	| dataUrl |	dataUrl := ZnDataUrl new.	dataUrl data: (0 to: 255) asByteArray.	dataUrl mediaType: ZnMimeType applicationOctetStream.	dataUrl base64Encoded: true.	self assert: dataUrl data equals: (0 to: 255) asByteArray.	self assert: dataUrl isBase64Encoded.	self assert: dataUrl mediaType equals: ZnMimeType applicationOctetStream.	self assert: (ZnDataUrl fromString: dataUrl printString) data equals: (0 to: 255) asByteArray! !!ZnDataUrlTest methodsFor: 'tests' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testEmpty	| dataUrl |	dataUrl := ZnDataUrl new.	self assert: dataUrl isEmpty.	self assert: dataUrl scheme equals: #data.	self assert: ('text/plain' asZnMimeType matches: dataUrl mediaType).	self assert: dataUrl equals: ZnDataUrl new! !!ZnDataUrlTest methodsFor: 'tests' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testGreek	| dataUrl |	dataUrl := ZnDataUrl fromString: 'data:text/plain;charset=iso-8859-7,%e1%f8%e2'.	self assert: dataUrl data equals: 'αψβ'.	self deny: dataUrl isBase64Encoded.	self assert: (dataUrl printString sameAs: 'data:text/plain;charset=iso-8859-7,%e1%f8%e2')! !!ZnDataUrlTest methodsFor: 'tests' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testParseMinimal	| dataUrl |	dataUrl := ZnDataUrl fromString: 'data:,'.	self assert: dataUrl isEmpty.	self assert: dataUrl scheme equals: #data.	self assert: ('text/plain' asZnMimeType matches: dataUrl mediaType).! !!ZnDataUrlTest methodsFor: 'tests' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testPng	| logoPngBytes dataUrl representation |	logoPngBytes := PolymorphSystemSettings pharoLogoContents base64Decoded.	dataUrl := ZnDataUrl bytes: logoPngBytes type: ZnMimeType imagePng.	representation := dataUrl printString.	dataUrl := ZnDataUrl fromString: representation.	self assert: dataUrl data equals: logoPngBytes ! !!ZnDataUrlTest methodsFor: 'tests' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testSimpleBinary	| dataUrl |	dataUrl := ZnDataUrl new.	dataUrl data: #[ 0 1 2 3 4 5 6 7 8 9 ].	dataUrl mediaType: ZnMimeType applicationOctetStream.	dataUrl base64Encoded: true.	self assert: dataUrl data equals: #[ 0 1 2 3 4 5 6 7 8 9 ].	self assert: dataUrl isBase64Encoded.	self assert: dataUrl mediaType equals: ZnMimeType applicationOctetStream! !!ZnDataUrlTest methodsFor: 'tests' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testSimpleString	| dataUrl |	dataUrl := ZnDataUrl new.	dataUrl data: 'foo'.	self assert: dataUrl data equals: 'foo'! !!ZnDataUrlTest methodsFor: 'tests' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testSmallGif	| dataUrl |	dataUrl := ZnDataUrl fromString: 'data:image/gif;base64,R0lGODdhMAAwAPAAAAAAAP///ywAAAAAMAAwAAAC8IyPqcvt3wCcDkiLc7C0qwyGHhSWpjQu5yqmCYsapyuvUUlvONmOZtfzgFzByTB10QgxOR0TqBQejhRNzOfkVJ+5YiUqrXF5Y5lKh/DeuNcP5yLWGsEbtLiOSpa/TPg7JpJHxyendzWTBfX0cxOnKPjgBzi4diinWGdkF8kjdfnycQZXZeYGejmJlZeGl9i2icVqaNVailT6F5iJ90m6mvuTS4OK05M0vDk0Q4XUtwvKOzrcd3iq9uisF81M1OIcR7lEewwcLp7tuNNkM3uNna3F2JQFo97Vriy/Xl4/f1cf5VWzXyym7PHhhx4dbgYKAAA7'.	self assert: dataUrl mediaType equals: ZnMimeType imageGif.	self deny: dataUrl isEmpty.	self assert: dataUrl isBase64Encoded.	ImageReadWriter formFromStream: dataUrl data readStream.	self assert: dataUrl printString equals: 'data:image/gif;base64,R0lGODdhMAAwAPAAAAAAAP///ywAAAAAMAAwAAAC8IyPqcvt3wCcDkiLc7C0qwyGHhSWpjQu5yqmCYsapyuvUUlvONmOZtfzgFzByTB10QgxOR0TqBQejhRNzOfkVJ+5YiUqrXF5Y5lKh/DeuNcP5yLWGsEbtLiOSpa/TPg7JpJHxyendzWTBfX0cxOnKPjgBzi4diinWGdkF8kjdfnycQZXZeYGejmJlZeGl9i2icVqaNVailT6F5iJ90m6mvuTS4OK05M0vDk0Q4XUtwvKOzrcd3iq9uisF81M1OIcR7lEewwcLp7tuNNkM3uNna3F2JQFo97Vriy/Xl4/f1cf5VWzXyym7PHhhx4dbgYKAAA7'! !!ZnDataUrlTest methodsFor: 'tests' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testText	self 		assert: (ZnDataUrl text: 'Les élèves Français')		equals: (ZnDataUrl text: 'Les élèves Français').	self 		assert: (ZnDataUrl text: 'Les élèves Français') hash		equals: (ZnDataUrl text: 'Les élèves Français') hash.	self 		assert: (ZnDataUrl text: 'Les élèves Français') printString		equals: (ZnDataUrl text: 'Les élèves Français') printString! !!ZnMimeTypeTest methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90775945!someNonBinaryMimeTypes	^ #(		'text/plain;charset=ascii'		'application/json;charset=utf-8'		'application/ston'		'application/vnd.com.runkeeper.user+json;charset=ISO-8859-1'		'application/xml-dtd'		'application/xslt+xml'		'image/svg+xml'		'application/SGML'		'model/x3d+xml'		'application/csv'		'application/x-ndjson')! !"Zinc-Resource-Meta-Tests"!!ZnTooManyRedirects commentStamp: '<historical>' prior: 91016655!ZnTooManyRedirects is signalled when an HTTP client has been following more redirects than allowed.The default resume behavior is to retry, signal with any other value to give up just return the redirect.Part of Zinc HTTP Components. !!ZnClientTransactionEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90533715!printContentsOn: stream	super printContentsOn: stream.	request requestLine printMethodAndUriOn: stream.	stream space; print: response code.	response hasEntity		ifTrue: [			stream space; print: response entity contentLength; nextPut: $B ].	stream space; print: self duration; nextPutAll: 'ms'! !!ZnServerStartedEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90924636!printContentsOn: stream	super printContentsOn: stream.	description ifNotNil: [ stream << 'Started '; << description ]! !!ZnServer methodsFor: 'options' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90905269!delegate	"Return the optional delegate,	the object that will be sent #handleRequest: to handle a request and produce a response.	The default delegate is ZnDefaultServerDelegate"	^ self 		optionAt: #delegate		ifAbsentPut: [ ZnDefaultServerDelegate new server: self; yourself ]! !!ZnServer methodsFor: 'options' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!serverId	"Return my serverId.	This is a short identification string used in my name and while logging.	The default is nil, meaning there is no serverId."	^ self optionAt: #serverId ifAbsent: [ nil ]! !!ZnServer methodsFor: 'options' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!serverId: object	"Set my serverId.	This is a short identification string used in my name and while logging.	The default is nil, meaning there is no serverId."	self optionAt: #serverId put: object! !!ZnChunkedReadStream methodsFor: 'private' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90443184!ensureChunkBufferOfSize: size	(chunk isNotNil and: [ size <= chunk size ]) ifTrue: [ ^ self ].	chunk := self collectionSpecies new: size! !!ZnChunkedReadStream methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90438079!skip: count	count < 0 ifTrue: [ self error: 'cannot skip backwards' ].	count timesRepeat: [ self next ]! !!ZnBivalentWriteStream methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!print: object	object printOn: self! !!ZnDigestCredential methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90580490!isComplete	^ super isComplete & nonce isNotNil! !!ZnClientIgnoringExceptionOnConnectionReuseEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90501694!printContentsOn: stream	super printContentsOn: stream.	stream << 'Ignoring Exception On Connection Reuse '; print: exception! !!ZnRequestResponseHandledEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90871480!printContentsOn: stream	super printContentsOn: stream.	stream << 'Request Handled '; print: request; space; print: duration; << 'ms'! !!ZnClientFollowingRedirectEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90500917!printContentsOn: stream	super printContentsOn: stream.	stream << 'Following Redirect '; print: target! !!ZnRequestWrittenEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90876883!printContentsOn: stream	super printContentsOn: stream.	stream << 'Request Written '; print: request; space; print: duration; << 'ms'! !!ZnUtils class methodsFor: 'converting' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!exceptionSet: classNames	^ classNames inject: ExceptionSet new into: [ :set :each |		  (Smalltalk globals includesKey: each)			  ifTrue: [				  set					  add: (Smalltalk at: each);					  yourself ]			  ifFalse: [ set ] ]! !!ZnUtils class methodsFor: 'streaming' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91112597!readUpToEnd: inputStream limit: limit	| species bufferSize buffer totalRead outputStream |	bufferSize := limit ifNil: [ self streamingBufferSize ] ifNotNil: [ self streamingBufferSize min: limit ].	species := inputStream isBinary ifTrue: [ ByteArray ] ifFalse: [ String ].	buffer := species new: bufferSize.	totalRead := 0.	outputStream := nil.	[ inputStream atEnd ] whileFalse: [ | readCount |		readCount := inputStream readInto: buffer startingAt: 1 count: bufferSize.		totalRead := totalRead + readCount.		(limit isNotNil and: [ totalRead > limit ])			ifTrue: [ ZnEntityTooLarge signal ].		outputStream ifNil: [			inputStream atEnd				ifTrue: [ ^ buffer copyFrom: 1 to: readCount ]				ifFalse: [ outputStream := (species new: bufferSize) writeStream ] ].		outputStream next: readCount putAll: buffer startingAt: 1.		self signalProgress: totalRead total: limit ].	^ outputStream ifNil: [ species new ] ifNotNil: [ outputStream contents ]! !!ZnUtils class methodsFor: 'streaming' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91111096!signalProgress: amount total: total	(ZnCurrentOptions at: #signalProgress)		ifTrue: [			total				ifNil: [					HTTPProgress new						signal: ('Transferred {1} bytes ...' format: { amount humanReadableSIByteSize }) ]				ifNotNil: [					HTTPProgress new						total: total;						amount: amount;						signal: 'Transferring...' ] ]! !!ZnUtils class methodsFor: 'streaming' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91109066!streamFrom: inputStream to: outputStream size: totalSize	| bufferSize buffer leftToRead |	bufferSize := self streamingBufferSize min: totalSize.	buffer := (inputStream isBinary ifTrue: [ ByteArray ] ifFalse: [ String ]) new: bufferSize.	leftToRead := totalSize.	[ leftToRead > 0 and: [ inputStream atEnd not ] ]		whileTrue: [ | toReadCount readCount |			toReadCount := bufferSize min: leftToRead.			readCount := inputStream readInto: buffer startingAt: 1 count: toReadCount.			leftToRead := leftToRead - readCount.			outputStream next: readCount putAll: buffer startingAt: 1.			leftToRead > 0				ifTrue: [					self signalProgress: (totalSize - leftToRead) total: totalSize.					outputStream flush ] ].	^ totalSize - leftToRead! !!ZnDefaultServerDelegate methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!server	"Return the ZnServer I was configured with, the one I am the delegate for"		^ server! !!ZnDefaultServerDelegate methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!server: znServer	"Set my server to snServer, the one I am the delegate for"		server := znServer! !!ZnServerReadErrorEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90918368!printContentsOn: stream	super printContentsOn: stream.	stream << 'Server Read Error ';  print: exception! !!ZnBasicCredential methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90293142!isComplete	^ username isNotNil & password isNotNil! !!ZnClient methodsFor: 'private' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90457753!cleanupConnection	(self isOneShot		or: [			self streaming not				and: [					(request isNotNil and: [ request wantsConnectionClose ])						or: [ response isNotNil and: [ response wantsConnectionClose ] ] ] ])		ifTrue: [			self close ]! !!ZnClient methodsFor: 'private - protocol' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!executeWithRedirectsRemaining: redirectCount trail: collectionOfUrls	self getConnectionAndExecute.	response isRedirect		ifTrue: [			(redirectCount > 0 and: [ self followRedirects ])				ifTrue: [					self prepareRedirect.					collectionOfUrls add: self request url.					self 						executeWithRedirectsRemaining: redirectCount - 1 						trail: collectionOfUrls ]				ifFalse: [					self followRedirects						ifTrue: [ | exception |							(exception := ZnTooManyRedirects new) 									trail: collectionOfUrls. 							exception signal = exception defaultResumeValue								ifTrue: [									"when resumed with default resume value, start over"									self 										executeWithRedirectsRemaining: self maxNumberOfRedirects 										trail: collectionOfUrls ] ] ] ].	^ self handleResponse! !!ZnClient methodsFor: 'private - protocol' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90495213!executeWithRetriesRemaining: retryCount	^ [ self 			executeWithRedirectsRemaining: self maxNumberOfRedirects			trail: OrderedCollection new ]		on: self retryExceptionSet		do: [ :exception |			retryCount > 0				ifTrue: [					self						handleRetry: exception;						executeWithRetriesRemaining: retryCount - 1 ]				ifFalse: [					exception pass ] ]! !!ZnClient methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90493119!isConnected	"Return true if I hold an open HTTP connection."	^ connection isNotNil and: [ connection isConnected ]! !!ZnClient methodsFor: 'private' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90494015!newConnectionTo: url	| initialMilliseconds |	self signalHTTPProgress: 'Connecting to ',  url authority.	initialMilliseconds := Time millisecondClockValue.	(connection isNotNil and: [ connection isConnected ])		ifTrue: [ connection close ].	connection := ZnNetworkingUtils socketStreamToUrl: url.	url hasSecureScheme		ifTrue: [ self setupTLSTo: url ].	self logConnectionEstablishedTo: url started: initialMilliseconds! !!ZnClient methodsFor: 'accessing - request' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90494498!resetEntity	"Make sure that the current request does not hold an entity from a previous request.	This is sometimes necessary after a POST or PUT. This method will be called automatically	by #method: for certain requests."	(request isNotNil and: [ request hasEntity ])		ifTrue: [ request resetEntity: nil ]! !!ZnClient methodsFor: 'private' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90485231!setupTLSTo: url	(ZnNetworkingUtils shouldProxyUrl: url)		ifTrue: [ | originalRequest |			"http://www.ietf.org/rfc/rfc2817.txt (section 5)"			"https://en.wikipedia.org/wiki/HTTP_tunnel#HTTP_CONNECT_tunneling"			originalRequest := request copy.			request entity: nil. "to prevent #resetEntity from being called, resulting in #close of the shared entity"			self method: #CONNECT; writeRequest; readResponse.			response isSuccess ifFalse: [ self error: 'Failed to CONNECT to proxy for TLS/SSL' ].			connection := ZnNetworkingUtils secureSocketStreamOn: connection socket.			request := originalRequest ].	connection sslSession certificateName: self certificate.	[ connection sslSession serverName: url host ]		on: (ZnUtils exceptionSet: #( #SocketError #PrimitiveFailed ))		do: [ :error | "log it?" ].	connection connect! !!ZnEntityReader methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90610518!allowsReadingUpToEnd	^ allowReadingUpToEnd isNotNil and: [ allowReadingUpToEnd ]! !!ZnEntityReader methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90610725!isBinary	^ binary isNotNil and: [ binary ]! !!ZnEntityReader methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90612921!isStreaming	^ streaming isNotNil and: [ streaming ]! !!ZnStringEntity methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91012034!encoder: anEncoding	(encoder isNotNil and: [ anEncoding ~= encoder ]) ifTrue: [ self invalidateContentLength ].	encoder := anEncoding! !!ZnStringEntity methodsFor: 'private' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91010582!hasEncoder	^ encoder isNotNil! !!ZnStringEntity methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91011003!printContentsOn: stream	super printContentsOn: stream.	self string ifNotNil: [		stream			space;			nextPutAll: self string ]! !!ZnStringEntity methodsFor: 'initialize-release' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91008193!readFrom: stream	| buffer totalRead read readStream stringStream total |	total := self contentLength.	readStream := total ifNotNil: [ ZnLimitedReadStream on: stream limit: total ] ifNil: [ stream ].	buffer := String new: (ZnUtils streamingBufferSize min: (total ifNil: [ ZnUtils streamingBufferSize ])).	stringStream := nil.	totalRead := read := 0.	self initializeEncoder.	[ readStream atEnd ] whileFalse: [		[ read := encoder readInto: buffer startingAt: 1 count: buffer size fromStream: readStream ]			on: ZnByteStringBecameWideString			do: [ :notification |					buffer := notification wideString.					stringStream ifNotNil: [ | wideString position |						position := stringStream position.						wideString := WideString from: stringStream originalContents.						stringStream on: wideString; setFrom: position + 1 to: position ].					notification resume ].		totalRead := totalRead + read.		totalRead > (ZnCurrentOptions at: #maximumEntitySize)			ifTrue: [ ZnEntityTooLarge signal ].		stringStream ifNil: [			readStream atEnd				ifTrue: [ ^ self string: (buffer copyFrom: 1 to: read); computeContentLength ]				ifFalse: [ stringStream := (total ifNil: [ buffer species new ] ifNotNil: [ buffer species new: total ]) writeStream ] ].		stringStream next: read putAll: buffer startingAt: 1.		ZnUtils signalProgress: totalRead total: total ].	self string: (stringStream ifNil: [ String new ] ifNotNil: [ stringStream contents ])! !!ZnStringEntity methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91010738!string: aString	(string isNotNil and: [ aString ~= string ]) ifTrue: [ self invalidateContentLength ].	string := aString! !!ZnConnectionAcceptedEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90538941!printContentsOn: stream	super printContentsOn: stream.	stream << 'Connection Accepted '.	self class printAddress: address on: stream ! !!ZnServerSocketReleasedEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90924059!printContentsOn: stream	super printContentsOn: stream.	stream << 'Server Socket Released '.	self class printAddress: address on: stream. 	stream nextPut: $:; print: port! !!ZnConnectionRejectedEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90541152!printContentsOn: stream	super printContentsOn: stream.	stream << 'Connection Rejected '.	self class printAddress: address on: stream! !!ZnRequestReadEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90870445!printContentsOn: stream	super printContentsOn: stream.	stream << 'Request Read '; print: request; space; print: duration; << 'ms'! !!ZnServerConnectionClosedEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90915477!printContentsOn: stream	super printContentsOn: stream.	stream << 'Server Connection Closed '.	self class printAddress: address on: stream ! !!ZnMessage methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90725784!hasEntity	^ self entity isNotNil! !!ZnMessage methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90725864!hasHeaders	^ headers isNotNil and: [ self headers isEmpty not ]! !!ZnMessage methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90728844!hasSession	"Return if there currently is a server session.	This only returns a value during #handleRequest:"	^ ZnCurrentServerSession value isNotNil! !!ZnMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90726412!resetEntity: object	"Set my entity to object. Always set my content type and length as defined by object,	even if I am already describing an entity using my content type and length.	See also: #clearEntity"	(entity ~= object and: [ entity isNotNil ])		ifTrue: [ entity close ].	entity := object.	self headers acceptEntityDescription: object! !!ZnLoggingReadStream methodsFor: 'initialization' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90715797!initialize	super initialize.	logger := [ :string | string traceCr ].	identifier := self class name asString.	logLevel := 1! !!ZnLoggingReadStream methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnServerHandlerErrorEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90917093!printContentsOn: stream	super printContentsOn: stream.	stream << 'Server Handler Error ';  print: exception! !!ZnSimplifiedServerTransactionEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90962347!printContentsOn: stream	super printContentsOn: stream.	stream nextPutAll: method; space.	url printPathQueryFragmentOn: stream.	stream space; print: response.	size ifNotNil: [		stream space; print: size; nextPut: $B ].	stream space; print: duration; nextPutAll: 'ms'! !!ZnServerWriteErrorEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90948840!printContentsOn: stream	super printContentsOn: stream.	stream << 'Server Write Error ';  print: exception! !!ZnResponseReadEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90891417!printContentsOn: stream	super printContentsOn: stream.	stream << 'Response Read '; print: response; space; print: duration; << 'ms'! !!ZnMimePart methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90741188!hasEntity	^ self entity isNotNil! !!ZnMimePart methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90740702!hasHeaders	^ headers isNotNil and: [ self headers isEmpty not ]! !!ZnConnectionEstablishedEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90540003!printContentsOn: stream	super printContentsOn: stream.	stream << 'Connection Established '; nextPutAll: hostname asString; nextPut: $:; print: port.	proxy ifNotNil: [ stream << ' via proxy '; print: proxy ].	stream space.	self class printAddress: address on: stream.	stream nextPut: $:; print: port.	stream space; print: duration; << 'ms'! !!ZnServerSocketBoundEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90923268!printContentsOn: stream	super printContentsOn: stream.	stream << 'Server Socket Bound '.	self class printAddress: address on: stream.	stream nextPut: $:; print: port! !!ZnLogEvent class methodsFor: 'convenience' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90712432!logToTranscript	self stopLoggingToTranscript.	^ self announcer 		when: ZnLogEvent 		do: [ :event | self crTrace: event ]		for: self! !!ZnLogEvent class methodsFor: 'utilities' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!printAddress: address on: stream	"Try printing address as a IPv4 dotted address to stream.	If that fails, just print address as an object to stream."		[ address asSocketAddress printOn: stream ] on: Error do: [ stream print: address ]! !!ZnLogEvent methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90711706!id	"Return my numerical id or sequence number, unique in this image session."		^ id! !!ZnLogEvent methodsFor: 'initialization' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90711366!initialize	super initialize.	timestamp := DateAndTime now.	id := self nextId.	processId := ZnUtils currentProcessID! !!ZnLogEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!printHeaderOn: stream	"Print my generic context part, <date> <time> <seq-nr> <process> [ subclass addition], to stream"		timestamp printYMDOn: stream.	stream space.	timestamp printHMSOn: stream.	stream space.	id \\ 1000 printOn: stream base: 10 length: 3 padded: true.	stream space.	processId printOn: stream base: 10 length: 6 padded: true! !!ZnLogEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90710952!printOn: stream	self printHeaderOn: stream.	stream space.	self printContentsOn: stream! !!ZnLogEvent methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!processId	"Return a numeric process id"		^ processId! !!ZnLogEvent methodsFor: 'initialize' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!processId: anObject	processId := anObject! !!ZnLogEvent methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90711287!timestamp	"Return the point in time when I was created"	^ timestamp! !!ZnServerLogEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!printHeaderOn: stream	super printHeaderOn: stream.	serverId ifNotNil: [ stream space; << serverId asString ]! !!ZnTooManyRedirects methodsFor: 'private' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!defaultResumeValue	^ #retry! !!ZnTooManyRedirects methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!trail	^ trail! !!ZnTooManyRedirects methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!trail: aCollectionOfUrls	trail := aCollectionOfUrls! !!ZnSimplifiedClientTransactionEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90960155!printContentsOn: stream	super printContentsOn: stream.	stream nextPutAll: method; space.	url printPathQueryFragmentOn: stream.	stream space; print: response.	size ifNotNil: [		stream space; print: size; nextPut: $B ].	stream space; print: duration; nextPutAll: 'ms'! !!ZnClientRetryingEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90502700!printContentsOn: stream	super printContentsOn: stream.	stream << 'Retrying '; print: exception! !!ZnEntity methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90605242!hasContentLength	^ contentLength isNotNil! !!ZnEntity methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90605481!hasContentType	^ contentType isNotNil! !!ZnResponseWrittenEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90898127!printContentsOn: stream	super printContentsOn: stream.	stream << 'Response Written '; print: response; space; print: duration; << 'ms'! !!ZnServerTransactionEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90946986!printContentsOn: stream	super printContentsOn: stream.	request requestLine printMethodAndUriOn: stream.	stream space; print: response code.	response hasEntity		ifTrue: [			stream space; print: response entity contentLength; nextPut: $B ].	stream space; print: self duration; nextPutAll: 'ms'! !!ZnHtmlOutputStream methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnRequestLine methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90867718!printMethodAndUriOn: stream	(self method isNotNil and: [ self uri isNotNil ])		ifFalse: [ ^ self ].	stream		nextPutAll: self method;		space.	self uri printPathQueryFragmentOn: stream! !!ZnRequestLine methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90865333!printOn: stream	super printOn: stream.	(self method isNotNil and: [ self uri isNotNil ])		ifFalse: [ ^ self ].	stream nextPut: $(.	self printMethodAndUriOn: stream.	stream nextPut: $)! !!ZnServerGenericLogEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90916558!printContentsOn: stream	super printContentsOn: stream.	stream nextPutAll: subject asString! !!ZnServerStoppedEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90925099!printContentsOn: stream	super printContentsOn: stream.	description ifNotNil: [ stream << 'Stopped '; << description ]! !!ZnOptions methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90815720!at: key put: value	writable		ifFalse: [ (ModificationForbidden				for: self				at: key				with: value				retrySelector: #at:put:) signal ].	(parent isNotNil and: [ parent includesKey: key ])		ifFalse: [ KeyNotFound signalFor: key in: self ].	options ifNil: [ options := Dictionary new ].	^ options at: key put: value! !!ZnOptions methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90814698!includesKey: key	^ (options isNotNil and: [ options includesKey: key ])		or: [ parent isNotNil and: [ parent includesKey: key ] ]! !!ZnMultiThreadedServer methodsFor: 'private' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90791436!readRequestBadExceptionSet	"Return the set of exceptions which, when they occur while reading a request,	are interpreted as equivalent to a request parse error or bad request."	^ ZnUtils		exceptionSet:			#(#ZnParseError #ZnCharacterEncodingError #ZnUnknownScheme #ZnPortNotANumber #ZnTooManyDictionaryEntries #ZnEntityTooLarge)! !!ZnMultiThreadedServer methodsFor: 'private' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90789095!readRequestTerminationExceptionSet	"Return the set of exceptions which, when they occur while reading a request,	are interpreted as equivalent to a timeout or connection close."	^ ZnUtils		exceptionSet:			#(#ConnectionClosed #ConnectionTimedOut #SocketError #PrimitiveFailed)! !!ZnMultiThreadedServer methodsFor: 'private' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90790299!writeResponseTerminationExceptionSet	"Return the set of exceptions which, when they occur while writing a response,	are interpreted as equivalent to a timeout or connection close."	^ ZnUtils 		exceptionSet:			#(#ConnectionClosed #ConnectionTimedOut #SocketError #PrimitiveFailed)! !!ZnClientConnectionClosedEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90500273!printContentsOn: stream	super printContentsOn: stream.	stream << 'Connection Closed '.	self class printAddress: address on: stream.	stream nextPut: $:; print: port! !!ZnServerTransactionTiming methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!printOn: stream	super printOn: stream.	stream nextPut: $(; print: self totalDuration; nextPut: $)! !!ZnLimitedReadStream methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90700405!skip: count	count < 0 ifTrue: [ self error: 'cannot skip backwards' ].	count timesRepeat: [ self next ]! !!ZnByteArrayEntity methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90339426!printContentsOn: stream	super printContentsOn: stream.	self bytes ifNotNil: [		stream			space;			print: self bytes ]! !!ZnByteArrayEntity methodsFor: 'initialize-release' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90338481!readFrom: stream	self contentLength		ifNil: [			self bytes: (ZnUtils readUpToEnd: stream limit: (ZnCurrentOptions at: #maximumEntitySize)).			self contentLength: self bytes size ]		ifNotNil: [ | byteArray readCount |			self contentLength > (ZnCurrentOptions at: #maximumEntitySize)				ifTrue: [ ZnEntityTooLarge signal ].			byteArray := ByteArray ofSize: self contentLength.			readCount := self contentLength > ZnUtils streamingBufferSize				ifTrue: [ ZnUtils streamFrom: stream to: byteArray writeStream size: self contentLength ]				ifFalse: [ stream readInto: byteArray startingAt: 1 count: self contentLength ].			readCount = self contentLength 				ifTrue: [ self bytes: byteArray ]				ifFalse: [ self bytes: (byteArray copyFrom: 1 to: readCount); contentLength: readCount ] ]! !!ZnClientLogEvent methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!printHeaderOn: stream	super printHeaderOn: stream.	clientId ifNotNil: [ stream space; << clientId asString ]! !!ZnSingleThreadedServer methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90968936!isListening	"Return true when I have a valid server socket listening at the correct port"	^ self serverSocket isNotNil		and: [ self serverSocket isValid and: [ self serverSocket localPort = self port ] ]! !!ZnSingleThreadedServer methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90971577!isRunning	"Return true when I am running"	^ self process isNotNil and: [ self serverSocket isNotNil ]! !!ZnSingleThreadedServer methodsFor: 'private - logging' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90977218!logConnectionRejected: socketStream	logLevel < 3 ifTrue: [ ^ nil ].	^ (self newLogEvent: ZnConnectionRejectedEvent)		address: ([ socketStream socket remoteAddress ] on: Error do: [ nil ]);		emit! !!ZnSingleThreadedServer methodsFor: 'private - logging' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90978537!newLogEvent: logEventClass	^ logEventClass new		serverId: (self serverId ifNil: [ self route ]);		yourself! !!ZnSingleThreadedServer methodsFor: 'printing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90973202!printOn: stream	super printOn: stream.	stream nextPut: $(.	stream nextPutAll: (self isRunning ifTrue: [ 'running' ] ifFalse: [ 'stopped' ]).	self port ifNotNil: [ :port | stream space; print: port ].	self bindingAddress ifNotNil: [ :bindingAddress | stream space; print: bindingAddress ].	self serverId ifNotNil: [ :id | stream space; print: id ].	self route ifNotNil: [ :id | stream space; print: id ].	stream nextPut: $)! !!ZnSingleThreadedServer methodsFor: 'private' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90977009!serverProcessName	^ String streamContents: [ :stream |		stream nextPutAll: self class name; nextPutAll: ' HTTP port '; print: self port.		self serverId ifNotNil: [ :id | stream space; << id ].		self route ifNotNil: [ :id | stream space; << id ] ]! !!ZnCookie methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90549203!isInDomain: urlObject	| domain |	domain := (self domain beginsWith: '.')		ifTrue: [ self domain allButFirst ]		ifFalse: [ self domain ].	^ urlObject host includesSubstring: domain! !ZnClientLogEvent removeSelector: #printContentsOn:!ZnConstants class removeSelector: #frameworkMCVersion!ZnClient removeSelector: #executeWithRedirectsRemaining:!ZnMultiThreadedServer removeSelector: #exceptionSet:!ZnServerLogEvent removeSelector: #processId:!ZnServerLogEvent removeSelector: #processId!ZnServerLogEvent removeSelector: #printContentsOn:!"Zinc-HTTP"!!ZnProxyServerDelegate commentStamp: '<historical>' prior: 0!I am a ZnDelegate that acts as a proxy.I handle requests by passing them to a proxyBlock which can change the request before I execute it.The idea is that the changed request is to a different server, the one that we proxy.Usage example	| proxiedServer proxyServer proxyDelegate client  |	proxiedServer := ZnServer startOn: 8080.	proxyServer := ZnServer on: 9090.	proxyDelegate := ZnProxyServerDelegate new		server: proxyServer;		proxyBlock: [ :request | 			request url: (request url port: 8080) ].	proxyServer		delegate: proxyDelegate;		start.	client := ZnClient new.	client get: proxyServer url / #echo.!!ZnStaticFileServerDelegateTest methodsFor: 'tests' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90994815!testBasicGetWide	self withServerDo: [ :server | | client |		(client := ZnClient new)			beOneShot;			url: server localUrl;			addPath: #('local-files' 'wide.html');			get.		self assert: client isSuccess.		self assert: client response contentType = ZnMimeType textHtml.		self assert: client contents equals: self wideHtml.		self			assert: (ZnUtils parseHttpDate: (client response headers at: 'Modification-Date'))			equals: (ZnFileSystemUtils modificationTimeFor: 'wide.html') asUTC.		self			assert: (ZnUtils parseHttpDate: (client response headers at: 'Expires')) > (DateAndTime now + 10 days).		self			assert: (client response headers at: 'Cache-Control')			equals: (server delegate maxAgeFor: ZnMimeType textHtml) ]! !!ZnProxyServerDelegateTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testEcho	| proxiedServer proxyServer proxyDelegate client  |	proxiedServer := ZnServer startOn: 8080.	proxyServer := ZnServer on: 9090.	proxyDelegate := ZnProxyServerDelegate new		server: proxyServer;		proxyBlock: [ :request | 			request url: (request url port: 8080) ].	proxyServer		delegate: proxyDelegate;		start.	client := ZnClient new.	client get: proxyServer url / #echo.	self assert: client isSuccess.	self assert: (client contents includesSubstring: 'echoing').	self assert: (client contents includesSubstring: 'running 8080').	proxiedServer stop.	proxyServer stop! !!ZnImageExampleDelegate methodsFor: 'request handling' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90685632!handlePostRequest: request	"POST /image <multipart form data with file part> - change the image and show the result.	Do full error checking before accepting the newly uploaded image"	| part newImage badRequest |	badRequest := [ ^ ZnResponse badRequest: request ].	(request hasEntity and: [ request contentType matches: ZnMimeType multiPartFormData ])		ifFalse: badRequest.	part := request entity		partNamed: #file		ifNone: badRequest.	newImage := part entity.	(newImage isNotNil and: [ newImage contentType matches: 'image/*' asZnMimeType ])		ifFalse: badRequest.	[ self formForImageEntity: newImage ] on: Error do: badRequest.	image := newImage.	^ ZnResponse redirect: #image! !!ZnProxyServerDelegate methodsFor: 'private' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!augmentUrl: aUrl	"The URL in a server request has no scheme, host or port set.	Augment aUrl by taking those elements from #serverUrl"	self server ifNil: [ ^ aUrl ].	^ aUrl inContextOf: self server url! !!ZnProxyServerDelegate methodsFor: 'private' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!copyAndPrepareRequest: aRequest	"We make a copy of the request and augment its URL"	| copiedRequest |	copiedRequest := aRequest copy.	copiedRequest url: (self augmentUrl: copiedRequest url).	^ copiedRequest! !!ZnProxyServerDelegate methodsFor: 'public' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!handleRequest: incomingRequest	"Ask our proxy block to transform a incoming ZnRequest copy into an outgoing ZnRequest"	| outgoingRequest |	outgoingRequest := self proxyBlock 		cull: (self copyAndPrepareRequest: incomingRequest) 		cull: self server.	^ ZnClient new		request: outgoingRequest;		beOneShot;		execute;		response! !!ZnProxyServerDelegate methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!proxyBlock	^ proxyBlock! !!ZnProxyServerDelegate methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!proxyBlock: aBlock	"Set the block that transforms a copy of the incoming ZnRequest to the outgoing ZnRequest.	Two parameters are passed to block: the request and an optional server reference.	See #copyAndPrepareRequest: for how the request got changed."	proxyBlock := aBlock! !!ZnProxyServerDelegate methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!server	^ server! !!ZnProxyServerDelegate methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!server: aZnServer	"Set areference to the server we're in (optional)"	server := aZnServer! !!ZnStaticFileServerDelegate methodsFor: 'private' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90986901!actualFilenameFor: uri	| subElements subDir entry |	(uri isEmpty and: [ self prefix isEmpty ]) ifTrue: [ ^ self indexFileIn: self directory ].	(self prefix isEmpty or: [ uri isEmpty not and: [ uri pathSegments beginsWith: self prefix ] ]) ifFalse: [ ^ nil ].	subElements := (uri pathSegments allButFirst: self prefix size) reject: [ :each | each = $/ ].	subDir := (subElements ifNotEmpty: #allButLast ifEmpty: [ #() ]) 		inject: self directory 		into: [ :parent :sub | | file |			(file := parent / sub) exists				ifTrue: [ file ]				ifFalse: [ ^ nil ] ]. 	subElements isEmpty		ifTrue: [ entry := subDir entry ]		ifFalse: [ | file |			 (file := subDir / subElements last) exists				ifTrue: [ entry := file entry ]				ifFalse: [ ^ nil ] ].	^ entry isDirectory		ifTrue: [ self indexFileIn: entry reference ]		ifFalse: [ entry reference fullName ]! !!ZnStaticFileServerDelegate methodsFor: 'public' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90988966!handleRequest: request	"Server delegate entry point"	| actualFilename |	(#( #GET #HEAD ) includes: request method) ifFalse: [		^ ZnResponse methodNotAllowed: request ].	actualFilename := self actualFilenameFor: request uri.	^ actualFilename		  ifNotNil: [			  (self				   redirectNeededFor: request uri				   actualFilename: actualFilename)				  ifTrue: [ self directoryRedirectFor: request uri ]				  ifFalse: [				  self responseForFile: actualFilename fromRequest: request ] ]		  ifNil: [ ZnResponse notFound: request uri ]! !"Zinc-HTTP-Examples"!!ZnEntityTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90622973!testMultiPartFormDataWriteRead	| input output bytes |	input := ZnMultiPartFormDataEntity new		addPart: (ZnMimePart fieldName: 'extra' value: 'my-extra');		addPart: (ZnMimePart fieldName: 'info' value: 'my-info');		addPart: (ZnMimePart fieldName: 'file' fileName: 'foo.txt' entity: (ZnEntity text: 'Zinc HTTP Components'));		yourself.	self assert: input contentLength isNotNil.	self assert: input contentLength > 0.	self assert: (input contentType matches: ZnMimeType multiPartFormData).	bytes := ByteArray streamContents: [ :stream | input writeOn: stream ].	output := (ZnMultiPartFormDataEntity type: input contentType) readFrom: bytes readStream.	self assert: (output partNamed: 'extra') fieldValue equals: 'my-extra'.	self assert: (output partNamed: 'info') fieldValue equals: 'my-info'.	self assert: (output partNamed: 'extra') fieldValueString equals: 'my-extra'.	self assert: (output partNamed: 'info') fieldValueString equals: 'my-info'.	self assert: (output partNamed: 'file') contents equals: 'Zinc HTTP Components'.	output := (ZnMultiPartFormDataEntity type: input contentType length: input contentLength) readFrom: bytes readStream.	self assert: (output partNamed: 'extra') fieldValue equals: 'my-extra'.	self assert: (output partNamed: 'info') fieldValue equals: 'my-info'.	self assert: (output partNamed: 'extra') fieldValueString equals: 'my-extra'.	self assert: (output partNamed: 'info') fieldValueString equals: 'my-info'.	self assert: (output partNamed: 'file') contents equals: 'Zinc HTTP Components'! !!ZnEntityTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90624564!testMultiPartFormDataWriteReadBinary	| input output bytes |	input := ZnMultiPartFormDataEntity new		addPart: (ZnMimePart fieldName: 'extra' value: 'my-extra');		addPart: (ZnMimePart fieldName: 'info' value: 'my-info');		addPart: (ZnMimePart fieldName: 'file' fileName: 'foo.txt' entity: (ZnEntity text: 'Zinc HTTP Components'));		yourself.	self assert: input contentLength isNotNil.	self assert: input contentLength > 0.	self assert: (input contentType matches: ZnMimeType multiPartFormData).	bytes := ByteArray streamContents: [ :stream | input writeOn: stream ].	output := ZnEntity readBinaryFrom: bytes readStream usingType: input contentType andLength: bytes size.	self assert: (output partNamed: 'extra') fieldValue equals: 'my-extra' asByteArray.	self assert: (output partNamed: 'info') fieldValue equals: 'my-info' asByteArray.	self assert: (output partNamed: 'extra') fieldValueString equals: 'my-extra'.	self assert: (output partNamed: 'info') fieldValueString equals: 'my-info'.	self deny: (output partNamed: 'file') contents isString.	self assert: (output partNamed: 'file') contents equals: 'Zinc HTTP Components' asByteArray! !!ZnUrlTest methodsFor: '*Zinc-Tests' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testFragmentWithQuestionMark	| urlString url |	urlString := 'http://www.example.com/#fragment?with?question?mark'.	url := urlString asUrl.	self assert: url segments isNil.	self deny: url hasQuery.	self assert: url asString equals: urlString! !!ZnChunkedStreamTest class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!defaultTimeLimit	^15 seconds! !!ZnChunkedStreamTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90448246!testGzipWriteRead	| data written read |	data := (String loremIpsum: 16*1024) utf8Encoded.	written := ByteArray streamContents: [ :out |		| stream chunkedStream |		stream := GZipWriteStream on: (chunkedStream := ZnChunkedWriteStream on: out).		stream nextPutAll: data.		stream finish.		chunkedStream finish ].	read := (GZipReadStream on: (ZnChunkedReadStream on: written readStream)) upToEnd.	self assert: read equals: data! !!ZnServerTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90942627!testDefault	| port server initialDefaultServer wasRunning |	wasRunning := ZnServer default ifNil: [ false ] ifNotNil: [ ZnServer default isRunning ].	initialDefaultServer := ZnServer stopDefault.	self assert: ZnServer default isNil.	port := self port.	server := ZnServer startDefaultOn: port.	self assert: ZnServer default isNotNil.	self assert: ZnServer default identicalTo: server.	self assert: ZnServer default port equals: port.	self assert: ZnServer default isRunning.	self assert: (ZnServer managedServers includes: server).	ZnServer stopDefault.	self assert: ZnServer default isNil.	self deny: server isRunning.	self deny: (ZnServer managedServers includes: server).	server := ZnServer startDefaultOn: port.	"Starting the default again is actually a restart"	ZnServer startDefaultOn: port.	self assert: ZnServer default identicalTo: server.	ZnServer stopDefault.	ZnServer adoptAsDefault: initialDefaultServer.	self assert: initialDefaultServer identicalTo: ZnServer default.	wasRunning ifTrue: [ ZnServer default start ]! !!ZnServerTest methodsFor: 'tests' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testLogging	| client logEventCollection count renderedLogEvents |	logEventCollection := OrderedCollection new.	ZnLogEvent announcer		when: ZnLogEvent		do: [ :event | logEventCollection add: event ]		for: self.	self withServerDo: [ :server |		1 to: 3 do: [ :logLevel |			server				serverId: 'S' , logLevel asString;				logLevel: logLevel.			client := ZnClient new.			client				clientId: 'C' , logLevel asString;				logLevel: logLevel.			client get: (server localUrl addPathSegment: #small).			self assert: client isSuccess.			client get: (server localUrl addPathSegment: #error).			self deny: client isSuccess.			server delegate				map: #redirect				to: [ :request | ZnResponse redirect: #welcome ].			client get: (server localUrl addPathSegment: #redirect).			self assert: client isSuccess.			client close ] ].	count := ZnLogEvent announcer numberOfSubscriptions.	ZnLogEvent announcer unsubscribe: self.	self		assert: ZnLogEvent announcer numberOfSubscriptions		equals: count - 1.	self deny: logEventCollection isEmpty.	renderedLogEvents := String streamContents: [ :out |		                     logEventCollection do: [ :event |			                     out				                     print: event;				                     cr ] ].	self deny: renderedLogEvents isEmpty! !!ZnServerTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90931338!testTooManyConcurrentConnections	self usingClassicSocketStreamsOnWindowsDo: [		self withServerDo: [ :server | | client clients |			self deny: server debugMode.			server maximumNumberOfConcurrentConnections: 4.			clients := (1 to: 4) collect: [ :each |				ZnClient new					url: server localUrl;					addPathSegment: #random;					clientId: ('client-{1}' format: { each });					enforceHttpSuccess;					get;					yourself ].			client := ZnClient new					url: server localUrl;					addPathSegment: #random;					clientId: 'client-5';					get;					yourself.			self assert: client response code equals: 503.			clients do: [ :each |				each get; close ].			client get.			self assert: client isSuccess.			client close ] ]! !!ZnMagicCookieTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90720153!testFromString	| cookie |	cookie := ZnCookie fromString: self cookieString for: 'www.google.com' asZnUrl.	self assert: cookie name equals: 'PREF'.	self assert: cookie path isNotNil.	self assert: cookie domain equals: '.google.com'.	self assert: cookie isExpired not! !!ZnUserAgentSessionTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91104988!testAccessors	| session |	session := ZnUserAgentSession new.	self assert: (session cookieJar isKindOf: ZnCookieJar).	self assert: (session credentials isNotNil)! !!ZnUserAgentSessionTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91104834!testWithCookieJar	self assert: ((ZnUserAgentSession withCookieJar: ZnCookieJar new) isNotNil)! !!ZnClientTest class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!defaultTimeLimit	^ 60 seconds! !!ZnClientTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90527222!testLogging	| client logEventCollection count |	logEventCollection := OrderedCollection new.	ZnLogEvent announcer		when: ZnLogEvent		do: [ :event | logEventCollection add: event ]		for: self.	(client := ZnClient new)		clientId: #C1;		beOneShot.	client get: self smallHtmlUrl.	client close.	count := ZnLogEvent announcer numberOfSubscriptions.	ZnLogEvent announcer unsubscribe: self.	self		assert: ZnLogEvent announcer numberOfSubscriptions		equals: count - 1.	self deny: logEventCollection isEmpty.	self assert: logEventCollection anyOne clientId equals: #C1! !!ZnClientTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90504054!testQueryGoogle	| client |		(client := ZnClient new)		http;		host: 'www.google.com';		addPath: 'search';		queryAt: 'q' put: 'Pharo Smalltalk';		retryDelay: 20;		numberOfRetries: 3;		get.		[			self 			assert: (client isSuccess or: [client response code = 429])			description: ('Response should be success or 429 code. [{1}] received' format: {				client response  statusLine}).		self 			assert: (client response contentType matches: ZnMimeType textHtml)			description: 'Response has content type html'.		client isSuccess  ifTrue: [			self 				assert: (client contents includesSubstring: 'pharo.org')				description: 'Response incudes string pharo.org' ]	] ensure: [ client close ]! !!ZnClientTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90528715!testRedirect	| client response target |	target := 'http://zn.stfx.eu'.	client := ZnClient new url: target.	client get.	self assert: client isSuccess.	client		close;		maxNumberOfRedirects: 0;		url: target.	self should: [ client get ] raise: ZnTooManyRedirects.	client close.	response := [		ZnClient new			beOneShot;			maxNumberOfRedirects: 0;			get: target;			response ] on: ZnTooManyRedirects do: [ :exception | exception resume: #doNotRetry ].	self assert: response isRedirect! !!ZnClientTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testRedirectLoopAndTrail	self withServerDo: [ :server | | client count |		server onRequestRespond: [ :request |			request uri firstPathSegment = 'follow'				ifTrue: [ ZnResponse redirect: 'follow' ] ].		(client := ZnClient new)			url: server localUrl; addPath: 'follow';			maxNumberOfRedirects: 10.		self should: [ client get ] raise: ZnTooManyRedirects.		client close.		(client := ZnClient new)			url: server localUrl; addPath: 'follow';			maxNumberOfRedirects: 10.		[ client get ] on: ZnTooManyRedirects do: [ :exception |			self assert: exception isResumable.			self assert: exception trail size equals: 10.			self assert: (exception trail allSatisfy: [ :each | each = (server localUrl / 'follow') ]) ].		client close.				(client := ZnClient new)			url: server localUrl; addPath: 'follow';			maxNumberOfRedirects: 10.		count := 0.		[ client get ] on: ZnTooManyRedirects do: [ :exception |			count := count + 1.			exception trail size <= 30				ifTrue: [ exception resume ]				ifFalse: [ exception resume: #doNotRetry ] ].		self assert: count equals: 4.		client close ]! !!ZnClientTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90522215!testRedirectWithCookies	self withServerDo: [ :server | | client cookie |		server onRequestRespond: [ :request |			request uri firstPathSegment = 'one'				ifTrue: [					(ZnResponse redirect: 'two')						addCookie: (ZnCookie name: 'session' value: '123456');						yourself ]				ifFalse: [					cookie := request cookies detect: [ :each | each name = 'session' ] ifNone: [ nil ].					(request uri firstPathSegment = 'two' and: [ cookie isNotNil and: [ cookie value = '123456' ] ])						ifTrue: [ ZnResponse ok: (ZnEntity text: 'OK!!') ]		 				ifFalse: [ ZnResponse badRequest: request ] ] ].		(client := ZnClient new)			url: server localUrl; addPath: 'one';			post.		self assert: client isSuccess.		self assert: client contents equals: 'OK!!'.		client close ]! !!ZnRequestTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90872305!testCookiesParsing	| input request cookies testCookie1 testCookie2 |	input := 'GET /foo.html HTTP/1.1', String crlf,		'Cookie: testCookie1=123; testCookie2=321', String crlf,		'Host: foo.com', String crlf,		'Agent: SUnit', String crlf,		String crlf.	request := ZnRequest readFrom: input readStream.	cookies := request cookies.	testCookie1 := cookies detect: [ :each | each name = 'testCookie1' ].	testCookie2 := cookies detect: [ :each | each name = 'testCookie2' ].	self assert: testCookie1 isNotNil.	self assert: testCookie1 value equals: '123'.	self assert: testCookie2 isNotNil.	self assert: testCookie2 value equals: '321'.! !!ZnMagicCookieJarTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90717572!testCookieAtForUrl	| jar c1 c2 |	jar := ZnCookieJar new.	c1 := ZnCookie fromString: self cookieString for: 'http://www.google.com' asZnUrl.	c2 := ZnCookie fromString: self cookieStringAlt for: 'http://www.pharo-project.org' asZnUrl.	jar add: c1; add: c2.	self assert: ((jar cookieAt: 'PREF' forUrl: 'http://www.google.com' asZnUrl) isNotNil).	self assert: ((jar cookieAt: 'foobar' forUrl: 'http://www.google.com' asZnUrl) isNil)! !!ZnLogEventTest methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!clientId	^ 'client-1'! !!ZnLogEventTest methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!request	^ ZnRequest get: 'http://foo.com/test'! !!ZnLogEventTest methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!response	^ ZnResponse ok: (ZnEntity text: 'OK')! !!ZnLogEventTest methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!serverId	^ 'server-1'! !!ZnLogEventTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testClientTransactionEvent	| event |	(event := ZnClientTransactionEvent new)		clientId: self clientId;		request: self request;		response: self response;		requestDuration: self timing requestDuration;		responseDuration: self timing responseDuration.	self assert: event id isInteger.	self assert: event processId isInteger.	self assert: event timestamp <= DateAndTime now.	self assert: event clientId equals: self clientId.	self assert: event request uri equals: self request uri.	self assert: event request method equals: self request method.	self assert: event response code equals: self response code.	self assert: event duration equals: self timing requestDuration + self timing responseDuration.	self assert: event printString isString.	^ event! !!ZnLogEventTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testServerTransactionEvent	| event |	(event := ZnServerTransactionEvent new)		serverId: self serverId;		request: self request;		response: self response;		timing: self timing.	self assert: event id isInteger.	self assert: event processId isInteger.	self assert: event timestamp <= DateAndTime now.	self assert: event serverId equals: self serverId.	self assert: event request uri equals: self request uri.	self assert: event request method equals: self request method.	self assert: event response code equals: self response code.	self assert: event duration equals: self timing totalDuration.	self assert: event printString isString.	^ event! !!ZnLogEventTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testSimplifiedClientTransactionEvent	| event |	(event := ZnSimplifiedClientTransactionEvent new)		clientId: self clientId;		request: self request;		response: self response;		requestDuration: self timing requestDuration;		responseDuration: self timing responseDuration.	self assert: event id isInteger.	self assert: event processId isInteger.	self assert: event timestamp <= DateAndTime now.	self assert: event clientId equals: self clientId.	self assert: event url equals: self request uri.	self assert: event method equals: self request method.	self assert: event responseCode equals: self response code.	self assert: event size equals: self response contentLength.	self assert: event duration equals: self timing requestDuration + self timing responseDuration.	self assert: event printString isString.	^ event! !!ZnLogEventTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!testSimplifiedServerTransactionEvent	| event |	(event := ZnSimplifiedServerTransactionEvent new)		serverId: self serverId;		request: self request;		response: self response;		timing: self timing.	self assert: event id isInteger.	self assert: event processId isInteger.	self assert: event timestamp <= DateAndTime now.	self assert: event serverId equals: self serverId.	self assert: event url equals: self request uri.	self assert: event method equals: self request method.	self assert: event responseCode equals: self response code.	self assert: event size equals: self response contentLength.	self assert: event duration equals: self timing totalDuration.	self assert: event printString isString.	^ event! !!ZnLogEventTest methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34'!timing	^ ZnServerTransactionTiming new			requestDuration: 1;			responseDuration: 2;			yourself! !!ZnUtilsTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91117624!testDefaultJSONReader	"System should provide a JSON parser"	| reader expectedParserClass |	reader := ZnUtils defaultJSONReader.	expectedParserClass := self class environment at: #NeoJSONObject ifAbsent: [		          self class environment at: #STONJSON ifAbsent:[nil]].	self assert: reader isNotNil.	self assert: reader equals: expectedParserClass! !!ZnUtilsTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 91114169!testDefaultJSONWriter	"System should provide a JSON parser"	| writer expectedParserClass |	writer := ZnUtils defaultJSONWriter.	expectedParserClass := self class environment at: #NeoJSONWriter ifAbsent: [		          self class environment at: #STONJSON ifAbsent:[nil]].	self assert: writer isNotNil.	self assert: writer equals: expectedParserClass! !"Zinc-Tests"!!ZnSecureServer commentStamp: '' prior: 0!I am ZnSecureServer, an implementation of an HTTPS server.I am a ZnMultiThreadedServer(ZnSecureServer on: 1443)	certificate: '/home/sven/ssl/key-cert.pem';	logToTranscript;	start;	yourself.	Disclaimer: this is an experimental proof of concept.!!ZnSecureServer methodsFor: 'accessing'!certificate	^ certificate! !!ZnSecureServer methodsFor: 'accessing'!certificate: anObject	certificate := anObject! !!ZnSecureServer methodsFor: 'accessing'!scheme	^ #https! !!ZnSecureServer methodsFor: 'private'!socketStreamOn: socket	| stream |	stream := ZdcSecureSocketStream on: socket.	stream sslSession certificateName: self certificate.	stream accept.	^ stream! !"Zinc-Zodiac-Core"!!ZnHTTPSTest class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90651718!defaultTimeLimit	^60 seconds! !!ZnHTTPSTest methodsFor: 'private' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90650992!ensureSocketStreamFactory	self 		assert: ZnNetworkingUtils default secureSocketStreamClass isNotNil		description: 'Please set a secure socket stream class in ZnNetworkingUtils default or switch to the ZnZodiacNetworkingUtils socket stream factory'! !!ZnHTTPSTest methodsFor: 'testing' stamp: 'CompatibleUserName 8/31/2024 04:18:34' prior: 90648808!testGoogleEncrypted	| client |	self ensureSocketStreamFactory.	self isNativeSSLPluginPresent ifFalse: [ ^ self ].		client := ZnClient new.	client		retryDelay: 1;		numberOfRetries: 3;		get: 'https://encrypted.google.com/search?q=Smalltalk'.		[ 		self 			assert: (client isSuccess or: [client response code = 429])			description: ('Response should be success or 429 code. [{1}] received' format: {				client response  statusLine}).		self 			assert: (client contents includesSubstring: 'Google')			description: 'Response includes string google'.    		client isSuccess  ifTrue: [			self 				assert: (client contents includesSubstring: 'Smalltalk')				description: 'Response includes string Smalltalk ' ]	] ensure: [		client close ]! !"Zinc-Zodiac-Tests"!!TeaNoSuchParam commentStamp: '' prior: 0!This exception indicates that the given parameter was not found in the TeaRequest.!!TeaAbort commentStamp: '' prior: 0!I'm an exception that immediately stops a request within a filter or route.!!IsObject commentStamp: '' prior: 0!I'm the base class of the type constraints. I match to any object. My subclasses can restict the type of placeholders.Example:Teapot on	GET: '/user/<id:IsInteger>' -> [:req | users findById: (req at: #id)];	start.This route matches to the '/users/12' but does not match to '/users/foobar'. In case of matching, the the path paramter "id" will be converted to an integer.You can extend the built in type constraints with your own constraints, by implementing the "placeholder type constraint" protocol. Then you can use the class name in the URL.!!IsInteger commentStamp: '' prior: 0!I'm a type constraint that matches to positive or negative integers.!!IsNumber commentStamp: '' prior: 0!I'm a type constraint that matches to positive or negative floats or integers.!!IsUUID commentStamp: '' prior: 0!I'm a type constraint that matches to an UUID.!!Send commentStamp: '' prior: 0!I can send messages to objects on a http requests. The selector of the message can take maximum 2 arguments ( TeaRequest and TeaResponse).Example:Teapot on	GET: '/hi' -> (Send message: #greet to: controller);	start.	!!TeaErrorHandler commentStamp: '' prior: 0!An error handler handles Exceptions signaled by the Routes or before actions.!!TeaFilter commentStamp: '' prior: 0!After and Before filters!!TeaAfterFilter commentStamp: '' prior: 0!An after filter is evaluated after each (matching) request. This filter has access to the response object generated by the matching route. The response can be modified from the filter, e.g. addition headers can be added.!!TeaBeforeFilter commentStamp: '' prior: 0!A before filter is evaluated before (matching) each request. This filter has access to the request object. For example, a before filter can be used to validate session attributes for authentication.!!TeaGlobUrlSegment commentStamp: '' prior: 0!My subclasses form the elements of TeaGlobUrlPatterns!!TeaLiteral commentStamp: '' prior: 0!A literal url pattern segment that matches to a string.!!TeaLiteralStop commentStamp: '' prior: 0!I'm a placeholder at the last position.!!TeaPlaceholder commentStamp: '' prior: 0!I'm a placeholder with a key. My content is substituted with a value.!!TeaPlaceholderStop commentStamp: '' prior: 0!I'm a placeholder at the last position.!!TeaWildcard commentStamp: '' prior: 0!A wildcard url pattern segment that matches to anything.!!TeaWildcardStop commentStamp: '' prior: 0!I'm a Wildcard at the last position.!!TeaMethodMatcher commentStamp: '' prior: 0!I can be matched against an HTTP method. I will return either true or false.!!TeaNotFoundHandler commentStamp: '' prior: 0!I decides what response to return when there were not matching routes (and no static path) for the incoming request. By default I just return 404.!!Tea405AwareNotFoundHandler commentStamp: '' prior: 0!I'm a smarter not found handler that returns 405 instead of 404 when the url part of some routes matched but the HTTP method didn't.!!TeaOutput commentStamp: '' prior: 0!I have various response transformer methods on my class side, that can be used as follows:Teapot on	GET: '/books' -> books; output: #json;	start.	Some of the transformers require optional dependencies, like Neo-JSON, STON, or Mustache.!!TeaPadding commentStamp: '' prior: 0!An url is padded by me, if its size is to short. I don't match to any literal URL, so it's like I'm not there.!!TeaRequest commentStamp: '' prior: 0!I extend the ZnRequest with addition methods for convenience.!!TeaRequestMatcher commentStamp: '' prior: 0!I can be matched against a ZnRequest. I check the http method and url of the request. !!TeaResponse commentStamp: '' prior: 0!A TeaResponse represents an HTTP response returned by a Route. The ZnResponse is generated from the TeaResponse by the given response transformer.!!TeaRoute commentStamp: '' prior: 0!A route handles http requests if it matches to the route. I have four major parts.- A handler that can be a block, a value or a message send.- An url pattern that can be matched against actual urls.- An http method that can be matched against the actual http method.- A response transformer for creating ZnResponse from the object returned by the handler.!!TeaRouter commentStamp: '' prior: 0!A zn delegate baseclass!!TeaCompositeRouter commentStamp: '' prior: 0!I'm a composite zn delegate, built from other zn delegates. I forward the request to the first delegate that returns other than 404 as response. Errors are handled with the help of the registered error handlers.!!TeaDynamicRouter commentStamp: '' prior: 0!I'm a ZnDelegate. I serve dynamically generated contents. The request is handled by the first route object, that returns other than 404 as response.!!TeaStaticRouter commentStamp: '' prior: 0!I'm a ZnDelegate based on ZnStaticFileServerDelegate. I serve static content from a file system directory.!!TeaUrlPattern commentStamp: '' prior: 0!An URL pattern can be matched agains actual urls. The pattern may collect named parameters from the URL in case of match.!!TeaGlobUrlPattern commentStamp: '' prior: 0!An UrlPattern is made from segments. I can be matched against an actual URL. '*' and <named-parameters> can be used inside the pattern.I can parse the pattern from a string by saying:	self parseString: '/foo/*/<id>/bar'Which will create a pattern that matches to an URL like this: 	/foo/xyz/12/bar!!TeaRxUrlPattern commentStamp: '' prior: 0!I'm an URL pattern that uses a regular expression internally. I collect subexpressions in case of matching.!!TeaUrlPatternSet commentStamp: '' prior: 0!I match to the given url if any of my elements match.E.g.Teapot on	GET: {'/a'. '/b'} -> 'ab';	start.		Both ZnEasy get: '/a' and ZnEasy get: '/b' returns 'ab'!!Teapot commentStamp: '' prior: 0!I'm the Teapot server on top of ZnServer. I can handle URL routing as follows:Teapot on      GET: '/hi' -> 'Hello World!!';      GET: '/a/*/b' -> (Send message: #ab: to: controller);      GET: '/users' -> [ users ]; output: #json	      GET: '/user/<id>' -> [ :req | (req at: #id) ]; output: #ston;      PUT: '/books/<id>' -> [ :req | | book |	  book := Book author: (req at: #author) title: (req at: #title).        books at: (req at: #id) put: book ]; 	  output: #ston;      start.For more configuration option see the Teapot class>>configure method.!!ZnResponse methodsFor: '*Teapot-Core'!teaTransform: aResponseTransformer request: aTeaRequest	^ self! !!RxMatcher methodsFor: '*Teapot-Core'!asTeaUrlPattern	^ TeaRxUrlPattern fromRxMatcher: self! !!String methodsFor: '*Teapot-Core'!asTeaUrlPattern	^ TeaGlobUrlPattern parseString: self! !!TeaNoSuchParam class methodsFor: 'signaling'!signalWithParam: aSymbol	(self new setParam: aSymbol) signal: 'Param ', aSymbol printString, ' not found'! !!TeaNoSuchParam methodsFor: 'accessing'!param	^ param! !!TeaNoSuchParam methodsFor: 'initialization'!setParam: aSymbol	param := aSymbol.	^ self! !!TeaAbort class methodsFor: 'instance creation'!response: aZnResponse	^ self new setResponse: aZnResponse! !!TeaAbort methodsFor: 'converting'!response	^ response! !!TeaAbort methodsFor: 'initialization'!setResponse: aZnResponse	response := aZnResponse.	^ self! !!BlockClosure methodsFor: '*Teapot-Core'!teaEvalActionOnException: anException request: aTeaRequest	^ self cull: anException cull: aTeaRequest! !!BlockClosure methodsFor: '*Teapot-Core'!teaEvalActionOnRequest: aTeaRequest	^ self cull: aTeaRequest! !!BlockClosure methodsFor: '*Teapot-Core'!teaEvalActionOnRequest: aTeaRequest response: aZnResponse	^ self cull: aTeaRequest cull: aZnResponse! !!IsInteger class methodsFor: 'type constraint'!matchesTo: aString	^ '-?\d+' asRegex matches: aString! !!IsInteger class methodsFor: 'type constraint'!parseString: aString	^ aString asInteger! !!IsNumber class methodsFor: 'type constraint'!matchesTo: aString	Number readFrom: aString ifFail: [ ^false ].	^ true! !!IsNumber class methodsFor: 'type constraint'!parseString: aString	^ aString asNumber! !!IsObject class methodsFor: 'type constraint'!matchesTo: aString	^ true! !!IsObject class methodsFor: 'type constraint'!parseString: aString	^ aString! !!IsUUID class methodsFor: 'type constraint'!matchesTo: aString	^ '[0-9a-f]{8}\-[0-9a-f]{4}\-[0-9a-f]{4}\-[0-9a-f]{4}\-[0-9a-f]{12}' asRegex matches: aString! !!IsUUID class methodsFor: 'type constraint'!parseString: aString	^ UUID fromString: aString! !!Object methodsFor: '*Teapot-Core'!teaEvalActionOnException: anException request: aTeaRequest	^ self! !!Object methodsFor: '*Teapot-Core'!teaEvalActionOnRequest: aTeaRequest	^ self! !!Object methodsFor: '*Teapot-Core'!teaTransform: aResponseTransformer request: aTeaRequest	^ aResponseTransformer cull: (TeaResponse ok body: self) cull: aTeaRequest! !!Send class methodsFor: 'instance creation'!message: aSymbol to: anObject	^ self new 		setSelector: aSymbol 		receiver: anObject! !!Send methodsFor: 'printing'!printOn: aStream	aStream 		nextPutAll: '(Send message: ';		nextPutAll: selector printString;		nextPutAll: ' to: '.	receiver printOn: aStream.	aStream nextPut: $)! !!Send methodsFor: 'initialization'!setSelector: aSymbol receiver: anObject	selector := aSymbol.	receiver := anObject.	^ self	! !!Send methodsFor: 'tea action'!teaEvalActionOnException: anException request: aTeaRequest	^ receiver 		perform: selector 		withEnoughArguments: { anException. aTeaRequest }	! !!Send methodsFor: 'tea action'!teaEvalActionOnRequest: aTeaRequest	^ receiver 		perform: selector 		withEnoughArguments: { aTeaRequest }	! !!Send methodsFor: 'tea action'!teaEvalActionOnRequest: aTeaRequest response: aZnResponse	^ receiver 		perform: selector 		withEnoughArguments: { aTeaRequest. aZnResponse }	! !!TeaErrorHandler class methodsFor: 'instance creation'!for: anExceptionSet action: aTeaAction responseTransformer: aResponseTransformer	^ self new 		setExceptions: anExceptionSet 		action: aTeaAction 		responseTransformer: aResponseTransformer! !!TeaErrorHandler methodsFor: 'error handler'!canHandleError: anException	^ exceptions handles: anException! !!TeaErrorHandler methodsFor: 'error handler'!handleError: anException request: aTeaRequest	| result |	^ (self canHandleError: anException)		ifTrue:			[ result := action teaEvalActionOnException: anException request: aTeaRequest.			result teaTransform: responseTransformer request: aTeaRequest ]		ifFalse: 			[ self error: 'Cannot handle ', anException printString ]! !!TeaErrorHandler methodsFor: 'error handler'!responseTransformer: aResponseTransformer 	responseTransformer := aResponseTransformer! !!TeaErrorHandler methodsFor: 'initialization'!setExceptions: anExceptionSet action: aTeaAction responseTransformer: aResponseTransformer	exceptions := anExceptionSet.	action := aTeaAction.	responseTransformer := aResponseTransformer.	^ self! !!TeaAfterFilter methodsFor: 'response handling'!handleRequest: aZnRequest response: aZnResponse	requestMatcher		matchRequest: aZnRequest		ifMatch: [ :aTeaRequest | action teaEvalActionOnRequest: aTeaRequest response: aZnResponse ]		ifNoMatch: [ ]! !!TeaBeforeFilter methodsFor: 'request handling'!handleRequest: aZnRequest	requestMatcher		matchRequest: aZnRequest		ifMatch: [ :aTeaRequest | action teaEvalActionOnRequest: aTeaRequest ]		ifNoMatch: [ ]! !!TeaFilter class methodsFor: 'instance creation'!urlPattern: anUrlPattern action: aTeaAction	^ self new 		setMatcher: (TeaRequestMatcher method: TeaMethodMatcher any url: anUrlPattern)		action: aTeaAction! !!TeaFilter methodsFor: 'acccessing'!action	^action! !!TeaFilter methodsFor: 'acccessing'!requestMatcher	^requestMatcher! !!TeaFilter methodsFor: 'initialization'!setMatcher: aTeaRequestMatcher action: aTeaAction	requestMatcher := aTeaRequestMatcher.	action := aTeaAction.	^ self! !!TeaFilter methodsFor: 'acccessing'!whenClause: aBlockClosure 	requestMatcher whenClause: aBlockClosure ! !!TeaGlobUrlSegment methodsFor: 'url pattern segment'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	self subclassResponsibility! !!TeaLiteral class methodsFor: 'instance creation'!fromString: aString atLast: aBoolean	| class |	class := aBoolean ifTrue: [ TeaLiteralStop ] ifFalse: [ TeaLiteral ].	^ class new setLiteral: aString! !!TeaLiteral methodsFor: 'url pattern segment'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	^ literal = urlSegments first and: 		[ adjacentPatterns first 			matches: urlSegments allButFirst 			rest: adjacentPatterns allButFirst 			placeholders: aDictionary ]! !!TeaLiteral methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: literal.	! !!TeaLiteral methodsFor: 'initialization'!setLiteral: aString	literal := aString.	^ self! !!TeaLiteralStop methodsFor: 'url pattern segment'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	^ urlSegments size = 1 and: [ literal = urlSegments first ]! !!TeaPlaceholder class methodsFor: 'private'!createPlaceholderName: key typeConstraint: aTypeConstraint atLast: aBoolean	| class |	class := aBoolean		ifTrue: [ TeaPlaceholderStop ]		ifFalse: [ TeaPlaceholder ].	^ class new 		setPlaceholderName: key 		typeConstraint: aTypeConstraint! !!TeaPlaceholder class methodsFor: 'instance creation'!fromString: aString atLast: aBoolean	| spec typeConstraint key |	self mustBeValidPlaceholder: aString.	spec := aString allButFirst allButLast findTokens: ':'.	key := spec first.	typeConstraint := spec at: 2 ifAbsent: #IsObject.	^ self 		createPlaceholderName: key 		typeConstraint: (Smalltalk at: typeConstraint asSymbol)		atLast: aBoolean! !!TeaPlaceholder class methodsFor: 'private'!mustBeValidPlaceholder: aString	((aString beginsWith: '<') and: [ aString endsWith: '>' ])		ifFalse: [ self error: 'Invalid placeholder name: ', aString ]! !!TeaPlaceholder methodsFor: 'url pattern segment'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	(urlSegments first = TeaPadding or: [ (typeConstraint matchesTo: urlSegments first) not]) 		ifTrue: [ ^ false ].			aDictionary 		at: placeholderName 		put: (typeConstraint parseString: urlSegments first).					^ adjacentPatterns first 		matches: urlSegments allButFirst 		rest: adjacentPatterns allButFirst 		placeholders: aDictionary! !!TeaPlaceholder methodsFor: 'printing'!printOn: aStream	aStream 		nextPut: $<;		nextPutAll: placeholderName;		nextPut: $>! !!TeaPlaceholder methodsFor: 'initialization'!setPlaceholderName: aString typeConstraint: aTypeConstraint	placeholderName := aString asSymbol.	typeConstraint := aTypeConstraint.	^ self! !!TeaPlaceholderStop methodsFor: 'url pattern segment'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	| match |	match := urlSegments size = 1 		and: [ urlSegments first ~= TeaPadding 		and: [ (typeConstraint matchesTo: urlSegments first) ] ].	match ifTrue:		 [ aDictionary			at: placeholderName 			put: (typeConstraint parseString: urlSegments first) ].	^ match! !!TeaWildcard class methodsFor: 'instance creation'!atLast: aBoolean	^ aBoolean		ifTrue: [ TeaWildcardStop new ]		ifFalse: [ TeaWildcard new ]! !!TeaWildcard methodsFor: 'url pattern segment'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	^ adjacentPatterns first 		matches: urlSegments allButFirst 		rest: adjacentPatterns allButFirst 		placeholders: aDictionary! !!TeaWildcard methodsFor: 'printing'!printOn: aStream	aStream nextPut: $*! !!TeaWildcardStop methodsFor: 'url pattern segment'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	^ true! !!TeaMethodMatcher class methodsFor: 'instance creation'!any	^ self new 		setMatcherBlock: [ :anyMethod | true ] 		name: 'ANY'! !!TeaMethodMatcher class methodsFor: 'instance creation'!exactly: aSymbol	^ self new 		setMatcherBlock: [ :actual | actual = aSymbol ] 		name: aSymbol asString! !!TeaMethodMatcher methodsFor: 'converting'!asString	^ name! !!TeaMethodMatcher methodsFor: 'http method matcher'!matchesHttpMethod: aSymbol	^ matcherBlock value: aSymbol! !!TeaMethodMatcher methodsFor: 'printing'!printOn: aStream	aStream 		nextPutAll: name;		nextPut: $:! !!TeaMethodMatcher methodsFor: 'initialization'!setMatcherBlock: aBlockClosure name: aString	matcherBlock := aBlockClosure.	name := aString.	^ self! !!Tea405AwareNotFoundHandler methodsFor: 'private'!populateAllowedHeaderOf: response withAllowedRoutes: allowedRoutes	allowedRoutes do: [ :route | 		response headers 			at: 'Allow' 			put: route methodMatcher asString			ifPresentMerge: [ :old :new | old, ', ', new ] ].	^ response! !!Tea405AwareNotFoundHandler methodsFor: 'not found handler'!requestNotFound: aZnRequest	| allowedRoutes |	allowedRoutes := routes		select: [ :each | each canHandleUrl: aZnRequest url ].	^ allowedRoutes		ifEmpty: [ ZnResponse notFound: aZnRequest url ]		ifNotEmpty: [			self				populateAllowedHeaderOf: (ZnResponse methodNotAllowed: aZnRequest)				withAllowedRoutes: allowedRoutes ]! !!TeaNotFoundHandler methodsFor: 'initialization'!initialize	super initialize.	routes := OrderedCollection new.! !!TeaNotFoundHandler methodsFor: 'initialization'!initializeRoutes: aTeaRouteCollection	routes := aTeaRouteCollection.	^ self! !!TeaNotFoundHandler methodsFor: 'not found handler'!requestNotFound: aZnRequest	^ ZnResponse notFound: aZnRequest url! !!TeaOutput class methodsFor: 'response transformers'!html	^ self stringWithContentType: ZnMimeType textHtml! !!TeaOutput class methodsFor: 'response transformers'!json	^ [ :aTeaResponse | | entity |		entity := ZnStringEntity 			with: ((self optionalClass: #NeoJSONWriter) toString: aTeaResponse body) 			type: (ZnMimeType applicationJson charSet: aTeaResponse charSet; yourself).		self 			znEntity: entity			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers'!mustache: templateStringOrStream contentType: contentType	^ [ :aTeaResponse | | model object entity |		object := aTeaResponse body.		model := (object respondsTo: #asDictionary) ifTrue: [ object asDictionary ] ifFalse: [ object ].				entity := (ZnStringEntity 			with: (((self optionalClass: #MustacheTemplate) on: templateStringOrStream) value: model) 			type: contentType).		self 			znEntity: entity			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers'!mustacheHtml: templateString 	^ self mustache: templateString contentType: ZnMimeType textHtml.! !!TeaOutput class methodsFor: 'private'!optionalClass: aSymbol	[ ^ Smalltalk at: aSymbol ]		on: KeyNotFound		do: [ self error: 'An optional dependency ', aSymbol, ' was not found. Please load it first.' ]! !!TeaOutput class methodsFor: 'response transformers'!ston	^ [ :aTeaResponse | | entity |		entity := ZnStringEntity 			with: ((self optionalClass: #STON) toString: aTeaResponse body) 			type: (ZnMimeType textPlain charSet: aTeaResponse charSet; yourself).		self 			znEntity: entity			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers'!stream	^ self stream: ZnMimeType applicationOctetStream ! !!TeaOutput class methodsFor: 'response transformers'!stream: aZnMimeType	^ [ :aTeaResponse | | entity |		entity := ZnStreamingEntity 			readFrom: aTeaResponse body			usingType: aZnMimeType			andLength: aTeaResponse body size.		self 			znEntity: entity			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers'!stringWithContentType: aZnMimeType 	^ [ :aTeaResponse | | entity |		entity := ZnStringEntity new			contentType: (aZnMimeType charSet: aTeaResponse charSet; yourself);			string: aTeaResponse body asString;			yourself.		self 			znEntity: entity 			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers'!text	^ self stringWithContentType: ZnMimeType textPlain! !!TeaOutput class methodsFor: 'private'!znEntity: aZnEntity code: anInteger headers: aDictionary	| headers |	headers := ZnHeaders defaultResponseHeaders.	headers addAll: aDictionary.	^ ZnResponse new		statusLine: (ZnStatusLine code: anInteger);		headers: headers;		entity: aZnEntity;		yourself! !!TeaRequest class methodsFor: 'instance creation'!fromZnRequest: aZnRequest	^ self fromZnRequest: aZnRequest pathParams: Dictionary new! !!TeaRequest class methodsFor: 'instance creation'!fromZnRequest: aZnRequest pathParams: aDictionary	^ self new setZnRequest: aZnRequest pathParams: aDictionary! !!TeaRequest methodsFor: 'aborting'!abort: response	(TeaAbort response: response) signal! !!TeaRequest methodsFor: 'acccessing - params'!at: aSymbol	^ self 		at: aSymbol 		ifAbsent: [ TeaNoSuchParam signalWithParam: aSymbol ]! !!TeaRequest methodsFor: 'acccessing - params'!at: aSymbol ifAbsent: aBlock	"Gets the value of a path parameter, query parameter for form parameter.		E.g. /foo/<path-param>/bar		E.g. /foo?queryParam=value"	^ pathParams at: aSymbol ifAbsent: [ self queryOrFormParam: aSymbol ifAbsent: aBlock	"XXX do something better" ]! !!TeaRequest methodsFor: 'reflective operations'!doesNotUnderstand: aMessage	^ aMessage sendTo: znRequest! !!TeaRequest methodsFor: 'private'!formParam: aSymbol ifAbsent: aBlock	^ (znRequest entity isKindOf: ZnApplicationFormUrlEncodedEntity) "XXX do something better" 		ifTrue: [ znRequest entity at: aSymbol ifAbsent: aBlock ]		ifFalse: aBlock! !!TeaRequest methodsFor: 'private'!queryOrFormParam: aSymbol ifAbsent: aBlock	^ znRequest uri 		queryAt: aSymbol 		ifAbsent: [ self formParam: aSymbol ifAbsent: aBlock ]! !!TeaRequest methodsFor: 'initialization'!setZnRequest: aZnRequest pathParams: aDictionary	znRequest := aZnRequest.	pathParams := aDictionary.	^ self! !!TeaRequestMatcher class methodsFor: 'instance creation'!method: aMethodMatcher url: anUrlPattern	^ self new setPattern: anUrlPattern method: aMethodMatcher! !!TeaRequestMatcher methodsFor: 'request matcher'!matchRequest: aZnRequest ifMatch: matchBlock ifNoMatch: noMatchBlock	| placeholders matches |	(methodMatcher matchesHttpMethod: aZnRequest method) ifFalse: [ ^ noMatchBlock value ].	placeholders := Dictionary new.	matches := (urlPattern matchesUrl: aZnRequest url placeholders: placeholders) 		and: [ whenClause cull: (TeaRequest fromZnRequest: aZnRequest pathParams: placeholders) ].	^ matches 		ifTrue: [ matchBlock value: (TeaRequest fromZnRequest: aZnRequest pathParams: placeholders) ]		ifFalse: noMatchBlock! !!TeaRequestMatcher methodsFor: 'request matcher'!matchesUrl: aZnUrl	^ urlPattern matchesUrl: aZnUrl placeholders: Dictionary new! !!TeaRequestMatcher methodsFor: 'accessing'!methodMatcher	^ methodMatcher! !!TeaRequestMatcher methodsFor: 'printing'!printOn: aStream	methodMatcher printOn: aStream.	aStream space.	urlPattern printOn: aStream.! !!TeaRequestMatcher methodsFor: 'initialization'!setPattern: anUrlPattern method: aMethodMatcher	urlPattern := anUrlPattern.	methodMatcher := aMethodMatcher.	whenClause := [ :anyRequest | true ].	^ self! !!TeaRequestMatcher methodsFor: 'accessing'!whenClause: aBlockClosure 	whenClause := aBlockClosure! !!TeaResponse class methodsFor: 'instance creation'!badRequest	^ self code: ZnStatusLine badRequest code! !!TeaResponse class methodsFor: 'instance creation'!code: anInteger	^ self new code: anInteger! !!TeaResponse class methodsFor: 'instance creation'!created	^ self code: ZnStatusLine created code! !!TeaResponse class methodsFor: 'instance creation'!methodNotAllowed	^ self code: ZnStatusLine methodNotAllowed code ! !!TeaResponse class methodsFor: 'instance creation'!notFound	^ self code: ZnStatusLine notFound code ! !!TeaResponse class methodsFor: 'instance creation'!notModified	^ self code: ZnStatusLine notModified code! !!TeaResponse class methodsFor: 'instance creation'!ok	^ self code: ZnStatusLine ok code! !!TeaResponse class methodsFor: 'instance creation'!redirect	^ self code: ZnStatusLine redirect code! !!TeaResponse class methodsFor: 'instance creation'!serverError	^ self code: ZnStatusLine internalServerError code! !!TeaResponse class methodsFor: 'instance creation'!unauthorized	^ self code: ZnStatusLine unauthorized code! !!TeaResponse methodsFor: 'accessing'!body	^ body! !!TeaResponse methodsFor: 'accessing'!body: anObject	body := anObject.	^ self! !!TeaResponse methodsFor: 'accessing'!charSet	^ charSet! !!TeaResponse methodsFor: 'accessing'!charSet: aString	charSet := aString.	^ self! !!TeaResponse methodsFor: 'accessing'!code	^ code! !!TeaResponse methodsFor: 'accessing'!code: anInteger	code := anInteger.	^ self! !!TeaResponse methodsFor: 'accessing'!headerName: nameString value: valueString	headers at: nameString put: valueString.	^ self! !!TeaResponse methodsFor: 'accessing'!headers	^ headers! !!TeaResponse methodsFor: 'accessing'!headers: aDictionary	headers := aDictionary asDictionary.	^ self! !!TeaResponse methodsFor: 'initialization'!initialize	super initialize.	headers := Dictionary new.	body := String crlf.	code := ZnStatusLine ok code.	charSet := 'utf-8'.! !!TeaResponse methodsFor: 'accessing'!location: url	self headerName: 'Location' value: url asString.	^ self! !!TeaResponse methodsFor: 'response transforming'!teaTransform: aResponseTransformer request: aTeaRequest	^ aResponseTransformer cull: self cull: aTeaRequest! !!TeaRoute class methodsFor: 'instance creation'!matcher: aTeaRequestMatcher action: aTeaAction transformer: aResponseTransformer port: portNumber	^ self new 		setMatcher: aTeaRequestMatcher		action: aTeaAction		transformer: aResponseTransformer		port: portNumber "XXX only used by teapsoon inspector"! !!TeaRoute methodsFor: 'request handling'!canHandleUrl: aZnUrl	"only check the URL not without checking HTTP Method or when clause"	^ requestMatcher matchesUrl: aZnUrl! !!TeaRoute methodsFor: 'request handling'!handleRequest: aZnRequest ifUnhandled: aBlock	^ requestMatcher		matchRequest: aZnRequest		ifMatch: [ :aTeaRequest |			(action teaEvalActionOnRequest: aTeaRequest)				teaTransform: responseTransformer				request: aTeaRequest ]		ifNoMatch: aBlock! !!TeaRoute methodsFor: 'accessing'!methodMatcher 	^ requestMatcher methodMatcher ! !!TeaRoute methodsFor: 'printing'!printOn: aStream	requestMatcher printOn: aStream.	aStream nextPutAll: ' -> '.	action printOn: aStream.! !!TeaRoute methodsFor: 'accessing'!responseTransformer: aBlock	responseTransformer := aBlock! !!TeaRoute methodsFor: 'initialization'!setMatcher: aTeaRequestMatcher action: aTeaAction transformer: aResponseTransformer port: portNumber	requestMatcher := aTeaRequestMatcher.	action := aTeaAction.	responseTransformer := aResponseTransformer.	port := portNumber.	^ self! !!TeaRoute methodsFor: 'accessing'!whenClause: aBlockClosure 	requestMatcher whenClause: aBlockClosure! !!TeaCompositeRouter class methodsFor: 'instance creation'!routers: teaRouterCollection	^ self new setRouters: teaRouterCollection! !!TeaCompositeRouter methodsFor: 'filters'!addAfterFilter: aTeaFilter	^ afterFilters add: aTeaFilter! !!TeaCompositeRouter methodsFor: 'filters'!addBeforeFilter: aTeaFilter	^ beforeFilters add: aTeaFilter! !!TeaCompositeRouter methodsFor: 'error handing'!addErrorHandler: aTeaErrorHandler	^ errorhandlers add: aTeaErrorHandler! !!TeaCompositeRouter methodsFor: 'accessing'!afterFilters	^afterFilters ! !!TeaCompositeRouter methodsFor: 'accessing'!beforeFilters	^beforeFilters ! !!TeaCompositeRouter methodsFor: 'private'!evaluateAfterFilters: aZnRequest response: aZnResponse	afterFilters do: [ :each | each handleRequest: aZnRequest response: aZnResponse ]! !!TeaCompositeRouter methodsFor: 'private'!evaluateBeforeFilters: aZnRequest	beforeFilters do: [ :each | each handleRequest: aZnRequest ]! !!TeaCompositeRouter methodsFor: 'private'!evaluateRouters: aZnRequest ifUnhandled: aBlock	routers do: [ :each | | response |		response := each handleRequest: aZnRequest ifUnhandled: nil.		response ifNotNil: [ ^ response ] ].	^ aBlock value! !!TeaCompositeRouter methodsFor: 'private'!exceptionOccurred: anException request: aZnRequest	| handler |	handler := errorhandlers 		detect: [ :each | each canHandleError: anException ]		ifNone: [ anException pass ].			^ handler handleError: anException request: (TeaRequest fromZnRequest: aZnRequest).	! !!TeaCompositeRouter methodsFor: 'zn delegate'!handleRequest: aZnRequest	^ self 		handleRequest: aZnRequest 		ifUnhandled: [ notFoundHandler requestNotFound: aZnRequest ] ! !!TeaCompositeRouter methodsFor: 'zn delegate'!handleRequest: aZnRequest ifUnhandled: aBlock	| response |	^ [ self evaluateBeforeFilters: aZnRequest.	     response := self evaluateRouters: aZnRequest ifUnhandled: aBlock.	     self evaluateAfterFilters: aZnRequest response: response.	     response		   ] on: Exception 	     do: [ :ex | self exceptionOccurred: ex request: aZnRequest ]! !!TeaCompositeRouter methodsFor: 'initialization'!initialize	super initialize.	errorhandlers := OrderedCollection new.	beforeFilters := OrderedCollection new.	afterFilters := OrderedCollection new.	notFoundHandler := TeaNotFoundHandler new.! !!TeaCompositeRouter methodsFor: 'error handing'!notFoundHandler: aTeaNotFoundHandler	notFoundHandler := aTeaNotFoundHandler! !!TeaCompositeRouter methodsFor: 'initialization'!setRouters: teaRouterCollection	routers := teaRouterCollection asArray.	^ self! !!TeaDynamicRouter methodsFor: 'route dispatcher'!addRoute: aRoute	^ routes add: aRoute! !!TeaDynamicRouter methodsFor: 'zn delegate'!handleRequest: aZnRequest ifUnhandled: aBlock	routes do: [ :each | | response |		response := each handleRequest: aZnRequest ifUnhandled: nil.		response ifNotNil: [ ^ response ] ].	^ aBlock value! !!TeaDynamicRouter methodsFor: 'initialization'!initialize	super initialize.	routes := OrderedCollection new.! !!TeaDynamicRouter methodsFor: 'accessing'!routes	^routes! !!TeaRouter methodsFor: 'router'!handleRequest: aZnRequest ifUnhandled: aBlock	self subclassResponsibility ! !!TeaStaticRouter methodsFor: 'zn delegate'!handleRequest: aZnRequest ifUnhandled: aBlock	| response |	delegate ifNil: [ ^ aBlock value ].	response := delegate handleRequest: aZnRequest.	^ response isNotFound ifTrue: aBlock ifFalse: [ response ]! !!TeaStaticRouter methodsFor: 'acccessing'!urlPrefix: urlPrefixString path: pathString	delegate ifNil: [ delegate := ZnStaticFileServerDelegate new ].	delegate		prefixFromString: urlPrefixString;		directory: pathString asFileReference.! !!TeaGlobUrlPattern class methodsFor: 'private'!createSegment: aString atLast: aBoolean	aString = '*' 		ifTrue: [ ^ TeaWildcard atLast: aBoolean ].	(aString beginsWith: '<')		ifTrue: [ ^ TeaPlaceholder fromString: aString atLast: aBoolean ].	^ TeaLiteral fromString: aString atLast: aBoolean! !!TeaGlobUrlPattern class methodsFor: 'private'!parseSegments: aString	| tokens |	tokens := aString findTokens: '/'.	^ tokens collectWithIndex: [ :each :idx | 		self createSegment: each atLast: idx = tokens size ]! !!TeaGlobUrlPattern class methodsFor: 'instance creation'!parseString: aString	^ self new setSegments: (self parseSegments: aString)! !!TeaGlobUrlPattern methodsFor: 'url matcher'!matchesUrl: anUrl placeholders: aDictionary	| urlSegments |	urlSegments := self padUrlSegments: anUrl with: TeaPadding size: segments size.	segments isEmpty		ifTrue: [ ^ urlSegments isEmpty ].	^ segments first 		matches: urlSegments 		rest: segments allButFirst 		placeholders: aDictionary! !!TeaGlobUrlPattern methodsFor: 'private'!padUrlSegments: anUrl with: padding size: anInteger	| urlSegments |	urlSegments := anUrl segments isEmptyOrNil 		ifTrue: [ OrderedCollection new ]		ifFalse: [ self trimTrailingSlash: anUrl segments ].	urlSegments size < segments size		ifTrue: [ urlSegments := urlSegments forceTo: anInteger paddingWith: padding ].	^ urlSegments! !!TeaGlobUrlPattern methodsFor: 'printing'!printOn: aStream	aStream nextPut: $'.	segments 		do: [ :each | each printOn: aStream ]		separatedBy: [ aStream nextPut: $/ ].	aStream nextPut: $'.! !!TeaGlobUrlPattern methodsFor: 'initialization'!setSegments: anArray	segments := anArray.	^ self! !!TeaGlobUrlPattern methodsFor: 'private'!trimTrailingSlash: urlSegments 	^ (urlSegments isNotEmpty and: [ urlSegments last asString = '/' ])		ifTrue: [ urlSegments allButLast ]		ifFalse: [ urlSegments ]! !!TeaRxUrlPattern class methodsFor: 'instance creation'!fromRxMatcher: aRxMatcher 	^ self new initializeRxMatcher: aRxMatcher ! !!TeaRxUrlPattern methodsFor: 'private'!hasMatched: aZnUrl	"XXX RxMatcher has state. Consider something better"	^ lock critical: [ (regexp matches: aZnUrl path) or: [ regexp matches: '/', aZnUrl path ] ]! !!TeaRxUrlPattern methodsFor: 'initialization'!initializeRxMatcher: aRxMatcher 	regexp := aRxMatcher.	lock := Mutex new.	^ self! !!TeaRxUrlPattern methodsFor: 'url matcher'!matchesUrl: aZnUrl placeholders: aDictionary 	| match |	match := self hasMatched: aZnUrl.	match ifTrue:		[ 2 to: regexp subexpressionCount do: [ :i | 			aDictionary at: i - 1put: (regexp subexpression: i) ] ].	^ match! !!TeaRxUrlPattern methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: '<regexp>'.! !!TeaUrlPattern methodsFor: 'url matcher'!matchesUrl: anUrl placeholders: aDictionary	self subclassResponsibility ! !!TeaUrlPatternSet class methodsFor: 'instance creation'!fromCollection: aCollection 	^ self new setPatterns: (aCollection collect: #asTeaUrlPattern)! !!TeaUrlPatternSet methodsFor: 'url matcher'!matchesUrl: anUrl placeholders: aDictionary	^ patterns anySatisfy: [ :each | each matchesUrl: anUrl placeholders: aDictionary ]! !!TeaUrlPatternSet methodsFor: 'printing'!printOn: aStream	aStream nextPut: ${.	patterns 		do: [ :each | each printOn: aStream ]		separatedBy: [ aStream nextPut: $. ].	aStream nextPut: $}.! !!TeaUrlPatternSet methodsFor: 'initialization'!setPatterns: aCollection 	patterns := aCollection.	^ self! !!Teapot class methodsFor: 'instance creation'!configure: optionsAssociations	"Create a new Teapot instance with optional properties. 	 - Teapot properties: #defaultOutput, #znServer	 - ZnServer properties: See options protocol of ZnServer for specific usages.		Example: Teapot configure: { 		#defaultOutput -> #json. 		#bindAddress -> #[192 168 0 3].		#port -> 8080. 		#debugMode -> true.		#notFoundHandlerClass -> Tea405AwareNotFoundHandler.	}."		^ self new initializeOptions: optionsAssociations asDictionary! !!Teapot class methodsFor: 'instance creation'!on	"Create Teapot with default properties."		^ self configure: { }! !!Teapot class methodsFor: 'controlling'!stopAll	self allInstancesDo: #stop! !!Teapot methodsFor: 'url mapping'!CONNECT: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #CONNECT)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping'!DELETE: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #DELETE)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping'!GET: patternActionAssoc	self 		addRouteMethod: (TeaMethodMatcher exactly: #GET) 		pattern: patternActionAssoc key 		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping'!HEAD: patternActionAssoc	self 		addRouteMethod: (TeaMethodMatcher exactly: #HEAD) 		pattern: patternActionAssoc key 		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping'!OPTIONS: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #OPTIONS)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping'!PATCH: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #PATCH)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping'!POST: patternActionAssoc	self 		addRouteMethod: (TeaMethodMatcher exactly: #POST) 		pattern: patternActionAssoc key 		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping'!PUT: patternActionAssoc	self 		addRouteMethod: (TeaMethodMatcher exactly: #PUT) 		pattern: patternActionAssoc key 		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping'!TRACE: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #TRACE)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'private'!addRouteMethod: aTeaMethodMatcher pattern: pattern action: aTeaAction	current := dynamicRouter addRoute:		(TeaRoute			matcher: (TeaRequestMatcher method: aTeaMethodMatcher url: pattern asTeaUrlPattern)			action: aTeaAction			transformer: defaultOutput			port: server port)! !!Teapot methodsFor: 'filters'!after: patternActionAssoc	current := compositeRouter addAfterFilter:				(TeaAfterFilter 			urlPattern: patternActionAssoc key asTeaUrlPattern 			action: patternActionAssoc value)! !!Teapot methodsFor: 'url mapping'!any: patternActionAssoc	self		addRouteMethod: TeaMethodMatcher any		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'filters'!before: patternActionAssoc	current := compositeRouter addBeforeFilter:				(TeaBeforeFilter 			urlPattern: patternActionAssoc key asTeaUrlPattern 			action: patternActionAssoc value)! !!Teapot methodsFor: 'url mapping'!exception: anExceptionSetActionAssoc	current := compositeRouter addErrorHandler:		(TeaErrorHandler			for: anExceptionSetActionAssoc key			action: anExceptionSetActionAssoc value			responseTransformer: defaultOutput)! !!Teapot methodsFor: 'initialization'!initializeOptions: optionsDictionary	dynamicRouter := TeaDynamicRouter new.	staticRouter := TeaStaticRouter new.	compositeRouter := TeaCompositeRouter routers: {dynamicRouter. staticRouter}.		defaultOutput := self responseTransformer: (optionsDictionary at: #defaultOutput ifAbsent: #html).										self exception: TeaAbort -> [ :abort :req | abort response teaTransform: [ :same | same ] request: req].	server := optionsDictionary 		at: #znServer		ifAbsent: [ ZnServer defaultServerClass new ].	optionsDictionary 		at: #notFoundHandlerClass 		ifPresent: [:class | compositeRouter notFoundHandler: (class new initializeRoutes: dynamicRouter routes)].	server delegate: compositeRouter.		optionsDictionary keysAndValuesDo: [ :key :value | server optionAt: key put: value ].	^ self! !!Teapot methodsFor: 'url mapping'!output: transformerBlockOrSymbol	current responseTransformer: (self responseTransformer: transformerBlockOrSymbol)	! !!Teapot methodsFor: 'private'!responseTransformer: transformerBlockOrSymbol	^ transformerBlockOrSymbol isSymbol		ifTrue: [ TeaOutput perform: transformerBlockOrSymbol ]		ifFalse: [ transformerBlockOrSymbol ]! !!Teapot methodsFor: 'url mapping'!serveStatic: urlPrefixString from: pathString		staticRouter urlPrefix: urlPrefixString path: pathString! !!Teapot methodsFor: 'accessing'!server	^ server! !!Teapot methodsFor: 'controlling'!start	server start! !!Teapot methodsFor: 'controlling'!stop	server stop! !!Teapot methodsFor: 'filters'!when: aBlockClosure 	current whenClause: aBlockClosure	! !!Collection methodsFor: '*Teapot-Core'!asTeaUrlPattern	^ TeaUrlPatternSet fromCollection: self! !"Teapot-Core"!!Cupboard commentStamp: '' prior: 0!A cupboard for teapots.I'm the main User Interface to manage teapots instances.You can open me with:		self soleInstance open!!TeaFormTab commentStamp: '' prior: 0!I'm built up from a dynamically extensible key value pair list (TeaKeyValueInput). I can represent POST parameters or HTTP headers for example.!!TeaKeyValueInput commentStamp: '' prior: 0!Two inputs and a remove button.!!TeaKeyValueList commentStamp: '' prior: 0!I'm built up from a dynamically extensible list of other components.!!TeaRequestBodyTabs commentStamp: '' prior: 0!I graphically represent a request body that can be viewed in multiple ways.!!Teaspoon commentStamp: '' prior: 0!I provide a graphical interface for quickly testing and excesising routes. Right click on a route in the inspector to open me.!!ManifestTeapotTools commentStamp: '' prior: 0!Please describe the package using the class comment of the included manifest class. The manifest class also includes other additional metadata for the package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!TeaIconProvider commentStamp: '' prior: 0!An icon provider for tools icons with an icon cache!!TeaRoute methodsFor: '*Teapot-Tools'!inspectRoute: aBuilder	<inspectorPresentationOrder: 0 title: 'Teaspoon'>	^ Teaspoon new		method: requestMatcher methodMatcher asString		url: requestMatcher urlPattern asTeaspoonPath		port: port.! !!Cupboard class methodsFor: 'accessing'!iconProvider	^TeaIconProvider! !!Cupboard class methodsFor: 'world menu'!menuCommandOn: aBuilder 	<worldMenu> 		(aBuilder item: #'Teapot')	 		help: 'Teatime'; 		parent: #'Tools' translated;		icon: self iconProvider teapotIcon;		action: [ self soleInstance open ].	 aBuilder withSeparatorAfter ! !!Cupboard class methodsFor: 'instance creation'!new	self error: 'Do not create new instances - access using #soleInstance'! !!Cupboard class methodsFor: 'private'!reset	<script>		soleInstance := nil.	 ! !!Cupboard class methodsFor: 'accessing'!soleInstance	<script: 'self soleInstance inspect'>		^ soleInstance ifNil: [ soleInstance := self basicNew initialize ]! !!Cupboard methodsFor: 'initialization'!buildBrowseToolBarItem	^ SpToolbarButtonPresenter new		label: 'Browse';		icon: self iconProvider teapotServerIcon;		action: [ self selectedTeapot browse ];		help: 'Browse the selected Teapot';		yourself! !!Cupboard methodsFor: 'initialization'!buildContextMenu	^ SpMenuPresenter new			addItem: [ :item | 				item 					name: 'Start';					icon: self iconProvider teapotServerStartIcon;					action: [ teapots selectedItem start. self refreshTeapots ] ];			addItem: [ :item | 				item 					name: 'Stop';					icon: self iconProvider teapotServerStopIcon;					action: [ teapots selectedItem stop. self refreshTeapots ] ];			addItem: [ :item | 				item 					name: 'Browse';					icon: self iconProvider teapotServerIcon;					action: [ teapots selectedItem browse. self refreshTeapots ] ];		yourself! !!Cupboard methodsFor: 'initialization'!buildInspectToolBarItem	^ SpToolbarButtonPresenter new		label: 'Inspect';		icon: self iconProvider teapotInspectIcon;		action: [ self selectedTeapot inspect ];		help: 'Inspect the selected Teapot';		yourself! !!Cupboard methodsFor: 'initialization'!buildNewStaticToolBarItem	^ SpToolbarButtonPresenter new		  label: 'New File Server';		  icon: self iconProvider teapotServerStaticIcon;		  action: [			  self onNewStaticServer.			  self refreshTeapots ];		  help: 'Create a new Teapot serving static files';		  yourself! !!Cupboard methodsFor: 'initialization'!buildNewToolBarItem	^ SpToolbarButtonPresenter new		  label: 'New Server';		  icon: self iconProvider teapotServerIcon;		  action: [			  self onNewServer.			  self refreshTeapots ];		  help: 'Create a new Teapot';		  yourself! !!Cupboard methodsFor: 'initialization'!buildRefreshToolBarItem	^ SpToolbarButtonPresenter new		label: 'Refresh';		icon: self iconProvider teapotRefreshIcon;		action: [ self refreshTeapots ];		help: 'Refresh the Teapot list';		yourself! !!Cupboard methodsFor: 'initialization'!buildStartToolBarItem		^ SpToolbarButtonPresenter new		label: 'Start';		icon: self iconProvider teapotServerStartIcon;		action: [ self selectedTeapot start. self refreshTeapots ];		help: 'Start the selected Teapot';		yourself! !!Cupboard methodsFor: 'initialization'!buildStopToolBarItem		^ SpToolbarButtonPresenter new		label: 'Stop';		icon: self iconProvider teapotServerStopIcon;		action: [ self selectedTeapot stop. self refreshTeapots ];		help: 'Stop the selected Teapot';		yourself! !!Cupboard methodsFor: 'initialization'!buildToolbar		^ self newToolbar 		addItem: self buildRefreshToolBarItem;		addItem: self buildNewToolBarItem;		addItem: self buildNewStaticToolBarItem;		addItem: self buildStartToolBarItem;		addItem: self buildStopToolBarItem;		addItem: self buildBrowseToolBarItem;		addItem: self buildInspectToolBarItem;		yourself! !!Cupboard methodsFor: 'layout'!defaultLayout 	^ SpBoxLayout newTopToBottom 		add: teapots;		yourself! !!Cupboard methodsFor: 'private'!iconForTeapot: aTeapot	^aTeapot server isRunning 			ifTrue: [ self iconProvider teapotServerStartIcon ] 			ifFalse: [ self iconProvider teapotServerStopIcon ]! !!Cupboard methodsFor: 'accessing'!iconProvider	^ self class iconProvider! !!Cupboard methodsFor: 'initialization'!initializePresenters		teapots := self newList.	teapots		items: self teapots;		displayIcon: [:each | self iconForTeapot: each ];		display: [ :each | self nameForTeapot: each  ];		whenActivatedDo: [ self selectedTeapot inspect ];		bindKeyCombination: Character cr asShortcut toAction: [ self selectedTeapot inspect ];		contextMenu: self buildContextMenu! !!Cupboard methodsFor: 'initialization'!initializeWindow: aWindowPresenter	super initializeWindow: aWindowPresenter.	aWindowPresenter 		title: 'Teapots';		toolbar: (toolbar := self buildToolbar).! !!Cupboard methodsFor: 'private'!nameForTeapot: aTeapot	^ String streamContents: [:stream |		stream nextPutAll: aTeapot server port asString.		stream nextPutAll: ' - '.		stream nextPutAll: (aTeapot server isRunning ifTrue: [ 'running' ] ifFalse: [ 'stopped' ]) ].! !!Cupboard methodsFor: 'actions'!onNewServer	| port pot |	port := UIManager default request: 'New server' initialAnswer: '80'.	port ifNil: [ ^ self ].	pot := Teapot configure: { 		#port -> port asNumber	}.	pot start.			! !!Cupboard methodsFor: 'actions'!onNewStaticServer	| port directory pot |	port := UIManager default request: 'New server' initialAnswer: '80'.	port ifNil: [ ^self ].	directory := UIManager default chooseDirectory: 'Serve directory'.	directory ifNil: [ ^ self ].	pot := Teapot configure: { 		#port -> port asNumber	}.	pot serveStatic: '/' from: directory.	pot start.			! !!Cupboard methodsFor: 'actions'!open	self refreshTeapots.	super open.! !!Cupboard methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: 'Cupboard'! !!Cupboard methodsFor: 'actions'!refreshTeapots	teapots items: self teapots! !!Cupboard methodsFor: 'accessing'!selectedTeapot	^ teapots selectedItem! !!Cupboard methodsFor: 'accessing'!teapots	^ Teapot allInstances! !!TeaFormTab class methodsFor: 'specs'!defaultLayout	^ SpBoxLayout newVertical 		add: #form expand: false fill: false;      add: (SpBoxLayout newHorizontal 		   add: #addButton expand: false fill: false;         hAlignCenter;         yourself) expand: false fill: false;				yourself! !!TeaFormTab methodsFor: 'accessing'!addButton	^ addButton ! !!TeaFormTab methodsFor: 'initialization'!connectPresenters 	addButton whenActionPerformedDo: [ form addKey: 'key' value: 'value' ]! !!TeaFormTab methodsFor: 'accessing'!form	^ form! !!TeaFormTab methodsFor: 'initialization'!initializePresenters	addButton := self newButton label: 'Add parameter'; yourself.	form := self instantiate: TeaKeyValueList.	self focusOrder 		add: form;		add: addButton.! !!TeaFormTab methodsFor: 'protocol'!updateKeyValus: keyValueCollection	form items: keyValueCollection! !!TeaFormTab methodsFor: 'private'!urlEncoded	| url formParams |	url := '/' asZnUrl.	formParams := form items.	formParams ifEmpty: [ ^ '' ].	formParams do: [ :association | url := url withQuery: association ].	^ url asString allButFirst: 2	! !!TeaFormTab methodsFor: 'protocol'!writeUrlEncodedTo: aTextModel	self urlEncoded 		ifNotEmpty: [ aTextModel text: self urlEncoded ]! !!TeaKeyValueInput class methodsFor: 'specs'!defaultLayout	^ SpBoxLayout newHorizontal  		add: #keyInput expand: true fill: true padding: 5;		add: #valueInput expand: true fill: true padding: 5;		add: #removeButton expand: false fill: false padding: 5;		vAlignStart;		yourself! !!TeaKeyValueInput class methodsFor: 'instance creation'!key: keyString value: valueString removeAction: aBlock	^ self new		setKey: keyString 		value: valueString		removeAction: aBlock! !!TeaKeyValueInput methodsFor: 'converting'!asAssociation	^ keyInput text -> valueInput text! !!TeaKeyValueInput methodsFor: 'initialization'!initializePresenters	keyInput := self newTextInput placeholder: 'key'; yourself.	valueInput := self newTextInput placeholder: 'value'; yourself.	removeButton := self newButton label: 'Remove'; yourself.	self focusOrder		add: keyInput;		add: valueInput;		add: removeButton.		! !!TeaKeyValueInput methodsFor: 'accessing'!keyInput	^ keyInput! !!TeaKeyValueInput methodsFor: 'accessing'!removeButton	^ removeButton! !!TeaKeyValueInput methodsFor: 'initialization'!setKey: keyString value: valueString removeAction: aBlock	keyInput text: keyString.	valueInput text: valueString.	removeButton whenActionPerformedDo: [ aBlock value: self ].	^ self! !!TeaKeyValueInput methodsFor: 'accessing'!valueInput	^ valueInput! !!TeaKeyValueList methodsFor: 'protocol'!addKey: keyString value: valueString	| item |	item := TeaKeyValueInput 		key: keyString 		value: valueString 		removeAction: [ :teaKeyValueInput | self remove: teaKeyValueInput ].	items add: item.	self rebuildLayout.! !!TeaKeyValueList methodsFor: 'private'!asAssociations	^ items collect: #asAssociation! !!TeaKeyValueList methodsFor: 'initialization'!defaultLayout	^ SpBoxLayout new! !!TeaKeyValueList methodsFor: 'initialization'!initialize	super initialize.	items := OrderedCollection new.! !!TeaKeyValueList methodsFor: 'protocol'!items	^ self withoutDuplicatesAndBlanks: (self asAssociations asOrderedDictionary)! !!TeaKeyValueList methodsFor: 'protocol'!items: keyedCollection	items removeAll.	keyedCollection keysAndValuesDo: [ :key :value | self addKey: key value: value ].! !!TeaKeyValueList methodsFor: 'initialization'!layout 	| box |	box := SpBoxLayout newVertical		spacing: 5;		vAlignStart;		yourself.	items do: [ :teaKeyValueInput | box add: teaKeyValueInput ].	^ items 		ifEmpty: [ box ] 		ifNotEmpty: [ SpScrollableLayout with: box ]! !!TeaKeyValueList methodsFor: 'private'!remove: item	items remove: item.	self rebuildLayout.! !!TeaKeyValueList methodsFor: 'private'!withoutDuplicatesAndBlanks: keyedCollection	| keyset |	keyset := PluggableSet new		equalBlock: [ :a :b | a key = b key ];		hashBlock: [ :x | x key hash ];		yourself.					keyedCollection keysAndValuesDo: [ :key :value | 		keyset add: (key -> value) ].	^ keyset reject: [ :each | 		each key isEmptyOrNil or: [ each value isEmptyOrNil ] ]! !!TeaRequestBodyTabs class methodsFor: 'layout'!defaultLayout	^ SpBoxLayout newVertical 		add: #label expand: false fill: false;		spacing: 5;		add: #requestBody expand: true fill: true;		yourself! !!TeaRequestBodyTabs methodsFor: 'private'!formTabTitle	^ 'Form'! !!TeaRequestBodyTabs methodsFor: 'initialization'!initializePresenters	label := self newLabel label: 'Request body'; yourself.	requestBody := self newRequestBody.! !!TeaRequestBodyTabs methodsFor: 'accessing'!label	^ label! !!TeaRequestBodyTabs methodsFor: 'initialization'!newRequestBody	raw := self newText.	form := TeaFormTab new.	^ self newNotebook 		addPageTitle: self rawTabTitle provider: raw; 		addPageTitle: self formTabTitle provider: form;		whenSelectedPageChangedDo: [ :selected | 			selected title = self formTabTitle				ifTrue: [ form updateKeyValus: ('?' , raw text) asUrl query ]				ifFalse: [ form writeUrlEncodedTo: raw ] ];		yourself! !!TeaRequestBodyTabs methodsFor: 'private'!rawTabTitle	^ 'Raw'! !!TeaRequestBodyTabs methodsFor: 'accessing'!requestBody	^ requestBody! !!TeaRequestBodyTabs methodsFor: 'protocol'!urlEncoded	requestBody selectedPage title = self formTabTitle		ifTrue: [ raw text: form urlEncoded ].	^ raw text! !!Teaspoon class methodsFor: 'layout'!defaultLayout    ^ SpBoxLayout newVertical         add: (SpBoxLayout newHorizontal                    vAlignCenter;                    add: #methodDropList expand: false fill: false;                    spacing: 5;                    add: #urlInput expand: true fill: true;                    yourself)             expand: false fill: false padding: 10;        add: #requestBody expand: true fill: true;        add: (SpBoxLayout newHorizontal                vAlignCenter;                add: #contentTypeLabel expand: false fill: false;                spacing: 5;                add: #contentTypeDropList expand: true fill: true;                yourself)            expand: false fill: false;        spacing: 10;				  add: #resultLabel expand: false fill: false;        add: #resultText expand: true fill: true;        add: (SpBoxLayout newHorizontal                 add: #execButton expand: false fill: false;                hAlignCenter;                yourself)            expand: false fill: false;        yourself! !!Teaspoon class methodsFor: 'private - accessing'!iconProvider	^TeaIconProvider ! !!Teaspoon class methodsFor: 'world menu'!menuCommandOn: aBuilder 	<worldMenu> 		(aBuilder item: #'Teaspoon')	 		help: 'Teaspoon'; 		parent: #'Tools' translated;		icon: self iconProvider teaspoonIcon;		action: [ self open ].! !!Teaspoon class methodsFor: 'interface'!open	<script>	^ (SpWindowPresenter presenter: self new)		initialExtent: 600@600;		open;		yourself! !!Teaspoon class methodsFor: 'specs'!title	^ 'Teaspoon client'! !!Teaspoon methodsFor: 'private'!client	^ ZnClient new		url: self urlInput text;		method: self methodDropList selectedItem;		entity: (ZnStreamingEntity 			readFrom: (ReadStream on: requestBody urlEncoded)			usingType: self contentTypeDropList selectedItem			andLength: requestBody urlEncoded size)		yourself! !!Teaspoon methodsFor: 'initialization'!connectPresenters 	execButton		whenActionPerformedDo: [ 			self urlInput text notEmpty				ifTrue: [ 					self resultText text: ''.					self resultText text: self client execute.				] 		]! !!Teaspoon methodsFor: 'accessing'!contentTypeDropList	^ contentTypeDropList! !!Teaspoon methodsFor: 'accessing'!contentTypeLabel	^ contentTypeLabel! !!Teaspoon methodsFor: 'accessing'!execButton	^ execButton! !!Teaspoon methodsFor: 'initialization'!initializePresenters	super initializePresenters.	methodDropList := self newMethodDropList.	urlInput := self newTextInput autoAccept: true; text: 'http://localhost:1701/'; yourself.	requestBody := TeaRequestBodyTabs new.	contentTypeLabel := self newLabel label: 'Content Type'; yourself.	contentTypeDropList := self newContentTypeDropList.	execButton := self newButton label: 'Execute request'; yourself.	resultText := self newText.	resultLabel := self newLabel label: 'Result'; yourself.! !!Teaspoon methodsFor: 'tea spoon'!method: methodString url: urlString port: portNumber	self populateMethod: methodString.	self populateUrl: urlString port: portNumber.! !!Teaspoon methodsFor: 'accessing'!methodDropList	^ methodDropList! !!Teaspoon methodsFor: 'initialization'!newContentTypeDropList	| dropList |	dropList := self newDropList.	#(		applicationFormUrlEncoded 		applicationJson 		applicationXml 		applicationSton 		applicationOctetStream 		text 		textHtml 		textPlain	) do: [ :each | dropList addItemLabeled: (each value: ZnMimeType) do: [] ].		^ dropList! !!Teaspoon methodsFor: 'initialization'!newMethodDropList	| dropList |	dropList := self newDropList.	ZnConstants knownHTTPMethods do: [ :each | 		dropList addItemLabeled: each do: [] ].	^ dropList! !!Teaspoon methodsFor: 'private'!populateMethod: methodString	| selected |	selected := methodDropList listItems		detect: [ :each | each = methodString ]		ifNone: [ methodDropList listItems first ].	methodDropList selectItem: selected.! !!Teaspoon methodsFor: 'private'!populateUrl: urlString port: portNumber	| pathSegment |	pathSegment := urlString.	(pathSegment beginsWith: '/') 		ifFalse: [ pathSegment := '/', pathSegment ].		urlInput text: ('http://localhost:', portNumber asString, pathSegment)! !!Teaspoon methodsFor: 'accessing'!requestBody	^ requestBody! !!Teaspoon methodsFor: 'accessing'!resultLabel	^ resultLabel! !!Teaspoon methodsFor: 'accessing'!resultText	^ resultText! !!Teaspoon methodsFor: 'accessing'!urlInput	^ urlInput! !!TeaRxUrlPattern methodsFor: '*Teapot-Tools'!asTeaspoonPath	^ '/'! !!ManifestTeapotTools class methodsFor: 'code-critics'!ruleLongMethodsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#Cupboard #inspectTeapot: #false)) #'2022-08-29T16:00:19.64012+02:00') )! !!TeaUrlPatternSet methodsFor: '*Teapot-Tools'!asRequestBuilderPath	^ patterns 		ifEmpty: [ '/' ]		ifNotEmpty: [ patterns first asTeaspoonPath ]! !!TeaUrlPatternSet methodsFor: '*Teapot-Tools'!asTeaspoonPath	^ patterns 		ifEmpty: [ '/' ]		ifNotEmpty: [ patterns first asTeaspoonPath ]! !!Teapot methodsFor: '*Teapot-Tools'!browse	WebBrowser openOn: 'http://localhost:', self server port asString! !!Teapot methodsFor: '*Teapot-Tools'!inspectAfterFilter: aBuilder	<inspectorPresentationOrder: 0 title: 'After Filters'>	| list |	^ (list := SpListPresenter new)		items: compositeRouter afterFilters;		display: [ :filter | filter requestMatcher ];		contextMenu: (SpMenuPresenter new 			addItem: [ :item | 				item					name: 'Remove filter';					action: [ 						self removeAfterFilter: list selectedItem.						list refresh ] ]);				yourself! !!Teapot methodsFor: '*Teapot-Tools'!inspectBeforeFilter: aBuilder	<inspectorPresentationOrder: 0 title: 'Before Filters'>	| list |	^ (list := SpListPresenter new)		items: compositeRouter beforeFilters;		display: [ :filter | filter requestMatcher ];		contextMenu: (SpMenuPresenter new 			addItem: [ :item | 				item					name: 'Remove filter';					action: [ 						self removeBeforeFilter: list selectedItem.						list refresh ] ];			yourself);  		yourself! !!Teapot methodsFor: '*Teapot-Tools'!inspectDynamicRoutes: aBuilder	<inspectorPresentationOrder: 0 title: 'Dynamic routes'>      	| list |	^ (list := SpListPresenter new)		items: dynamicRouter routes;		display: [ :route | route printString ];		contextMenu: (SpMenuPresenter new 			addItem: [ :item | 				item					name: 'Remove route';					action: [ 						self removeDynamicRoute: list selectedItem.						list refresh ] ];			yourself);   				yourself.! !!Teapot methodsFor: '*Teapot-Tools'!removeAfterFilter: aFilter	compositeRouter afterFilters remove: aFilter! !!Teapot methodsFor: '*Teapot-Tools'!removeAllAfterFilters 	compositeRouter afterFilters removeAll! !!Teapot methodsFor: '*Teapot-Tools'!removeAllBeforeFilters 	compositeRouter beforeFilters removeAll! !!Teapot methodsFor: '*Teapot-Tools'!removeAllDynamicRoutes 	dynamicRouter routes removeAll! !!Teapot methodsFor: '*Teapot-Tools'!removeBeforeFilter: aFilter	compositeRouter beforeFilters remove: aFilter! !!Teapot methodsFor: '*Teapot-Tools'!removeDynamicRoute: aRoute	dynamicRouter routes remove: aRoute! !!TeaGlobUrlPattern methodsFor: '*Teapot-Tools'!asTeaspoonPath	^ String streamContents: [ :aStream |			segments 				do: [ :each | each printOn: aStream ]				separatedBy: [ aStream nextPut: $/ ] ]! !!TeaIconProvider class methodsFor: 'private - icons'!form: base64String	^ Form fromBinaryStream: (base64String base64Decoded asByteArray readStream)! !!TeaIconProvider class methodsFor: 'accessing'!icons	IconCache ifNil: [ IconCache := Dictionary new ].	^IconCache! !!TeaIconProvider class methodsFor: 'icons'!teapotIcon	^ self icons			at: #'teapotIcon'			ifAbsentPut: [ self form: self teapotIconContents ]! !!TeaIconProvider class methodsFor: 'private - icons'!teapotIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABhklEQVR42rWSPSxDURTHzzmvr8TyRBP00Y1BQiwiRD+YkKiPyWqTSDAZjUaj2SyS0lbEpNWPRCTEYBeNKrv4qN57nFYiPoqXNM7Nzcs799zf/Z//vQg1Bv4rIO4LdDCgF5FPwrn0s2PAdmsf1RkNvbK6KbMLGGaR4SCcTz19A0S8A3NkGo/TuexWORG1A/2MvE9EHuQ3PsuQeFFcWjXQtaEVjpHBzZLexj07cK4Je1jTKBn6khmzCNzyJo7h41dAD8z6FJEs+TuT1hijdnAICdJS8ShFRSlv/Ms4Zp6ZzKd2Y75gBqM+v9DoChgt587zsrtObRSLdFFpMm4Hk0AQcgpw89N6CdyHCnGtAthp93e6gI6l0yZ08DTEi1NibSmCpffqeFvILF+C3MD47/LFK8Y9MNRiOJe5+3RczDviYXpJisvdP+wXo2FCVCbC10dc9SHF7eF6QD2vUC8Qkkf0uiT9wFon5OSVqUL65oui6hGxBy3TMMsAU+Y9Ki5M3KZ1lZZqi5oBr2z5j75RN5raAAAAAElFTkSuQmCC'! !!TeaIconProvider class methodsFor: 'icons'!teapotInspectIcon	^ self iconNamed: #'glamorousInspect'! !!TeaIconProvider class methodsFor: 'icons'!teapotRefreshIcon	^ self iconNamed: #'glamorousRefresh'! !!TeaIconProvider class methodsFor: 'icons'!teapotServerIcon	^ self icons			at: #'teapotServerIcon'			ifAbsentPut: [ self form: self teapotServerIconContents ]! !!TeaIconProvider class methodsFor: 'private - icons'!teapotServerIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC0UlEQVR4Xo2SbU+SURzG+RS2hDdufQBtM0e58GHa8o2W3mbWkjbLhzURTTNEHnwowNKG2oM6JUWF2+fHTJ2aJaFCPlAzJygGOMPM8qF8wqtbXli2rK7t2v7n7Fy/c8520fbk4nKEkZkpIUViKckXSEj9qBEjehNG3kxDILxLenoyCVdXVwbtMHl7s4hJ4ypsi1uUHbDad2Fz2kGtd2G2bWBIZ0Jz6wvLHtDL69RBIIvlS2hGFqEbW4FhcgWmuU0YzduYNu9QswOmDw7MWhwUaAe2Tw7M29dxIyGV3Af4+voR3X1mDAwuoLd/Hl09c9Q8D/34MgVcxYz1O+yft2Ff3sTYWxvKK/oRxU44CGhpe4/Orlm0tk+joWkS6toJ1KhHoax5jdLyPsgLn0GUrUZMnBTnw64jPj7lIEBNjqK+8R1U5DiU1XqUP9WitGwQfEEJMgRS5D8ohrJKjampKQhF9+HjG8j9BeBPlCk0qFDqUKbQ4knJSzwsom6Vd1N/lcJgMGBraxvf1jfw5es64mJvwfMEk9gHBAaeIeQFXXhcPIDCwl7k5z9HrqwDUkkL2Ox0aLXDWFvbwsLCMmZm7QgJYeNsUNBPgLu7B1MirUdeXidk0nbkZDdBLKqjXIuIiBS0tXXBal2C0bSEVxoTgoOjQGfQD/YiLU1MioQqZ1AoUEOQoYZISCI8PBnVNc2YMFiocpnR1jEM9lUO/lioa9FJZDqvygnYsxNwIQmKikYqbMGAZgbquh4kcsU4tJUyWYklg6/aBxDhXBQ9UkE3/hGDQzNIThUg5BxbcyjgKFVRHk9uEWSonIAwgoukm3eo0CW4uR1DQEAktRdN0v4md4/jTA4n17L3ipjYe2D5ROK0z0VcTuSBL6zElajYPNq/5OcfQGRlKZHAKaLal4/bPAXkBa3IypZr6HQ6g/Y/8vI6SVRW9qChUYPsnCJNaGgE9/czPwCyhvLlWzqQAwAAAABJRU5ErkJggg=='! !!TeaIconProvider class methodsFor: 'icons'!teapotServerStartIcon	^ self icons			at: #'teapotServerStartIcon'			ifAbsentPut: [ self form: self teapotServerStartIconContents ]! !!TeaIconProvider class methodsFor: 'private - icons'!teapotServerStartIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADR0lEQVR4Xn2T71fTZRyG+S804RV56k3Hc6jciTpHICnNOnVYfCWhCZiiCAxGlEbbhCg2TjQdIYlCwWIIU0crDhAiiOA8xL6B4kFqG7+22QYRHCL5Nbia7ByOnNPpc859zvPmup7nOef+hDw5JzOydQWfaU0qtdYkDjro/9VJv2in8lKdVaMtNUkkksiQ/xtr3ygu3yqe6TU8U4+zHjgHM/FwmT5xFMtP3S71GY1JocjT7dgRGrZF0NH1O+LdBe7en8c+tohzfBXHmB/HhB/n5BpjrkA8fh4GLnB7/0aRm2/aImhpG6LH6qOz20N7xwQ3ezzYBv/i3vBCAF7CN7PK1NwyA0Muqr69wcmMj7cKmiw22q6P09xip8nyANPVIeobBqhv/IXq7zopK2+l4PNG0k5oiBfSSUxM1W0RNDRaMf8wTOOVe9TVi9QY+rhY1UthkQGlUsPZc5UYjSbsdgenPikmIkIibMK7JS9G5p0vIfF8Dqll+ZRUmKmouIlef52c3HOINhsrKys8+meZ2dkFUlKziY19LSiQ7JUIh5vep2SgmNbJFgy/1XC09SgHNXI0xRbSjmvo6uxiIQB7vbPYHX8glaYSFxcnhGx7altYglmgxl5Ns+tHFlcfMTI3TJ2zluzeLA4pPyLlSCENDddwu2dwOP+kq/tB4P/pbNwe/UGU7thtGbXOSuaX51hfX9+IdfoW+pESdpdHkpx6hksXjQzdn6TfNo7Z0kumXBUUPK/YZZKLR5ha9G7Cj+Nf82NxX+E5YziyFCXlFbXYRDc9t0epu9yCUlUaFLycJzEliq9TMfkF7TPmALyGb9nDhUkN6hE5uy4/TVLyp3xZWoU46KM30FZ5zile3SsNdkCaJdW9eecF0u1vUT+t3xC4lhx86BQ4OPgKMd/EIktWkZmlJu5dGeHhO9m3T4bscEZQEBoWGpbbeZwi1zF+nq8LvmBlgq+8uSTciiFNpSUzs4zomCT2RL9HUk4+6oLv2f/GO4rNDhx4+4CQcTXFVTRygralKmqnNMithyisLrBqtUYUiguB9p3ldH4N+q+bAxU+bfrPbYzaHyVsj9guPBv5jCB5Kbi6UXtiBIOhnWvmO3TcsBEfn6B4kvkXxV9YN+ClYBQAAAAASUVORK5CYII='! !!TeaIconProvider class methodsFor: 'icons'!teapotServerStaticIcon	^ self icons			at: #'teapotServerStaticIcon'			ifAbsentPut: [ self form: self teapotServerStaticIconContents ]! !!TeaIconProvider class methodsFor: 'private - icons'!teapotServerStaticIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADIElEQVR42l2Ta0gUURTH/1fHWVNz2dLNIinQ0shAKCsSixIp7EMQ7VKbH8SICopo6UFaiBqZBm5R1Bc1i7ZwJw1DlzbQfKTr9rA+aGX2MFbbNsu21Np259Gdcczwwsw5c+85vzn/e+8hoCM0NHThjh07KySJQBAl5BcUGUSRAEREWWkh19Ls4H788DkFQRjCjEHkV0xMrKGj+70tWquRcZBBygIkGkEQDATg9Qyjr/f5kL2p3vmw5QHn831XgEpcbKze0GDvs7FhGmgoIyJCQyEhNJ0ghBDlNyGyCZEQpqFw0Y+8XBN3395gVAB6vd5grX1s07Dh4IMieD6I8FlhiIyaBZZlEDmbQVQEo0j6NPwVz3sGcL26nGtttU8DKqvbbSyrQTDIq08QoijQPfHD7/fj14Qfo76f8AwPYmTkHSbGPnMOx71pwKXLDhsTxirJPD8JoBoxOPiSKhjFnDk6KlWLtFWpuHW7EdVVl8xu96BFBcwznCu/a2MYdjo5QEECjzdve7BvbzaSkpKpPAEBXsDJE8WotVUaR0e/cQogLi7OkF9ww8Zq6B4EJgFysCjyePXahf37tyElJRXj4xP49TsI85HjcLkcRo/Hw5HVaQlRSUv0pdu3rj/IIAj30E/09Osxf8EKMAxDAY+Rk5OF1NSV8P8BPnt9OF9WjMamm/ECT48xL3fzoePmLSW6CEYLegISL6HD9RFdL3jodDqMfHEjOTke0XOTkLw8HV7vF9zhrKi5dlGpnpwpybHmH0s3EZ5+C/Tq8HRSkFQ7OQfqV9S+QtrGw/B8eg9nZycuWApVQNFua8HRDJMcJKnBRJj0CfX/Abh+rM06hPq6Gjx1PXO2tTWtUwAlhbsoYINJDpbUBKLCiJoszx04WwfHow9ITFyNsXEv1+1sNiqA4tNG6ynzRhNouUSYgkhqJdMS9pzhEIhbg8XaZXDYr1qePOkyK4CiUwbr6SOZJjJTgmqnAEevtGJRym709j50VlVeNE51Jtm0IcWcmbE0WxLpCdBWlgQRoFdY9sfG/PqYeQkr5IZqfzrg7n/nsQwM9Fv+b+e/lwaeIIipiHQAAAAASUVORK5CYII='! !!TeaIconProvider class methodsFor: 'icons'!teapotServerStopIcon	^ self icons			at: #'teapotServerStopIcon'			ifAbsentPut: [ self form: self teapotServerStopIconContents ]! !!TeaIconProvider class methodsFor: 'private - icons'!teapotServerStopIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADO0lEQVR4Xn2T7U+TVxiH+xdsGfso0Q+Gbh+UBYFEsjeSzS6yKWDWdKyMurEXytDyVsfcKHRtFKdWRFyljxoiVbEoq3vxPVM2qKwd5XXZYK30BYotuEXWQaSUa8/GdDZLdidX7i/nvk7OOb8jebhK399uqtfvsdXqGmx9A15cbi9Ot4cWi9VRUrLNtGnTZrnk/6q710swHCM0vchkeInJyH3iTIQX+WHAj6vPw8e1u2ylpRrTunXpWQmCq9+M4h6KMjByl7HxOby+RTzjcbx+kcAStwJxxicWRVmc8K/3uHSlhwTB1xeH+c4R4XpXiCvXAlz/Nige4w6DI7/j8c8zNR1j5m6MUe805+xOzC32REGn3cXlq36+uuDh8/M/Yzs7zKn2fto7XAitN2g+chljQwea8kMoCspQKsscCYJT7T102n/iTMcQJ0+7aT3hRDjWw8HmC2zbvpP9piMcP96G0+nCaj1NXv5W24PhZLGExjO06Fux7LdjOdrNZ+YbHGy6hmFXO21tVhYWYszP32N2do69ew/xVrFmWaDKzatoK1IFbxoM/GhpoddoxKpS0/CBwO7dX1Dz4TGaD5uZm1sgEpklEJihvEJHdfVHNsnG7Gz5RaUSryA84NY/vXOLAl25mR07BOrqDExMzuAL/IZ78DbKwjLS0jLlEqtCERyqqmasvp5fHmJUZKSmhk8zXxJ3sqDV1jI8EqSv3ye+zCQvv1LIixtkcok9dS1Rv49YNCryR0JfiM5yMvNpqkSBpnwn/YMhurq99Nz0kpPzOiuSVyRLvpRKmQuFiC/F/0s8ztn09VRWmSlRa+l1BcWQ3WHPvhaKVGXLGegqKGAsO5tg7mZuFxYSURUxVfgGvtw8RmUyhLTnqKg0o3jtXd4s1iBNeZL1WTL0emFZ8Iw0Rf79Y0kEVq4kLBJZtYopsY+LOB55FJ2qXrwDgRc2bOXZ5xW8qq5AU3kYXd2Bf0O0JUVaMZiRQTQ3l/miImbz8xlIz0AoUTuamjqo1gq8856JKu1R9h04T2OjNZia+lTiR0p9Qppl3JhjM65ZYzPIZLa1q1f/vSAp6fHkE9ZLdJzrRv9Jk6P4bbXpr9Ddn/sTU0VgFvyaFxkAAAAASUVORK5CYII='! !!TeaIconProvider class methodsFor: 'icons'!teaspoonIcon	^ self icons			at: #'teaspoonIcon'			ifAbsentPut: [ self form: (self teaspoonIconContents) ]! !!TeaIconProvider class methodsFor: 'private - icons'!teaspoonIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABdklEQVR42mNkoBAwgoiJs6fLvHv/oe/d27cM6urqTxQVFfq8HV2fEG1AQ1f7qlevX4XCBDk5OBnExcWLynLy+4kyIK+idNWfv39C0SUNDQz7U6PjiggaMG3+3L4r164UokvycPMwdDU0MxI0YNfhgzK7du96/O37NwwFCfEJYWY6+qvxGgACPdMmF967f68PXYG8nHxYeW4BYQNAYM6yxX23bt0q/PL1C1xMVFRsdWNZZRhRBsDA8YtnQw8ePMTw8+fP0JevXoby8vCu7qxvCiPaAGRQ2dyw6uOnj6FArzzR09Oz9LR3ekKSASDQNWXi4wcPH8hwc3E/YefgsGyprHlCkgGgWNqzd89xYNjIMDMxP2FkZLSc1NH9hGgDQKCuo1Xm/fv3x//++yvDyMD4hIWV1XJiW+cTog0AAWCKlfn79+/x/wz/ZZiZmZ+oKCtbkmQACORXlcv8//fvODDpy0hJSh0n2QAQmDx3lsynT59W/fnz5wkA2dSUkQj2i7UAAAAASUVORK5CYII='! !!TeaRequestMatcher methodsFor: '*Teapot-Tools'!urlPattern	^ urlPattern! !"Teapot-Tools"!!TeaTestClient commentStamp: '' prior: 0!Http client for testing.!!TeaUrlPatternTest methodsFor: 'private'!pattern: patternString matches: urlString	| placeholders |	placeholders := Dictionary new.	self assert: ((TeaGlobUrlPattern parseString: patternString) matchesUrl: urlString asUrl placeholders: placeholders).	^ placeholders! !!TeaUrlPatternTest methodsFor: 'private'!pattern: patternString noMatch: urlString	| placeholders |	placeholders := Dictionary new.	self deny: ((TeaGlobUrlPattern parseString: patternString) matchesUrl: urlString asUrl placeholders: placeholders).	^ placeholders! !!TeaUrlPatternTest methodsFor: 'tests'!testLongerPatternEndedPlaceholder	self pattern: '/a/b/<id>' noMatch: '/a/b'.! !!TeaUrlPatternTest methodsFor: 'tests'!testLongerPatternEndedWildcard	self pattern: '/a/b/c/*' matches: '/a/b/c'.	self pattern: '/1/2/3/*/*' matches: '/1/2/3'.		self pattern: '/a/b/c/*' noMatch: '/a/b'.! !!TeaUrlPatternTest methodsFor: 'tests'!testNoWildcard		self pattern: '/aa' matches: '/aa'.	self pattern: '/aa' noMatch: '/bb'.! !!TeaUrlPatternTest methodsFor: 'tests'!testPlaceholderSubstitute	| placeholders |		placeholders := self pattern: '/<id>/a/b' matches: '/123/a/b'.	self assert: (placeholders at: #id) equals: '123'.		placeholders := self pattern: '/a/<id>/b' matches: '/a/25/b'.	self assert: (placeholders at: #id) equals: '25'.		placeholders := self pattern: '/a/b/<id>' matches: '/a/b/xyz'.		self assert: (placeholders at: #id) equals: 'xyz'.		! !!TeaUrlPatternTest methodsFor: 'tests'!testPlaceholderTypeMatch	| placeholders |	placeholders := self pattern: '/<id:IsInteger>' matches: '/12'.	self assert: (placeholders at: #id) equals: 12.		placeholders := self pattern: '/<id:IsInteger>/abc' matches: '/-34/abc'.	self assert: (placeholders at: #id) equals: -34.		placeholders := self pattern: '/<float:IsNumber>/<int:IsNumber>' matches: '/3.14/3'.	self assert: (placeholders at: #float) equals: 3.14.	self assert: (placeholders at: #int) equals: 3.	! !!TeaUrlPatternTest methodsFor: 'tests'!testPlaceholderTypeNoMatch	self pattern: '/<id:IsInteger>' noMatch: '/foobar'.		self pattern: '/<id:IsNumber>' noMatch: '/foobar'.	self pattern: '/<id:IsInteger>' noMatch: '/12.3'.		! !!TeaUrlPatternTest methodsFor: 'tests'!testPlaceholders	self pattern: '/<id>/a/b' matches: '/1/a/b'.	self pattern: '/a/<id>/b' matches: '/a/2/b'.	self pattern: '/a/b/<id>' matches: '/a/b/1'.			self pattern: '/<id>/a/b' noMatch: '/1/a/c'.	self pattern: '/a/<id>/b' noMatch: '/a/2/c'.	self pattern: '/a/b/<id>' noMatch: '/a/c/1'.! !!TeaUrlPatternTest methodsFor: 'tests'!testRoot	self pattern: '/' matches: '/'.		self pattern: '/' noMatch: '/a'.		self pattern: '/a' noMatch: '/'.	self pattern: '/a/b' noMatch: '/'.	! !!TeaUrlPatternTest methodsFor: 'tests'!testShorterPatternEndedPlaceholder	self pattern: '/a/b/<id>' noMatch: '/a/b/1/2'.	! !!TeaUrlPatternTest methodsFor: 'tests'!testShorterPatternEndedWildcard	 	self pattern: '/a/*' matches: '/a/b/c'.	self pattern: '/*' matches: '/1/2/3'.	 	self pattern: '/a/*' noMatch: '/b/b/c'.	self pattern: '/a/b' noMatch: '/a/b/c'.	! !!TeaUrlPatternTest methodsFor: 'tests'!testTralingSlash	self pattern: '/a/b' matches: '/a/b/'.! !!TeaUrlPatternTest methodsFor: 'tests'!testWildcards	self pattern: '/*/1/2' matches: '/0/1/2'.	self pattern: '/a/b/*' matches: '/a/b/c'.	self pattern: '/x/*/z' matches: '/x/y/z'.		self pattern: '/*/1/2' noMatch: '/a/1/z'.		self pattern: '/a/b/*' noMatch: '/a/1/z'.		self pattern: '/x/*/z' noMatch: '/a/1/z'.						! !!TeapotAbortTest methodsFor: 'running'!setUp	server := Teapot on		GET: 'badrequest' -> [ :req | req abort: (ZnResponse badRequest: req) ];		GET: 'unauthorized' -> [ :req | req abort: TeaResponse unauthorized ];		GET: 'abortstring' -> [ :req | req abort: 'abort test' ];				start.! !!TeapotAbortTest methodsFor: 'running'!tearDown	server stop! !!TeapotAbortTest methodsFor: 'tests'!testAbortSupportsAnyObject	self assert: (TeaTestClient httpGetString: '/abortstring') equals: 'abort test'.! !!TeapotAbortTest methodsFor: 'tests'!testErrorCodes	self assert: (TeaTestClient httpGet: '/badrequest') code equals: 400.	self assert: (TeaTestClient httpGet: '/unauthorized') code equals: 401.! !!TeapotAfterTest methodsFor: 'running'!setUp	server := Teapot on		after: '/after/<param>' -> [ :req :resp | resp headers at: 'header-key' put: (req at: #param) ];		GET: '/after/*' -> 'after-return';				start		! !!TeapotAfterTest methodsFor: 'running'!tearDown	server stop! !!TeapotAfterTest methodsFor: 'tests'!testAfterFilterCanModifyResponse	| response |		response := TeaTestClient httpGet: '/after/header-value'.	self assert: response entity string equals: 'after-return'.	self assert: (response headers at: 'header-key') equals: 'header-value'.		response := TeaTestClient httpPost: '/after/notfound'.	self assert: response code equals: 404.	self assert: (response headers at: 'header-key') equals: 'notfound'.! !!TeapotBeforeTest methodsFor: 'private'!forbidden	^ ZnResponse new		statusLine: ZnStatusLine forbidden;		headers: ZnHeaders defaultResponseHeaders;		yourself! !!TeapotBeforeTest methodsFor: 'private'!logRequest: aTeaRequest	log add: (aTeaRequest at: #user)! !!TeapotBeforeTest methodsFor: 'running'!setUp	log := OrderedCollection new.	server := Teapot on		before: '/secure/*' -> [ :req | ((req at: #user) = 'admin' and: [ (req at: #pass) = '****' ]) 			ifFalse: [ req abort: self forbidden ] ];		before: '*' -> (Send message: #logRequest: to: self);		before: '*' -> 'any';		GET: '/secure' -> 'protected';		GET: '/secure/1/2/3' -> 'protected';		POST: '/public' -> 'public';		start		! !!TeapotBeforeTest methodsFor: 'running'!tearDown	server stop! !!TeapotBeforeTest methodsFor: 'tests'!testAuthentication	self assert: (TeaTestClient httpGetString: '/secure?user=admin&pass=****') equals: 'protected'.	self assert: (TeaTestClient httpGetString: '/secure/1/2/3?user=admin&pass=****') equals: 'protected'.			self assert: (TeaTestClient httpGet: '/secure?user=user01&pass=****') code equals: 403.	self assert: (TeaTestClient httpGet: '/secure/1/2/3?user=user02&pass=****') code equals: 403.			self assert: (TeaTestClient httpPostString: '/public?user=any') equals: 'public'.! !!TeapotBeforeTest methodsFor: 'tests'!testMultipleBeforeHandlers	TeaTestClient httpGet: '/secure?user=admin&pass=****'.	TeaTestClient httpGet: '/secure/1/2/3?user=admin&pass=****'.		TeaTestClient httpGet: '/secure?user=user01&pass=****'. "403 before second filter"	TeaTestClient httpPost: '/public?user=pubuser'.					self assert: log asArray equals: #(admin admin pubuser).! !!TeapotDefaultFormatTest methodsFor: 'running'!setUp	server := (Teapot configure: { #defaultOutput -> #text })		GET: 'default' -> 'any';		GET: 'html' -> 'any'; output: #html;		start		! !!TeapotDefaultFormatTest methodsFor: 'running'!tearDown	server stop! !!TeapotDefaultFormatTest methodsFor: 'tests'!testDefault	self 		assert: (TeaTestClient httpGet: '/default') contentType 		equals: ZnMimeType textPlain! !!TeapotDefaultFormatTest methodsFor: 'tests'!testOverride	self 		assert: (TeaTestClient httpGet: '/html') contentType 		equals: ZnMimeType textHtml! !!TeapotEncodingTest methodsFor: 'running'!setUp	server := Teapot on		GET: 'enc' -> (TeaResponse ok 								body: 'árvíztűrő tükörfúrógép'; 								charSet: 'iso-8859-2');		start! !!TeapotEncodingTest methodsFor: 'running'!tearDown	server stop! !!TeapotEncodingTest methodsFor: 'tests'!testUserSpecifiedEncoding	| response |	response := TeaTestClient httpGet: '/enc'.	self 		assert: response entity string		equals: 'árvíztűrő tükörfúrógép'.			self 		assert: response contentType charSet		equals: 'iso-8859-2'! !!TeapotErrorHandlingTest methodsFor: 'private'!handleError: ex request: req	self assert: (ex isKindOf: Exception).	self assert: (req isKindOf: TeaRequest).	^ ZnResponse ok: (ZnStringEntity text: 'outofbounds/domainerror handled')! !!TeapotErrorHandlingTest methodsFor: 'running'!setUp	server := Teapot on		GET: '/zerodiv' -> [ 1 / 0 ];		GET: '/sub' -> [ #() at: 123 ];					GET: '/domain' -> [ -2 sqrt ];		GET: '/nonbool' -> [ NotYetImplemented signal ];		GET: '/keynotfound' -> [ KeyNotFound signal ];		exception: ZeroDivide -> [ :ex :req | 'zerodiv handled' ];		exception: SubscriptOutOfBounds, DomainError -> (Send message: #handleError:request: to: self);		exception: NotYetImplemented -> (ZnResponse ok: (ZnStringEntity text: 'nonbool handled'));		exception: KeyNotFound -> 42;		output: [ :resp :req | ZnResponse ok: (ZnStringEntity text: resp body printStringRoman) ];		start		! !!TeapotErrorHandlingTest methodsFor: 'running'!tearDown	server stop! !!TeapotErrorHandlingTest methodsFor: 'tests'!testHandlesExceptionSet	self assert: (TeaTestClient httpGetString: '/sub') equals: 'outofbounds/domainerror handled'.		self assert: (TeaTestClient httpGetString: '/domain') equals: 'outofbounds/domainerror handled'.		! !!TeapotErrorHandlingTest methodsFor: 'tests'!testHandlesOneException	self assert: (TeaTestClient httpGetString: '/zerodiv') equals: 'zerodiv handled'.	! !!TeapotErrorHandlingTest methodsFor: 'tests'!testTransformingErroHandlerResponse	self assert: (TeaTestClient httpGetString: '/keynotfound') equals: 'XLII'.! !!TeapotErrorHandlingTest methodsFor: 'tests'!testValueAsExceptionHandler	self assert: (TeaTestClient httpGetString: '/nonbool') equals: 'nonbool handled'.	! !!TeapotFormParamsTest methodsFor: 'running'!setUp	server := Teapot on		POST: '/form' -> [ :req | (req at: #foo), '-', (req at: #bar) ];		exception: TeaNoSuchParam -> 'no such param';		start.! !!TeapotFormParamsTest methodsFor: 'running'!tearDown	server stop! !!TeapotFormParamsTest methodsFor: 'tests'!testFormParams	| result |	result := ZnEasy post: 'http://localhost:1701/form' data: (ZnApplicationFormUrlEncodedEntity new 		at: 'foo' put: 'abc'; 		at: 'bar' put: '123'; 		yourself).	self assert: result entity string equals: 'abc-123'.! !!TeapotFormParamsTest methodsFor: 'tests'!testFormParamsNotFound	| result |	result := ZnEasy post: 'http://localhost:1701/form' data: (ZnApplicationFormUrlEncodedEntity new 		at: 'invalid1' put: 'abc'; 		at: 'invalid2' put: '123'; 		yourself).	self assert: result entity string equals: 'no such param'! !!TeapotFormatTest methodsFor: 'running'!setUp	server := Teapot on		GET: '/a' -> [ 4 ]; output: [ :resp :req | ZnResponse ok: (ZnStringEntity text: resp body printStringRoman) ];		GET: 'default' -> 'any';		GET: '/plain' -> 'any'; output: #text;		GET: 'xml' -> 'any'; output: (TeaOutput stringWithContentType: ZnMimeType applicationXml);		start		! !!TeapotFormatTest methodsFor: 'running'!tearDown	server stop! !!TeapotFormatTest methodsFor: 'tests'!testArbitraryContentType	self 		assert: (TeaTestClient httpGet: '/xml') contentType 		equals: (ZnMimeType applicationXml charSet: 'utf-8'; yourself)! !!TeapotFormatTest methodsFor: 'tests'!testConverting	self assert: (TeaTestClient httpGetString: '/a') equals: 'IV'.	! !!TeapotFormatTest methodsFor: 'tests'!testDefaultContentTypeIsHtml	self 		assert: (TeaTestClient httpGet: '/default') contentType 		equals: ZnMimeType textHtml! !!TeapotFormatTest methodsFor: 'tests'!testSetsContentType	self 		assert: (TeaTestClient httpGet: '/plain') contentType 		equals: ZnMimeType textPlain! !!TeapotMessageSendTest methodsFor: 'web controller'!msg1	^ 'msg1 result'! !!TeapotMessageSendTest methodsFor: 'web controller'!msg2Req: req nil: resp	self assert: resp isNil.	^ 'msg2 ', (req at: #param)! !!TeapotMessageSendTest methodsFor: 'web controller'!msg3Req: req	^ 'msg3 ', (req at: #param)! !!TeapotMessageSendTest methodsFor: 'running'!setUp	server := Teapot on		GET: '/msg1' -> (Send message: #msg1 to: self);		GET: '/msg2/<param>' -> (Send message: #msg2Req:nil: to: self);				GET: '/msg3/<param>' -> (Send message: #msg3Req: to: self);							start.		! !!TeapotMessageSendTest methodsFor: 'running'!tearDown	server stop! !!TeapotMessageSendTest methodsFor: 'tests'!testReceivingOneArgKeywordMessage	self assert: (TeaTestClient httpGetString: '/msg3/bar') equals: 'msg3 bar'.! !!TeapotMessageSendTest methodsFor: 'tests'!testReceivingTwoArgsKeywordMessage	self assert: (TeaTestClient httpGetString: '/msg2/foo') equals: 'msg2 foo'.! !!TeapotMessageSendTest methodsFor: 'tests'!testReceivingUnaryMessage	self assert: (TeaTestClient httpGetString: '/msg1') equals: 'msg1 result'.! !!TeapotPathParamTest methodsFor: 'running'!setUp	server := Teapot on		GET: '/user/<id>' -> [ :req | '1-', (req at: #id) ];		GET: '/user/<id>/create' -> [ :req | '2-', (req at: #id) ];		GET: '/<id>/<user>' -> [ :req | '3-', (req at: #id) ];						POST: '/user/<id>/create' -> [ :req | '4-', (req at: #id) ];		start.		! !!TeapotPathParamTest methodsFor: 'running'!tearDown	server stop! !!TeapotPathParamTest methodsFor: 'tests'!testPlaceholderAtLast	self assert: (TeaTestClient httpGetString: '/user/12') equals: '1-12'	! !!TeapotPathParamTest methodsFor: 'tests'!testPlaceholderFirst	self assert: (TeaTestClient httpGetString: '/54/user') equals: '3-54'.	! !!TeapotPathParamTest methodsFor: 'tests'!testPlaceholderInside	self assert: (TeaTestClient httpGetString: '/user/34/create') equals: '2-34'.		! !!TeapotPathParamTest methodsFor: 'tests'!testPlaceholderPost	self assert: (TeaTestClient httpPostString: '/user/789/create') equals: '4-789'.		! !!TeapotQueryParamsTest methodsFor: 'running'!setUp	server := Teapot on		GET: '/query' -> [ :req | req at: #foo ];		GET: '/queryopt' -> [ :req | req at: #foo ifAbsent: [ 'default' ] ];				start! !!TeapotQueryParamsTest methodsFor: 'running'!tearDown	server stop! !!TeapotQueryParamsTest methodsFor: 'tests'!testDefaultQueryParam	self assert: (TeaTestClient httpGetString: '/queryopt') equals: 'default'.	! !!TeapotQueryParamsTest methodsFor: 'tests'!testQueryParam	self assert: (TeaTestClient httpGetString: '/query?foo=bar') equals: 'bar'.	self assert: (TeaTestClient httpGetString: '/queryopt?foo=baz') equals: 'baz'.! !!TeapotRegexpTest methodsFor: 'running'!setUp	server := Teapot on		GET: '/./' asRegex -> [ 'regexp' ];		GET: '\w+(\d)/\d/xxx' asRegex -> [ :req | req at: 1 ];		GET: '/(\d)/([abc]+)/\d/(.*)' asRegex -> [ :req | (req at: 1), (req at: 2), (req at: 3) ];				start! !!TeapotRegexpTest methodsFor: 'running'!tearDown	server stop! !!TeapotRegexpTest methodsFor: 'tests'!testCollectingSubexpressions	self assert: (TeaTestClient httpGetString: '/abc3/4/xxx') equals: '3'.		self assert: (TeaTestClient httpGetString: '/1/aabbcc/2/foobar') equals: '1aabbccfoobar'.! !!TeapotRegexpTest methodsFor: 'tests'!testIgnoresQueryParam	self assert: (TeaTestClient httpGetString: '/k/?param=value') equals: 'regexp'.	! !!TeapotRegexpTest methodsFor: 'tests'!testRegexpMatch	self assert: (TeaTestClient httpGetString: '/k/') equals: 'regexp'.	! !!TeapotResponseTest methodsFor: 'running'!setUp	server := Teapot on		GET: '/test400' -> [ 			TeaResponse badRequest				body: 'malformed input';				headers: { 'my-header' -> 'my-value' } ];		start! !!TeapotResponseTest methodsFor: 'running'!tearDown	server stop! !!TeapotResponseTest methodsFor: 'tests'!testReturnsCustomCodeBodyAndHeaders	| response |	response := TeaTestClient httpGet: '/test400'.	self assert: response entity string equals: 'malformed input'.	self assert: response code equals: 400.	self assert: (response headers at: 'my-header') equals: 'my-value'.! !!TeapotReturnResponseTest methodsFor: 'running'!setUp	| stream |	stream := ZnStreamingEntity		readFrom: 'direct stream' readStream		usingType: ZnMimeType textHtml		andLength: 'direct stream' size.			server := Teapot on		GET: '/resp1' -> [ :req | ZnResponse ok: (ZnStringEntity text: 'direct response') ];		GET: '/resp2' -> (ZnResponse ok: stream);		GET: '/redirect' -> (ZnResponse redirect: '/redirect_location');		GET: '/redirect_location' -> 'redirected here';		start! !!TeapotReturnResponseTest methodsFor: 'running'!tearDown	server stop! !!TeapotReturnResponseTest methodsFor: 'tests'!testDirectStreamResponse	self assert: (TeaTestClient httpGetString: '/resp2') equals: 'direct stream'.	! !!TeapotReturnResponseTest methodsFor: 'tests'!testDirectStringResponse	self assert: (TeaTestClient httpGetString: '/resp1') equals: 'direct response'.	! !!TeapotReturnResponseTest methodsFor: 'tests'!testRedirect	self assert: (TeaTestClient httpGetString: '/redirect') equals: 'redirected here'.	! !!TeapotRouteSetTest methodsFor: 'running'!setUp	server := Teapot on		before: { '/secure/*' . '/protected/*' } -> [ :req | req abort: TeaResponse unauthorized ];			GET: {'/a'. '/b'. '/c'} -> 'abc';		POST: { '/x/<param>'. '/y/<param>' } -> [ :req | req at: #param ];		after: { '/a'. '/b' } -> [ :req :resp | resp headers at: 'test' put: 'ab' ];		start.! !!TeapotRouteSetTest methodsFor: 'running'!tearDown	server stop! !!TeapotRouteSetTest methodsFor: 'tests'!testMatchesAnyRouteInAfterFilter	| response |	response := TeaTestClient httpGet: '/a'.	self assert: (response headers at: 'test') equals: 'ab'.		response := TeaTestClient httpGet: '/b'.	self assert: (response headers at: 'test') equals: 'ab'.			response := TeaTestClient httpGet: '/c'.	self assert: (response headers at: 'test' ifAbsent: nil) equals: nil.! !!TeapotRouteSetTest methodsFor: 'tests'!testMatchesAnyRouteInBeforeFilter	| response |	response := TeaTestClient httpGet: '/secure/123'.	self assert: response code equals: 401.		response := TeaTestClient httpGet: '/protected/123'.	self assert: response code equals: 401.! !!TeapotRouteSetTest methodsFor: 'tests'!testMatchesAnyRouteInSet	self assert: (TeaTestClient httpGetString: '/a') equals: 'abc'.	self assert: (TeaTestClient httpGetString: '/b') equals: 'abc'.	self assert: (TeaTestClient httpGetString: '/c') equals: 'abc'.! !!TeapotRouteSetTest methodsFor: 'tests'!testMatchesAnyRouteInSetWithParams	self assert: (TeaTestClient httpPostString: '/x/value1') equals: 'value1'.	self assert: (TeaTestClient httpPostString: '/y/value2') equals: 'value2'.	! !!TeapotRoutingTest methodsFor: 'running'!setUp	| teapot |	teapot := Teapot configure: { #notFoundHandlerClass -> Tea405AwareNotFoundHandler }.	server := teapot		GET: '/' -> '1';		GET: '/a' -> '2';		POST: '/a' -> 'post';		GET: '/a/*/b' -> [ '3' ];		GET: '/*/c' -> [ '4' ];			GET: '/x/y/*' -> [ '5' ];		GET: '/x/*/*/z/*' -> [ '6' ];		GET: '/404' -> (ZnResponse notFound: '/custom');		any: 'any' -> 'any';		start.		! !!TeapotRoutingTest methodsFor: 'running'!tearDown	server stop! !!TeapotRoutingTest methodsFor: 'tests'!test404 	self assert: (TeaTestClient httpGet: '/1/2/3/4') code equals: 404! !!TeapotRoutingTest methodsFor: 'tests'!test405	| response |	response := TeaTestClient httpDelete: '/a'.	self assert: response code equals: 405.	self 		assert: (', ' split: (response headers at: 'Allow')) asSet		equals: #(GET POST) asSet.! !!TeapotRoutingTest methodsFor: 'tests'!testAnyMatchesToAnyHttpMethod 	self assert: (TeaTestClient httpGetString: '/any') equals: 'any'. 	self assert: (TeaTestClient httpPostString: '/any') equals: 'any'. 	self assert: (TeaTestClient httpPutString: '/any') equals: 'any'.	 	self assert: (TeaTestClient httpDeleteString: '/any') equals: 'any'.! !!TeapotRoutingTest methodsFor: 'tests'!testCustom404 	self assert: (TeaTestClient httpGetString: '/404') equals: 'Not Found /custom', String crlf! !!TeapotRoutingTest methodsFor: 'tests'!testMultipleWildcard	self assert: (TeaTestClient httpGetString: '/x/foo/bar/z/baz') equals: '6'.	self assert: (TeaTestClient httpGetString: '/x/foo/bar/z/baz/123') equals: '6'.	! !!TeapotRoutingTest methodsFor: 'tests'!testNoWildcard	self assert: (TeaTestClient httpGetString: '') equals: '1'.	self assert: (TeaTestClient httpGetString: '/a') equals: '2'.		! !!TeapotRoutingTest methodsFor: 'tests'!testWildcardEnd	self assert: (TeaTestClient httpGetString: '/x/y/foo') equals: '5'.		! !!TeapotRoutingTest methodsFor: 'tests'!testWildcardFirst	self assert: (TeaTestClient httpGetString: '/foo/c') equals: '4'	! !!TeapotRoutingTest methodsFor: 'tests'!testWildcardInside	self assert: (TeaTestClient httpGetString: '/a/bar/b') equals: '3'	! !!TeapotSslTest methodsFor: 'private'!pemContent	^ String streamContents: [ :stream | 		{'-----BEGIN CERTIFICATE-----'.'MIICAzCCAWwCCQDqdNQzO71rWzANBgkqhkiG9w0BAQUFADBFMQswCQYDVQQGEwJB'.'VTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJuZXQgV2lkZ2l0'.'cyBQdHkgTHRkMCAXDTE3MDYyNDA4MDM1OVoYDzIxMTcwNTMxMDgwMzU5WjBFMQsw'.'CQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJu'.'ZXQgV2lkZ2l0cyBQdHkgTHRkMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDk'.'ysKeTfdTjx0l573Ag4ITy80env0TfKGdyjlHkehuzQBQsg+DiyQs2Ckr9GaaZIOe'.'BW/6btvHG51aGG+Fz2WtHY4MetyLJ/zy5PlzjOeGvRwAUwla0JZX8fB8poKgNXkm'.'gVeuCA3PKPnE6Ba1ucofvdtIsDMqpbABLMxdjhvagQIDAQABMA0GCSqGSIb3DQEB'.'BQUAA4GBAEf6vsOCHtWJT760Wdm606TWpY+EbxKdXViEtWaDT0K91HBrGqBnSvgC'.'1ByDRKz1L3UyfUjgaP04Iuy3aAUtUZ188A4YfC1XLcYln3K/3NNP4+S272R09Nne'.'kV7vvJt4I8vubjEo3Ihassy4PVTwcf6JnUBIdK7p4k+yAupHjzof'.'-----END CERTIFICATE-----'.'-----BEGIN RSA PRIVATE KEY-----'.'MIICXQIBAAKBgQDkysKeTfdTjx0l573Ag4ITy80env0TfKGdyjlHkehuzQBQsg+D'.'iyQs2Ckr9GaaZIOeBW/6btvHG51aGG+Fz2WtHY4MetyLJ/zy5PlzjOeGvRwAUwla'.'0JZX8fB8poKgNXkmgVeuCA3PKPnE6Ba1ucofvdtIsDMqpbABLMxdjhvagQIDAQAB'.'AoGAG501XDIA1f8B/5820dONkaIZgcaiuQVj5E2SGEdODIGFtjenk7LpjNgSMBHx'.'iFT1Zc82Mr3KnP+CQGuOmlHr7XylvmFM29x/cLd4HSvZNdg6pMrzuv/ILC27GLfU'.'gDGAVmyeBiyMTOLk6TJ/LElIrt+HABaHaa43XH/mF3VjAoECQQDzc3aDXCOOBvlA'.'mV3TgMEIuP9vEq5dgdz7bYZSVutc605AYo/1c9TkmlMy722/abQm0IpT1XRNjTmc'.'HT+Y5gb5AkEA8JXcGS9T0L5Vl2cel9wiad5oNbLGfG17nQQUl3LXikfPrcBGDmD4'.'aoEZkScPx3gKfawwKw8wsUwus30aWZapyQJBAJ5IqftKQsuq+Q/pJznGcrsrHNio'.'urmNH5JRaY3LeYeWbfAqpRKfVwGy3Pk29pIHNdwupmFPXSi284fu9FSC6nECQQDV'.'w+IPwpyPcj7syuRE/ITbWpFvfQydjE30YqbFNnZLWKkv8hKNPh4by9/iuDlt+7we'.'k/ssl0+liVJJixP5nEP5AkB8dFXPvAsxeTHCPMwAsJlPnxRodktuY7SlEUqqEpex'.'yxwciD3/Fyai686sj5iYiOuy2xcxaFZvJ1K1J/aCvwhK'.'-----END RSA PRIVATE KEY-----'.} do: [ :line | stream nextPutAll: line; crlf ]]! !!TeapotSslTest methodsFor: 'private'!pemFile	^ FileLocator temp asFileReference / 'test-teapot-ssl.pem'! !!TeapotSslTest methodsFor: 'initialization'!setUp	self writeOutPemTo: self pemFile.	teapot := Teapot configure: { 		#znServer -> (			(ZnSecureServer on: 1443) 				certificate: self pemFile fullName;				yourself).	}.	teapot		GET: '/ssl' -> 'secure';		start.! !!TeapotSslTest methodsFor: 'running'!tearDown	teapot stop.	self pemFile delete.! !!TeapotSslTest methodsFor: 'tests'!testHttpsGet	self skip.	"| result |	result := ZnEasy get: 'https://localhost:1443/ssl'.	self assert: result equals: 'secure'."! !!TeapotSslTest methodsFor: 'private'!writeOutPemTo: aFileReference	aFileReference writeStreamDo: [ :stream | stream nextPutAll: self pemContent ]! !!TeapotStaticFilesTest methodsFor: 'private'!createTempHtdocs	| tmpHtdocs |	tmpHtdocs := FileLocator temp asFileReference / 'test_htdocs'.	tmpHtdocs createDirectory.	tmpHtdocs / 'index.html' writeStreamDo: [ :stream | stream nextPutAll: 'static index' ].	tmpHtdocs / 'a.txt' writeStreamDo: [ :stream | stream nextPutAll: 'a' ].	tmpHtdocs / 'b.txt' writeStreamDo: [ :stream | stream nextPutAll: 'static' ].	^ tmpHtdocs! !!TeapotStaticFilesTest methodsFor: 'running'!setUp	htdocs := self createTempHtdocs.	server := Teapot on		GET: 'here/are/statics/b.txt' -> 'dynamic';		serveStatic: 'here/are/statics' from: htdocs;		start! !!TeapotStaticFilesTest methodsFor: 'running'!tearDown	htdocs deleteAll.	server stop.! !!TeapotStaticFilesTest methodsFor: 'tests'!testDynamicContentServedBeforeStatic	self assert: (TeaTestClient httpGetString: '/here/are/statics/b.txt') equals: 'dynamic'.	! !!TeapotStaticFilesTest methodsFor: 'tests'!testStaticFile	self assert: (TeaTestClient httpGetString: '/here/are/statics/a.txt') equals: 'a'.	! !!TeapotStaticFilesTest methodsFor: 'tests'!testStaticIndexHtml	self assert: (TeaTestClient httpGetString: '/here/are/statics') equals: 'static index'.	! !!TeapotStaticFilesTest methodsFor: 'tests'!testStaticNotFound	self assert: (TeaTestClient httpGet: '/here/are/statics/notfound.txt') code equals: 404.	! !!TeapotStreamingTest methodsFor: 'private'!content	^ (ByteArray new: 4096 withAll: 65) asString! !!TeapotStreamingTest methodsFor: 'private'!createDownloadableFile	| file |	file := FileLocator temp asFileReference / 'download.file'.	file writeStreamDo: [ :stream | stream nextPutAll: self content ].	^ file! !!TeapotStreamingTest methodsFor: 'private'!deleteDownloadableFile	downloadFile delete! !!TeapotStreamingTest methodsFor: 'running'!setUp	downloadFile := self createDownloadableFile.	server := Teapot on		GET: '/stream' -> downloadFile readStream;		output: #stream;		start! !!TeapotStreamingTest methodsFor: 'running'!tearDown	self deleteDownloadableFile.	server stop.! !!TeapotStreamingTest methodsFor: 'tests'!testStreamingContent	self 		assert: (TeaTestClient httpGet: '/stream') contents asString 		equals: self content	! !!TeapotTeaResponseTest methodsFor: 'running'!setUp	server := Teapot on		GET: '/ok' -> (TeaResponse ok body: 'tested ok');		GET: '/badrequest' -> [:req | TeaResponse badRequest body: 'Bad Request'];		GET: '/created' -> [:req | TeaResponse created body: 'Created'; location: req url];		GET: '/notallowed' -> [:req | TeaResponse methodNotAllowed ];		GET: '/notfound' -> [:req | TeaResponse notFound ];		GET: '/notmodified' -> [:req | TeaResponse notModified ];		GET: '/redirect' -> (TeaResponse redirect location: '/target');		GET: '/servererror' -> (TeaResponse serverError body: 'tested server error');		GET: '/unauthorized' -> (TeaResponse unauthorized body: 'Unauthorized'; headerName: 'WWW-Authenticate' value: 'tested unauthorized');		start! !!TeapotTeaResponseTest methodsFor: 'running'!tearDown	server stop.! !!TeapotTeaResponseTest methodsFor: 'tests'!testBadRequest	| response |	response := TeaTestClient httpGet: '/badrequest'.	self assert: response code equals: 400.	self assert: response entity string equals: 'Bad Request'! !!TeapotTeaResponseTest methodsFor: 'tests'!testCreated	| response |	response := TeaTestClient httpGet: '/created'.	self assert: response code equals: 201.	self assert: response entity string equals: 'Created'.	self assert: (response headers at: 'Location') equals: '/created'.! !!TeapotTeaResponseTest methodsFor: 'tests'!testMethodNotAllowed	| response |	response := TeaTestClient httpGet: '/notallowed'.	self assert: response code equals: 405.! !!TeapotTeaResponseTest methodsFor: 'tests'!testNotFound	| response |	response := TeaTestClient httpGet: '/notfound'.	self assert: response code equals: 404.! !!TeapotTeaResponseTest methodsFor: 'tests'!testNotModified	| response |	response := TeaTestClient httpGet: '/notmodified'.	self assert: response code equals: 304.! !!TeapotTeaResponseTest methodsFor: 'tests'!testOk	| response |	response := TeaTestClient httpGet: '/ok'.	self assert: response code equals: 200.	self assert: response entity string equals: 'tested ok'.! !!TeapotTeaResponseTest methodsFor: 'tests'!testRedirect	| response |	response := TeaTestClient httpGetNoRedirect: '/redirect'.	self assert: response code equals: 302.	self assert: (response headers at: 'Location') equals: '/target'.! !!TeapotTeaResponseTest methodsFor: 'tests'!testServerError	| response |	response := TeaTestClient httpGet: '/servererror'.	self assert: response code equals: 500.	self assert: response entity string equals: 'tested server error'! !!TeapotTeaResponseTest methodsFor: 'tests'!testUnauthorized	| response |	response := TeaTestClient httpGet: '/unauthorized'.	self assert: response code equals: 401.	self assert: response entity string equals: 'Unauthorized'.	self assert: (response headers at: 'WWW-Authenticate') equals: 'tested unauthorized'.! !!TeapotWhenClauseTest methodsFor: 'running'!setUp	server := Teapot on		any: '/when' -> 'get'; when: [:req | req method = 'GET'];		any: '/when' -> 'post'; when: [:req | req method = 'POST'];		any: '/when/<p>' -> 'param-dispatch'; when: [:req | (req at: #p) = 'pval'];		any: '/when' -> 'unfiltered';		any: '/never' -> 'never match'; when: [ false ];		before: '/*' -> [:req | 			req abort: (TeaResponse ok body: 'before') ]; 			when: [:req | req relativeUrl path = 'beforeurl' ];		after: '/*' -> [:req :resp | 			resp statusLine: ZnStatusLine ok. 			resp entity: (ZnStringEntity text: 'after') ]; 			when: [:req | req relativeUrl path = 'afterurl' ];		start! !!TeapotWhenClauseTest methodsFor: 'running'!tearDown	server stop! !!TeapotWhenClauseTest methodsFor: 'tests'!testDispatchesOnMethodInWhenFilter	self 		assert: (TeaTestClient httpGetString: '/when') 		equals: 'get'.		self 		assert: (TeaTestClient httpPutString: '/when/pval') 		equals: 'param-dispatch'.	self 		assert: (TeaTestClient httpPostString: '/when') 		equals: 'post'.	self 		assert: (TeaTestClient httpDeleteString: '/when') 		equals: 'unfiltered'.			self assert: (TeaTestClient httpGet: '/never') isNotFound.! !!TeapotWhenClauseTest methodsFor: 'tests'!testWhenClauseWithBeforeAfterFilter	self 		assert: (TeaTestClient httpGetString: '/beforeurl') 		equals: 'before'.	self 		assert: (TeaTestClient httpGetString: '/afterurl') 		equals: 'after'.! !!TeapotWithTypeConstraintTest methodsFor: 'running'!setUp	server := Teapot on		GET: '/u/<identifier:IsUUID>/more' -> [ :req | (req at: #identifier) asString ];		GET: '/u' -> 'no uuid';		GET: '/u/<identifier:IsUUID>' -> [ :req | (req at: #identifier) asString36  ];				start! !!TeapotWithTypeConstraintTest methodsFor: 'running'!tearDown	server stop! !!TeapotWithTypeConstraintTest methodsFor: 'tests'!testNoParams	self 		assert: (TeaTestClient httpGetString: '/u') 		equals: 'no uuid'.	! !!TeapotWithTypeConstraintTest methodsFor: 'tests'!testParseTypeConstraint	self 		assert: (TeaTestClient httpGetString: '/u/964d5d07-1834-0d00-a106-47ae08909eb2') 		equals: (UUID fromString: '964d5d07-1834-0d00-a106-47ae08909eb2') asString36.	! !!TeapotWithTypeConstraintTest methodsFor: 'tests'!testParseTypeConstraint2	self 		assert: (TeaTestClient httpGetString: '/u/964d5d07-1834-0d00-a106-47ae08909eb2/more') 		equals: '964d5d07-1834-0d00-a106-47ae08909eb2'.	! !!TeaTestClient class methodsFor: 'private'!httpDelete: aString	^ ZnEasy delete: 'http://localhost:1701', aString	! !!TeaTestClient class methodsFor: 'private'!httpDeleteString: aString	^ ZnClient new		url: 'http://localhost:1701', aString;		delete	! !!TeaTestClient class methodsFor: 'private'!httpGet: aString	^ ZnEasy get: 'http://localhost:1701', aString	! !!TeaTestClient class methodsFor: 'private'!httpGetNoRedirect: aString	^ ZnClient new		followRedirects: false;		get: 'http://localhost:1701', aString;				response	! !!TeaTestClient class methodsFor: 'private'!httpGetString: aString	^ (self httpGet: aString) entity string	! !!TeaTestClient class methodsFor: 'private'!httpPost: aString	^ ZnEasy post: 'http://localhost:1701', aString data: (ZnEntity text: 'any')	! !!TeaTestClient class methodsFor: 'private'!httpPostString: aString	^ (self httpPost: aString) entity string	! !!TeaTestClient class methodsFor: 'private'!httpPut: aString	^ ZnEasy put: 'http://localhost:1701', aString data: (ZnEntity text: 'any')	! !!TeaTestClient class methodsFor: 'private'!httpPutString: aString	^ (self httpPut: aString) entity string	! !"Teapot-Tests"!!BaselineOfTealight commentStamp: '' prior: 0!A baseline for Tealight project!!BaselineOfTealight methodsFor: 'baseline'!baseline: spec	<baseline>	spec for: #common do: [ 		spec			baseline: 'Teapot' with: [ 				spec					repository: 'github://zeroflag/Teapot:master/source';					loads: #( 'Development' ) ];			import: 'Teapot'.		spec			package: 'Tealight-Web-Tools'			with: [ spec requires: #( 'Teapot' ) ].		spec			package: 'Tealight-Web-Tools-Tests'			with: [ spec requires: #( 'Tealight-Web-Tools' ) ].		spec			group: 'Tools' with: #( 'Tealight-Web-Tools' );			group: 'Tests' with: #( 'Tealight-Web-Tools-Tests' );			group: 'all' with: #( 'Tests' );			group: 'default' with: #( 'all' ) ]! !"BaselineOfTealight"!!TLDesktopMenu commentStamp: '' prior: 0!Desktop menu!!TLIconCache commentStamp: '' prior: 0!Utility class for caching icons (preventing unnnecessary instances of Forms). !!TLRESTAPIBuilder commentStamp: '' prior: 0!A simple utility class to build a REST API from methods!!TLVersionedRESTAPIBuilder commentStamp: '' prior: 0!An API builder for a versioned REST API!!TLRESTApiURLPathBuilder commentStamp: '' prior: 0!Utility class to build the REST API URL pathThe path is built from   - an optional API prefix  - an optional version  - the actual path  !!TLWebserver commentStamp: '' prior: 0!The Tealight server!!TLDesktopMenu class methodsFor: 'private - accessing'!mainMenuSymbol	^ #Tealight! !!TLDesktopMenu class methodsFor: 'world menu'!menuCommandOn: aBuilder 	<worldMenu>		| parent |	parent := self mainMenuSymbol.	(aBuilder item: parent)		order: 3.0; 	 		icon: (TLIconCache appIcon).	aBuilder withSeparatorAfter				 ! !!TLDesktopMenu class methodsFor: 'world menu'!serverMenuCommandOn: aBuilder	<worldMenu>	| parent |	parent := self mainMenuSymbol.	(aBuilder item: #Webserver)		parent: parent;		order: 2;		icon: TLIconCache serverIcon.	(aBuilder item: #'Start webserver')		parent: #Webserver;		icon: TLIconCache serverStartIcon;		action: [ TLWebserver start ].	(aBuilder item: #'Stop webserver')		parent: #Webserver;		icon: TLIconCache serverStopIcon;		action: [ TLWebserver stop ].	aBuilder withSeparatorAfter.	(aBuilder item: #'Browse webserver')		parent: #Webserver;		icon: TLIconCache serverIcon;		action: [ TLWebserver openWebbrowser ]! !!TLIconCache class methodsFor: 'icons'!appIcon	<script: 'self appIcon inspect'>	^ self iconNamed: #appIcon! !!TLIconCache class methodsFor: 'private - icons'!appIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABs0lEQVR42mNkIAJ0rzj4/+GjKwx8AtIMbWkBjMhyjMQYsGTWrP/RzhwMt84/Z3ipHMZgZ6jISLQBR87d+/9o6UwG7V8PGF7/ZGV47JzMkBjuSLwBq3ec+f+2MpaBi/EfA8P/fwxfsvsYslJ8iTPg0Nk7//dt2cPAsWk6g8C/HwxvP3xi+B9awGDq68XgbqvLSNCAHUeu/t9QU8Eg+eIqwz82DobvLx4z/FY1Y3Brn8DgaUeEASCwds/F/7sbShn+P7vD8FPLlsEzO5ch3NOE+DBonbrh/4VNqxl0PP0ZvFwsGEx15EiLxsbZu/4bqUkx6KtKMRy5cJfh4r2XDJ05PsS7ABwWx278X739JMPFI4cZFLR1GNZMKSDegP7lR/7PX3+U4d+PrwwGusoMmSG2DNaGSsQboJO98r+aEDNDpIMaQ6izHoZ6vAbsP3vv/7l7bxiKQ83g6rKmHfrvZyzJ4GGuSlw0wkDXmtP/1z/8y/DoHw9DhyEDQ6yLDnEG9G268H/5K1aGRxxCDAx//jLofX/JsDvTmLgwqFt74f9MBlkGxh8/GHR/vGbwFvnHUOBvhKIHACf7oBFVIpg+AAAAAElFTkSuQmCC'! !!TLIconCache class methodsFor: 'generate'!generateIcon	<script>		| base64Contents fileName contentsMethod iconMethod iconName |  	fileName := UIManager default chooseFullFileNameMatching: #('png') label: 'Icon file'.	fileName ifNil: [ ^ self ].	iconName := UIManager default request: 'Icon name' initialAnswer: 'blank'.	iconName ifNil: [ ^ self ].	base64Contents := (Base64MimeConverter mimeEncode: fileName binary) contents.	fileName close.	contentsMethod := String		streamContents: [ :s | 			s				nextPutAll: iconName;				nextPutAll: 'IconContents';				cr;				cr;				tab;				nextPut: $^;				nextPut: $';				nextPutAll: base64Contents;				nextPut: $' ].	iconMethod := String		streamContents: [ :s | 			s				nextPutAll: iconName;				nextPutAll: 'Icon';				cr;				tab;				nextPutAll: '<script: ''self ';				nextPutAll: iconName;				nextPutAll: 'Icon';				nextPutAll: ' inspect''>';				cr;				cr;				tab;				nextPutAll: '^ self iconNamed: #';				nextPutAll: iconName;				nextPutAll: 'Icon' ].	self class compile: contentsMethod classified: #'private - icons'.	self class compile: iconMethod classified: #icons! !!TLIconCache class methodsFor: 'private - accessing'!iconCache	^ IconCache ifNil: [ IconCache := Dictionary new ]! !!TLIconCache class methodsFor: 'accessing'!iconNamed: aSymbol	"Returns the icon with the given name"	(self class canUnderstand: aSymbol) ifFalse: [ ^super iconNamed: aSymbol ].	^ self iconCache		at: aSymbol		ifAbsentPut: [ 			Form				fromBinaryStream: (self perform: (aSymbol , 'Contents') asSymbol) base64Decoded readStream ]! !!TLIconCache class methodsFor: 'initialization-release'!reset	"Reset the icon cache"		<script>		IconCache := nil! !!TLIconCache class methodsFor: 'icons'!serverIcon	<script: 'self serverIcon inspect'>	^ self iconNamed: #serverIcon! !!TLIconCache class methodsFor: 'private - icons'!serverIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC0UlEQVR4Xo2SbU+SURzG+RS2hDdufQBtM0e58GHa8o2W3mbWkjbLhzURTTNEHnwowNKG2oM6JUWF2+fHTJ2aJaFCPlAzJygGOMPM8qF8wqtbXli2rK7t2v7n7Fy/c8520fbk4nKEkZkpIUViKckXSEj9qBEjehNG3kxDILxLenoyCVdXVwbtMHl7s4hJ4ypsi1uUHbDad2Fz2kGtd2G2bWBIZ0Jz6wvLHtDL69RBIIvlS2hGFqEbW4FhcgWmuU0YzduYNu9QswOmDw7MWhwUaAe2Tw7M29dxIyGV3Af4+voR3X1mDAwuoLd/Hl09c9Q8D/34MgVcxYz1O+yft2Ff3sTYWxvKK/oRxU44CGhpe4/Orlm0tk+joWkS6toJ1KhHoax5jdLyPsgLn0GUrUZMnBTnw64jPj7lIEBNjqK+8R1U5DiU1XqUP9WitGwQfEEJMgRS5D8ohrJKjampKQhF9+HjG8j9BeBPlCk0qFDqUKbQ4knJSzwsom6Vd1N/lcJgMGBraxvf1jfw5es64mJvwfMEk9gHBAaeIeQFXXhcPIDCwl7k5z9HrqwDUkkL2Ox0aLXDWFvbwsLCMmZm7QgJYeNsUNBPgLu7B1MirUdeXidk0nbkZDdBLKqjXIuIiBS0tXXBal2C0bSEVxoTgoOjQGfQD/YiLU1MioQqZ1AoUEOQoYZISCI8PBnVNc2YMFiocpnR1jEM9lUO/lioa9FJZDqvygnYsxNwIQmKikYqbMGAZgbquh4kcsU4tJUyWYklg6/aBxDhXBQ9UkE3/hGDQzNIThUg5BxbcyjgKFVRHk9uEWSonIAwgoukm3eo0CW4uR1DQEAktRdN0v4md4/jTA4n17L3ipjYe2D5ROK0z0VcTuSBL6zElajYPNq/5OcfQGRlKZHAKaLal4/bPAXkBa3IypZr6HQ6g/Y/8vI6SVRW9qChUYPsnCJNaGgE9/czPwCyhvLlWzqQAwAAAABJRU5ErkJggg=='! !!TLIconCache class methodsFor: 'icons'!serverStartIcon	<script: 'self serverStartIcon inspect'>		^ self iconNamed: #serverStartIcon! !!TLIconCache class methodsFor: 'private - icons'!serverStartIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADR0lEQVR4Xn2T71fTZRyG+S804RV56k3Hc6jciTpHICnNOnVYfCWhCZiiCAxGlEbbhCg2TjQdIYlCwWIIU0crDhAiiOA8xL6B4kFqG7+22QYRHCL5Nbia7ByOnNPpc859zvPmup7nOef+hDw5JzOydQWfaU0qtdYkDjro/9VJv2in8lKdVaMtNUkkksiQ/xtr3ygu3yqe6TU8U4+zHjgHM/FwmT5xFMtP3S71GY1JocjT7dgRGrZF0NH1O+LdBe7en8c+tohzfBXHmB/HhB/n5BpjrkA8fh4GLnB7/0aRm2/aImhpG6LH6qOz20N7xwQ3ezzYBv/i3vBCAF7CN7PK1NwyA0Muqr69wcmMj7cKmiw22q6P09xip8nyANPVIeobBqhv/IXq7zopK2+l4PNG0k5oiBfSSUxM1W0RNDRaMf8wTOOVe9TVi9QY+rhY1UthkQGlUsPZc5UYjSbsdgenPikmIkIibMK7JS9G5p0vIfF8Dqll+ZRUmKmouIlef52c3HOINhsrKys8+meZ2dkFUlKziY19LSiQ7JUIh5vep2SgmNbJFgy/1XC09SgHNXI0xRbSjmvo6uxiIQB7vbPYHX8glaYSFxcnhGx7altYglmgxl5Ns+tHFlcfMTI3TJ2zluzeLA4pPyLlSCENDddwu2dwOP+kq/tB4P/pbNwe/UGU7thtGbXOSuaX51hfX9+IdfoW+pESdpdHkpx6hksXjQzdn6TfNo7Z0kumXBUUPK/YZZKLR5ha9G7Cj+Nf82NxX+E5YziyFCXlFbXYRDc9t0epu9yCUlUaFLycJzEliq9TMfkF7TPmALyGb9nDhUkN6hE5uy4/TVLyp3xZWoU46KM30FZ5zile3SsNdkCaJdW9eecF0u1vUT+t3xC4lhx86BQ4OPgKMd/EIktWkZmlJu5dGeHhO9m3T4bscEZQEBoWGpbbeZwi1zF+nq8LvmBlgq+8uSTciiFNpSUzs4zomCT2RL9HUk4+6oLv2f/GO4rNDhx4+4CQcTXFVTRygralKmqnNMithyisLrBqtUYUiguB9p3ldH4N+q+bAxU+bfrPbYzaHyVsj9guPBv5jCB5Kbi6UXtiBIOhnWvmO3TcsBEfn6B4kvkXxV9YN+ClYBQAAAAASUVORK5CYII='! !!TLIconCache class methodsFor: 'icons'!serverStopIcon	<script: 'self serverStopIcon inspect'>	^ self iconNamed: #serverStopIcon! !!TLIconCache class methodsFor: 'private - icons'!serverStopIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADQ0lEQVR4Xn2Ta0zTVxiHG+GDprilxuhGCH5RYrJsxokGvI24DBJmYLBWQDrYZthGwka5VNFkCIFMN7WbFVfhr4ZIVWyV1V28Z8oGlbXjzrLBWumFiy24xa4rkVKe/R3T2SzZmzx5v5z3OTnn/I7kydq4cbNm2zalQS7PNXT22LF22bF02dhVUWVev36TJjo6WiH5v2rrsOP2BBmbmGHUM8uo9xEhRjwz/NjjxNpp43X5dsPDzaKiohLDBNe/HaSrz0/PwH2GhgPYHTPYhkPYnSKuWe64QgyPzIiyEJ7fHnDlWjthgm8u9/O92cvN1jGu3XBx8zu3eIx79A78gc05xfhEkMn7QQbtE1wwWdDVm8IFLSYrV687+fqSjS8u/oLhfD9nmrtpNloRGm9Rd+wqtfuNFKuOkJVTREqK3BwmONPcTovpZ84Z+zh9tovGUxaEE+0crrvE+x/s4ZDmGCdPNmGxWNHrz7JuXZLh8XBkZGSM8Nk56qsbaThkouF4G5/rbnFYe4Oaj5ppatIzPR1kauoBPl+AAweOsGVL6pzgueXLS7Ryhft2TQ0/NdTTUVuLPr+Q/bsE9u37kordJ6g7qiMQmMbr9eFyTaIqqSQtLdMgeXbJEsXl3FzsgvCYO//0lswsKlU6du4U2Lu3hpHRSRyu3+nqvUuusgiZbJFCok1Lc/eVlTNUVcWvTzAoMlBRwSdrUygvb0Ct/pD+ATed3Q7xZUZ5dauSpUufUUhMLzyP3+kg6PeL/BnWp/0+Tq/dQJkoKFbtobt3jNY2O+237aSmbiciMiJG8lVcHIGxMUKzof8SCnF+TQKlZTreK1TTYXWLIbvHxwfrycsvmstAa04OQ0lJuNPTuKtU4s3PY1z5Bo701xhMTkZYvZmSUh1Z2e/w1o5i4lasJCExmepqYU6weOFCxQ+yRbhiY/GIeJctY1zswyLmp56mMr9KvAOBl195k00vZSEvLKG49Chv71D9G6IVMllJb3w8/vR0pvLy8GVk0LMmnt0ZmWat1ki5WqDgXQ1l6uMc/PSiuLvWLZVKwz+SdMGCxOzVLxqyY2MN2atWGaTz5/+9YN68iJhT+isYL7RRUFBqTkjYoHkYukdzfwGRNFI+0JfMpQAAAABJRU5ErkJggg=='! !!TLRESTAPIBuilder class methodsFor: 'accessing'!allPragmas	"Return a collection of all the REST API pragmas"		^ (PragmaCollector selectors: {self pragmaKeyword}) pragmas! !!TLRESTAPIBuilder class methodsFor: 'building'!buildAPI	"Build the API from the receiver and subclasses"	<script>		self buildAPIFor: self teapotRefreshed! !!TLRESTAPIBuilder class methodsFor: 'building'!buildAPIFor: aTeapot	"Build the API from the receiver and subclasses"	<script>	self withAllSubclassesDo: [ :each | (each on: aTeapot) build ]! !!TLRESTAPIBuilder class methodsFor: 'instance creation'!on: aTeapot	^ self new teapot: aTeapot; yourself! !!TLRESTAPIBuilder class methodsFor: 'accessing'!pragmaKeyword	"Return the Pragma keyword that is used to define a REST API"		^#REST_API:pattern:! !!TLRESTAPIBuilder class methodsFor: 'accessing'!teapot	^TLWebserver teapot! !!TLRESTAPIBuilder class methodsFor: 'accessing'!teapotRefreshed	^TLWebserver teapotRefreshed ! !!TLRESTAPIBuilder methodsFor: 'accessing'!allPragmas		^ self class allPragmas! !!TLRESTAPIBuilder methodsFor: 'building'!build	"Build a regular API (unversioned) by installing a teapot route for each pragma definition"	self allPragmas do: [ :each | 		self			installHook: each arguments first			path: (self pathFromPragma: each)			pragma: each ]! !!TLRESTAPIBuilder methodsFor: 'installing'!installHook: httpMethod path: aPath pragma: aPragma	"Install a dynamic route as a hook in the current teapot"	| action route |	action := Send		          message: aPragma methodSelector		          to: aPragma method methodClass instanceSide.	route := aPath -> action.	self teapot perform: (httpMethod , ':') asSymbol with: route! !!TLRESTAPIBuilder methodsFor: 'private - factory'!newPathBuilder	^ TLRESTApiURLPathBuilder new! !!TLRESTAPIBuilder methodsFor: 'private - utilities'!pathFromPragma: aPragma	^(self newPathBuilder)						function: aPragma arguments second;			path! !!TLRESTAPIBuilder methodsFor: 'accessing'!pragmaKeyword	^ self class pragmaKeyword! !!TLRESTAPIBuilder methodsFor: 'accessing'!teapot	^ teapot! !!TLRESTAPIBuilder methodsFor: 'accessing'!teapot: anObject	teapot := anObject! !!TLVersionedRESTAPIBuilder class methodsFor: 'accessing'!pragmaKeyword	"Return the Pragma keyword that is used to define a versioned REST API"		^#REST_API:versions:pattern:! !!TLVersionedRESTAPIBuilder methodsFor: 'building'!build	"Build a regular API (unversioned) by installing a teapot route for each pragma definition"	self allPragmas do: [ :each | 			each arguments second do: [:version |				self installHook: each arguments first path: (self pathFromPragma: each version: version) pragma: each ] ]! !!TLVersionedRESTAPIBuilder methodsFor: 'private - utilities'!pathFromPragma: aPragma	^(self newPathBuilder)						version: aPragma arguments second;			function: aPragma arguments third;			path! !!TLVersionedRESTAPIBuilder methodsFor: 'private - utilities'!pathFromPragma: aPragma version: aVersion	^(self newPathBuilder)						version: aVersion;			function: aPragma arguments third;			path! !!TLRESTApiURLPathBuilder class methodsFor: 'accessing'!apiPrefix	"Return the API prefix"		^APIPrefix ! !!TLRESTApiURLPathBuilder class methodsFor: 'class initialization'!initialize	"initializes the receiver"		self useStandardPrefix! !!TLRESTApiURLPathBuilder class methodsFor: 'actions'!useAPIPrefix: aString	"Use the given string as API prefix"		APIPrefix := aString! !!TLRESTApiURLPathBuilder class methodsFor: 'actions'!useStandardPrefix	"Use the standard API prefix"		APIPrefix := 'api'! !!TLRESTApiURLPathBuilder class methodsFor: 'actions'!withoutPrefix	"Do not use any prefix"			APIPrefix := ''! !!TLRESTApiURLPathBuilder methodsFor: 'accessing'!apiPrefix	^ apiPrefix! !!TLRESTApiURLPathBuilder methodsFor: 'accessing'!apiPrefix: anObject	apiPrefix := anObject! !!TLRESTApiURLPathBuilder methodsFor: 'accessing'!function	^ function! !!TLRESTApiURLPathBuilder methodsFor: 'accessing'!function: anObject	function := anObject! !!TLRESTApiURLPathBuilder methodsFor: 'initialization'!initialize	"Initializes the receiver"	super initialize.	apiPrefix := self class apiPrefix.	version := String empty.	function := String empty.! !!TLRESTApiURLPathBuilder methodsFor: 'accessing'!path	^String streamContents: [:s | 		self 			write: self apiPrefix on: s;			write: self version on: s;			write: self function on: s	 ].! !!TLRESTApiURLPathBuilder methodsFor: 'accessing'!version	^ version! !!TLRESTApiURLPathBuilder methodsFor: 'accessing'!version: anObject	version := anObject! !!TLRESTApiURLPathBuilder methodsFor: 'private  - writing'!write: part on: aStream	part isEmpty ifTrue: [ ^self ].	(part beginsWith: '/')		ifFalse: [ aStream nextPut: $/ ].	aStream nextPutAll: part	! !!TLWebserver class methodsFor: 'defaults'!defaultConfiguration	"Override to set more default values"	^ {		#port -> self defaultPort 	}! !!TLWebserver class methodsFor: 'defaults'!defaultPort	"Return the default server port"		^DefaultPort ifNil: [ DefaultPort := 8080 ]! !!TLWebserver class methodsFor: 'defaults'!defaultPort: anInteger	"Sets the default server port"		DefaultPort := anInteger ! !!TLWebserver class methodsFor: 'defaults'!defaultServer	"Return the default server"		DefaultServer ifNil: [ self installAsDefaultServer ].	^DefaultServer ! !!TLWebserver class methodsFor: 'defaults'!defaultServer: aTLWebServer		DefaultServer := aTLWebServer! !!TLWebserver class methodsFor: 'class initialization'!initialize	DefaultPort := nil.	DefaultServer := nil! !!TLWebserver class methodsFor: 'private'!installAsDefaultServer	self defaultServer: self new! !!TLWebserver class methodsFor: 'operating'!openWebbrowser	<script>		| baseURL |	baseURL := 'http://localhost'.	self defaultPort = 80 ifFalse: [ 		baseURL := baseURL , ':' , self defaultPort asString ].	WebBrowser openOn: baseURL! !!TLWebserver class methodsFor: 'running'!start	"Start the server"	<script>		^self defaultServer start! !!TLWebserver class methodsFor: 'running'!startOn: aPort	"start on the given port"		self 		defaultPort: aPort;		start! !!TLWebserver class methodsFor: 'running'!stop	"Stop the server"	<script>		^ self defaultServer stop! !!TLWebserver class methodsFor: 'accessing'!teapot	^ self defaultServer teapot! !!TLWebserver class methodsFor: 'accessing'!teapotRefreshed	^ self defaultServer refreshTeapot! !!TLWebserver methodsFor: 'accessing'!configuration	^ configuration ifNil: [ configuration := self class defaultConfiguration ]! !!TLWebserver methodsFor: 'accessing'!configuration: anObject	configuration := anObject! !!TLWebserver methodsFor: 'private - initialization'!initTeapot	teapot := Teapot configure: self configuration! !!TLWebserver methodsFor: 'initialization'!initialize	super initialize.	self initTeapot! !!TLWebserver methodsFor: 'testing'!isRunning	^ self teapot server isRunning! !!TLWebserver methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: 'a '.	aStream nextPutAll: self className.	aStream nextPut: $(.	aStream nextPutAll: (self isRunning ifTrue: [ 'running' ] ifFalse: [ 'stopped' ]).	aStream nextPut: $).	self configuration printOn: aStream.! !!TLWebserver methodsFor: 'initialization'!refreshTeapot	self teapot server isRunning ifTrue: [ self stop ].	self initTeapot.	^ self teapot! !!TLWebserver methodsFor: 'running'!start	self teapot start! !!TLWebserver methodsFor: 'running'!stop	self teapot stop! !!TLWebserver methodsFor: 'accessing'!teapot	^teapot! !"Tealight-Web-Tools"!!TLRESTApiURLPathBuilderTest commentStamp: '' prior: 0!A test class for TLRESTApiURLPathBuilder!!TLRESTApiURLPathBuilderTest methodsFor: 'utilities'!buildWith: aBlock returnsPath: expectedPath	| builder |	builder := self defaultTestClass new.	aBlock value: builder.	self assert: builder path equals: expectedPath! !!TLRESTApiURLPathBuilderTest methodsFor: 'private - accessing'!defaultTestClass	^TLRESTApiURLPathBuilder! !!TLRESTApiURLPathBuilderTest methodsFor: 'running'!setUp	"Setup the test"	super setUp.	backupAPIPrefix := self defaultTestClass apiPrefix.	self defaultTestClass useStandardPrefix! !!TLRESTApiURLPathBuilderTest methodsFor: 'running'!tearDown	self defaultTestClass useAPIPrefix: backupAPIPrefix.	super tearDown! !!TLRESTApiURLPathBuilderTest methodsFor: 'tests'!testCustomPrefix	| cls |	cls := self defaultTestClass.	cls useAPIPrefix: '/myapp/api'.	self assert: cls apiPrefix equals: '/myapp/api'! !!TLRESTApiURLPathBuilderTest methodsFor: 'tests'!testEmptyPathBuilding	self buildWith: [ :builder |  ] returnsPath: '/api'! !!TLRESTApiURLPathBuilderTest methodsFor: 'tests'!testFullPathBuilding	self		buildWith: [ :builder | 			builder				apiPrefix: 'myapi';				version: 'v1';				function: 'foo' ]		returnsPath: '/myapi/v1/foo'! !!TLRESTApiURLPathBuilderTest methodsFor: 'tests'!testPrefixedPathBuilding	self		buildWith: [ :builder | 			builder				apiPrefix: 'myPrefix';				version: 'v1' ]		returnsPath: '/myPrefix/v1'! !!TLRESTApiURLPathBuilderTest methodsFor: 'tests'!testSimplePathBuilding	self buildWith: [ :builder |  ] returnsPath: '/api'! !!TLRESTApiURLPathBuilderTest methodsFor: 'tests'!testStandardPrefix	| cls |	cls := self defaultTestClass.	self assert: cls apiPrefix equals: 'api'! !!TLRESTApiURLPathBuilderTest methodsFor: 'tests'!testVersionedPathBuilding	self		buildWith: [ :builder | builder version: 'v1' ]		returnsPath: '/api/v1'! !"Tealight-Web-Tools-Tests"!----SNAPSHOT----2025-03-02T00:45:04.356638-05:00 SmallTalk.image priorSource: 308!----SNAPSHOT----2025-03-02T00:45:04.358094-05:00 SmallTalk.image priorSource: 544329!Object subclass: #DBs	instanceVariableNames: '' 	classVariableNames: ''	package: 'Guild'!
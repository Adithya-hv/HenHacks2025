----QUIT----2025-02-27T16:43:44.405418+01:00 Pharo12.0-SNAPSHOT-64bit-d516e0197e.image priorSource: 0!----QUIT----2025-02-27T16:43:44.40607+01:00 Pharo12.0-SNAPSHOT-64bit-d516e0197e.image priorSource: 0!----QUIT----2025-02-27T16:44:04.726011+01:00 Pharo12.0-SNAPSHOT-64bit-d516e0197e.image priorSource: 104!----QUIT----2025-02-27T16:44:04.726905+01:00 Pharo12.0-SNAPSHOT-64bit-d516e0197e.image priorSource: 207!!BaselineOfSQLite3 commentStamp: '' prior: 0!A baseline for SQlite3 support in Pharo!!BaselineOfSQLite3 methodsFor: 'baselines' stamp: '3/1/2025 19:01'!baseline: spec	<baseline>	spec		for: #pharo		do: [ 			self setUpDependencies: spec.			spec				package: 'SQLite3-Core';				group: 'Core' with: 'SQLite3-Core';				package: 'SQLite3-Core-Benchmarks' with: [ spec requires: 'SQLite3-Core' ];				group: 'Benchmarks' with: 'SQLite3-Core-Benchmarks';								package: 'SQLite3-Core-Tests' with: [ spec requires: 'Core' ];				group: 'Tests' with: 'SQLite3-Core-Tests';								package: 'SQLite3-Glorp' with: [ spec requires: #('Core' 'Glorp-Core') ];				group: 'glorp' with: 'SQLite3-Glorp';								package: 'SQLite3-Glorp-Tests' with: [ spec requires: #('SQLite3-Glorp' 'Glorp-Tests')  ];				group: 'Tools' with: #().			spec				group: 'CI' with: #('SQLite3-Glorp-Tests' 'Tests');				group: 'all' with: #('Core' 'Tests' 'Benchmarks' 'Tools');				group: 'default' with: #('all')			].	self versionSpecificBaseline: spec.! !!BaselineOfSQLite3 methodsFor: 'baselines' stamp: '3/1/2025 19:01'!projectClass	^ MetacelloCypressBaselineProject! !!BaselineOfSQLite3 methodsFor: 'baselines' stamp: '3/1/2025 19:01'!setUpDependencies: spec	spec		baseline: 'Glorp' with: [ spec repository: 'github://pharo-rdbms/glorp/' ];		project: 'Glorp-Core' copyFrom: 'Glorp' with: [ spec loads: 'Core' ];		project: 'Glorp-Tests' copyFrom: 'Glorp' with: [ spec loads: 'Glorp-Integration-Tests' ]! !!BaselineOfSQLite3 methodsFor: 'baselines' stamp: '3/1/2025 19:01'!versionSpecificBaseline: spec	"Add version specific packages to the spec"	spec for: #( #'pharo7.x' #'pharo8.x' ) do: [ 		spec			package: 'SQLite3-Pharo8';			group: 'Core' with: 'SQLite3-Pharo8'		].	spec for: #( #'pharo9.x' #'pharo10.x' #'pharo11.x' #'pharo12.x' ) do: [ 		spec			package: 'SQLite3-Pharo9';			group: 'Core' with: 'SQLite3-Pharo9'		].	spec for: #( #'pharo10.x' #'pharo11.x' #'pharo12.x' ) do: [ 		spec			package: 'SQLite3-Pharo10';			group: 'Core' with: 'SQLite3-Pharo10'.		spec			package: 'SQLite3-Inspector-Extensions' with: [ spec requires: #( 'Core' ) ];			group: 'Tools' with: 'SQLite3-Inspector-Extensions'		]! !"BaselineOfSQLite3"!!SQLite3BackupExternalReference commentStamp: '' prior: 0!I represent the SQLite API 'sqlite3_backup' C-level type.!!SQLite3DatabaseExternalObject commentStamp: '' prior: 0!I represent the SQLite API 'sqlite3' C-level type.!!SQLite3StatementExternalObject commentStamp: '' prior: 0!I represent the SQLite API 'sqlite3_stmt' C-level type.!!SQLite3AbstractError commentStamp: '' prior: 0!I represent an SQLite non-ok condition.!!SQLite3NotOpen commentStamp: '' prior: 0!I am signalled when operations are invoked on a database that is not open.!!SQLite3Backup commentStamp: '' prior: 0!I represent a SQLite backup operation.This is detailed at https://sqlite.org/c3ref/backup_finish.html#sqlite3backupinit!!SQLite3BaseConnection commentStamp: '' prior: 0!I represent a connection to an SQLite database. I provide a thin wrapper over the SQLite C API.Do not use this class directly, please check and use my subclass SQLite3Connection!!SQLite3Connection commentStamp: '' prior: 0!I represent a connection to an SQLite database.!!SQLite3Column commentStamp: '' prior: 0!I represent a column in a table!!SQLite3Database commentStamp: '' prior: 0!An SQLite3 database!!SQLite3Row commentStamp: '' prior: 0!I represent a row of results returned by the database.!!SQLite3Table commentStamp: '' prior: 0!A table within a SQLite3 database!!SQLite3Constants commentStamp: '' prior: 0!I provide SQLIte's constants.!!SQLite3Cursor commentStamp: '' prior: 0!I represent a set of results returned by the database. I produce UDBCSQLite3Row instances lazily.!!SQLite3Library commentStamp: '' prior: 0!I am the (unified) FFI interface to SQLite.!!SQLite3NativeError commentStamp: '' prior: 0!Common subclass for errors corresponding to a native SQLite3 C library error code.Typically one uses this class to create and access instances of subclasses:  	(SQLite3NativeError forNativeErrorCode: SQLITE_INTERRUPT  messageText: 'Interrupted') signal!!SQLite3Abort commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_ABORT result code indicates that an operation was aborted prior to completion, usually be application request. See also: SQLITE_INTERRUPT.If the callback function to sqlite3_exec() returns non-zero, then sqlite3_exec() will return SQLITE_ABORT.If a ROLLBACK operation occurs on the same database connection as a pending read or write, then the pending read or write may fail with an SQLITE_ABORT or SQLITE_ABORT_ROLLBACK error.In addition to being a result code, the SQLITE_ABORT value is also used as a conflict resolution mode returned from the sqlite3_vtab_on_conflict() interface.!!SQLite3AbortRollback commentStamp: '' prior: 0!The SQLITE_ABORT_ROLLBACK error code is an extended error code for SQLITE_ABORT indicating that an SQL statement aborted because the transaction that was active when the SQL statement first started was rolled back. Pending write operations always fail with this error when a rollback occurs. A ROLLBACK will cause a pending read operation to fail only if the schema was changed within the transaction being rolled back.!!SQLite3AuthorizationDenied commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_AUTH error is returned when the authorizer callback indicates that an SQL statement being prepared is not authorized.!!SQLite3Busy commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_BUSY result code indicates that the database file could not be written (or in some cases read) because of concurrent activity by some other database connection, usually a database connection in a separate process.For example, if process A is in the middle of a large write transaction and at the same time process B attempts to start a new write transaction, process B will get back an SQLITE_BUSY result because SQLite only supports one writer at a time. Process B will need to wait for process A to finish its transaction before starting a new transaction. The sqlite3_busy_timeout() and sqlite3_busy_handler() interfaces and the busy_timeout pragma are available to process B to help it deal with SQLITE_BUSY errors.An SQLITE_BUSY error can occur at any point in a transaction: when the transaction is first started, during any write or update operations, or when the transaction commits. To avoid encountering SQLITE_BUSY errors in the middle of a transaction, the application can use BEGIN IMMEDIATE instead of just BEGIN to start a transaction. The BEGIN IMMEDIATE command might itself return SQLITE_BUSY, but if it succeeds, then SQLite guarantees that no subsequent operations on the same database through the next COMMIT will return SQLITE_BUSY.See also: SQLITE_BUSY_RECOVERY and SQLITE_BUSY_SNAPSHOT.The SQLITE_BUSY result code differs from SQLITE_LOCKED in that SQLITE_BUSY indicates a conflict with a separate database connection, probably in a separate process, whereas SQLITE_LOCKED indicates a conflict within the same database connection (or sometimes a database connection with a shared cache).!!SQLite3BusyRecovery commentStamp: '' prior: 0!The SQLITE_BUSY_RECOVERY error code is an extended error code for SQLITE_BUSY that indicates that an operation could not continue because another process is busy recovering a WAL mode database file following a crash. The SQLITE_BUSY_RECOVERY error code only occurs on WAL mode databases.!!SQLite3BusySnapshot commentStamp: '' prior: 0!The SQLITE_BUSY_SNAPSHOT error code is an extended error code for SQLITE_BUSY that occurs on WAL mode databases when a database connection tries to promote a read transaction into a write transaction but finds that another database connection has already written to the database and thus invalidated prior reads.The following scenario illustrates how an SQLITE_BUSY_SNAPSHOT error might arise:1. Process A starts a read transaction on the database and does one or more SELECT statement. Process A keeps the transaction open.2. Process B updates the database, changing values previous read by process A.3. Process A now tries to write to the database. But process A's view of the database content is now obsolete because process B has modified the database file after process A read from it. Hence process A gets an SQLITE_BUSY_SNAPSHOT error.!!SQLite3CantOpen commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_CANTOPEN result code indicates that SQLite was unable to open a file. The file in question might be a primary database file or one of several temporary disk files.!!SQLite3CantOpenConvertPath commentStamp: '' prior: 0!The SQLITE_CANTOPEN_CONVPATH error code is an extended error code for SQLITE_CANTOPEN used only by Cygwin VFS and indicating that the cygwin_conv_path() system call failed while trying to open a file. See also: SQLITE_IOERR_CONVPATH!!SQLite3CantOpenFullPath commentStamp: '' prior: 0!The SQLITE_CANTOPEN_FULLPATH error code is an extended error code for SQLITE_CANTOPEN indicating that a file open operation failed because the operating system was unable to convert the filename into a full pathname.!!SQLite3CantOpenIsDir commentStamp: '' prior: 0!The SQLITE_CANTOPEN_ISDIR error code is an extended error code for SQLITE_CANTOPEN indicating that a file open operation failed because the file is really a directory.!!SQLite3CantOpenNoTempDir commentStamp: '' prior: 0!The SQLITE_CANTOPEN_NOTEMPDIR error code is no longer used.!!SQLite3ConstraintViolation commentStamp: '' prior: 0!The SQLITE_CONSTRAINT error code means that an SQL constraint violation occurred while trying to process an SQL statement. Additional information about the failed constraint can be found by consulting the accompanying error message (returned via sqlite3_errmsg() or sqlite3_errmsg16()) or by looking at the extended error code.The SQLITE_CONSTRAINT code can also be used as the return value from the xBestIndex() method of a virtual table implementation. When xBestIndex() returns SQLITE_CONSTRAINT, that indicates that the particular combination of inputs submitted to xBestIndex() cannot result in a usable query plan and should not be given further consideration.!!SQLite3ConstraintViolationCheck commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_CHECK error code is an extended error code for SQLITE_CONSTRAINT indicating that a CHECK constraint failed.!!SQLite3ConstraintViolationCommitHook commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_COMMITHOOK error code is an extended error code for SQLITE_CONSTRAINT indicating that a commit hook callback returned non-zero that thus caused the SQL statement to be rolled back.!!SQLite3ConstraintViolationForeignKey commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_FOREIGNKEY error code is an extended error code for SQLITE_CONSTRAINT indicating that a foreign key constraint failed.!!SQLite3ConstraintViolationFunction commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_FUNCTION error code is not currently used by the SQLite core. However, this error code is available for use by extension functions.!!SQLite3ConstraintViolationNotNull commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_NOTNULL error code is an extended error code for SQLITE_CONSTRAINT indicating that a NOT NULL constraint failed.!!SQLite3ConstraintViolationPrimaryKey commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_PRIMARYKEY error code is an extended error code for SQLITE_CONSTRAINT indicating that a PRIMARY KEY constraint failed.!!SQLite3ConstraintViolationRowID commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_ROWID error code is an extended error code for SQLITE_CONSTRAINT indicating that a rowid is not unique.!!SQLite3ConstraintViolationTrigger commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_TRIGGER error code is an extended error code for SQLITE_CONSTRAINT indicating that a RAISE function within a trigger fired, causing the SQL statement to abort.!!SQLite3ConstraintViolationUnique commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_UNIQUE error code is an extended error code for SQLITE_CONSTRAINT indicating that a UNIQUE constraint failed.!!SQLite3ConstraintViolationVirtualTable commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_VTAB error code is not currently used by the SQLite core. However, this error code is available for use by application-defined virtual tables.!!SQLite3Corrupt commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_CORRUPT result code indicates that the database file has been corrupted. See the How To Corrupt Your Database Files for further discussion on how corruption can occur.!!SQLite3CorruptVirtualTable commentStamp: '' prior: 0!The SQLITE_CORRUPT_VTAB error code is an extended error code for SQLITE_CORRUPT used by virtual tables. A virtual table might return SQLITE_CORRUPT_VTAB to indicate that content in the virtual table is corrupt.!!SQLite3Empty commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_EMPTY result code is not currently used.!!SQLite3Error commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_ERROR result code is a generic error code that is used when no other more specific error code is available.!!SQLite3Format commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_FORMAT result code is not currently used.!!SQLite3Full commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_FULL result code indicates that a write could not complete because the disk is full. Note that this error can occur when trying to write information into the main database file, or it can also occur when writing into temporary disk files.Sometimes applications encounter this error even though there is an abundance of primary disk space because the error occurs when writing into temporary disk files on a system where temporary files are stored on a separate partition with much less space that the primary disk.!!SQLite3IOError commentStamp: '' prior: 0!The SQLITE_IOERR result code says that the operation could not finish because the operating system reported an I/O error.A full disk drive will normally give an SQLITE_FULL error rather than an SQLITE_IOERR error.There are many different extended result codes for I/O errors that identify the specific I/O operation that failed.!!SQLite3IOErrorAccess commentStamp: '' prior: 0!The SQLITE_IOERR_ACCESS error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xAccess method on the sqlite3_vfs object.!!SQLite3IOErrorBlocked commentStamp: '' prior: 0!The SQLITE_IOERR_BLOCKED error code is no longer used.!!SQLite3IOErrorCheckReservedLock commentStamp: '' prior: 0!The SQLITE_IOERR_CHECKRESERVEDLOCK error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xCheckReservedLock method on the sqlite3_io_methods object.!!SQLite3IOErrorClose commentStamp: '' prior: 0!The SQLITE_IOERR_CLOSE error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xClose method on the sqlite3_io_methods object.!!SQLite3IOErrorConvertPath commentStamp: '' prior: 0!The SQLITE_IOERR_CONVPATH error code is an extended error code for SQLITE_IOERR used only by Cygwin VFS and indicating that the cygwin_conv_path() system call failed. See also: SQLITE_CANTOPEN_CONVPATH!!SQLite3IOErrorDelete commentStamp: '' prior: 0!The SQLITE_IOERR_DELETE error code is an extended error code for SQLITE_IOERR indicating an I/O error within xDelete method on the sqlite3_vfs object.!!SQLite3IOErrorDeleteNoEntry commentStamp: '' prior: 0!The SQLITE_IOERR_DELETE_NOENT error code is an extended error code for SQLITE_IOERR indicating that the xDelete method on the sqlite3_vfs object failed because the file being deleted does not exist.!!SQLite3IOErrorDirClose commentStamp: '' prior: 0!The SQLITE_IOERR_DIR_CLOSE error code is no longer used.!!SQLite3IOErrorDirFSync commentStamp: '' prior: 0!The SQLITE_IOERR_DIR_FSYNC error code is an extended error code for SQLITE_IOERR indicating an I/O error in the VFS layer while trying to invoke fsync() on a directory. The unix VFS attempts to fsync() directories after creating or deleting certain files to ensure that those files will still appear in the filesystem following a power loss or system crash. This error code indicates a problem attempting to perform that fsync().!!SQLite3IOErrorFStat commentStamp: '' prior: 0!The SQLITE_IOERR_FSTAT error code is an extended error code for SQLITE_IOERR indicating an I/O error in the VFS layer while trying to invoke fstat() (or the equivalent) on a file in order to determine information such as the file size or access permissions.!!SQLite3IOErrorFSync commentStamp: '' prior: 0!The SQLITE_IOERR_FSYNC error code is an extended error code for SQLITE_IOERR indicating an I/O error in the VFS layer while trying to flush previously written content out of OS and/or disk-control buffers and into persistent storage. In other words, this code indicates a problem with the fsync() system call in unix or the FlushFileBuffers() system call in windows.!!SQLite3IOErrorGetTempPath commentStamp: '' prior: 0!The SQLITE_IOERR_GETTEMPPATH error code is an extended error code for SQLITE_IOERR indicating that the VFS is unable to determine a suitable directory in which to place temporary files.!!SQLite3IOErrorLock commentStamp: '' prior: 0!The SQLITE_IOERR_LOCK error code is an extended error code for SQLITE_IOERR indicating an I/O error in the advisory file locking logic. Usually an SQLITE_IOERR_LOCK error indicates a problem obtaining a PENDING lock. However it can also indicate miscellaneous locking errors on some of the specialized VFSes used on Macs.!!SQLite3IOErrorMemoryMap commentStamp: '' prior: 0!The SQLITE_IOERR_MMAP error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xFetch or xUnfetch methods on the sqlite3_io_methods object while trying to map or unmap part of the database file into the process address space.!!SQLite3IOErrorNoMemory commentStamp: '' prior: 0!The SQLITE_IOERR_NOMEM error code is sometimes returned by the VFS layer to indicate that an operation could not be completed due to the inability to allocate sufficient memory. This error code is normally converted into SQLITE_NOMEM by the higher layers of SQLite before being returned to the application.!!SQLite3IOErrorRead commentStamp: '' prior: 0!The SQLITE_IOERR_READ error code is an extended error code for SQLITE_IOERR indicating an I/O error in the VFS layer while trying to read from a file on disk. This error might result from a hardware malfunction or because a filesystem came unmounted while the file was open.!!SQLite3IOErrorReadLock commentStamp: '' prior: 0!The SQLITE_IOERR_RDLOCK error code is an extended error code for SQLITE_IOERR indicating an I/O error within xLock method on the sqlite3_io_methods object while trying to obtain a read lock.!!SQLite3IOErrorSeek commentStamp: '' prior: 0!The SQLITE_IOERR_SEEK error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xRead or xWrite methods on the sqlite3_io_methods object while trying to seek a file descriptor to the beginning point of the file where the read or write is to occur.!!SQLite3IOErrorSharedMemoryError commentStamp: '' prior: 0!Abstract superclass for extended errors on shared memory access in SQlite3!!SQLite3IOErrorSharedMemoryLock commentStamp: '' prior: 0!The SQLITE_IOERR_SHMLOCK error code is no longer used.!!SQLite3IOErrorSharedMemoryMap commentStamp: '' prior: 0!The SQLITE_IOERR_SHMMAP error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xShmMap method on the sqlite3_io_methods object while trying to map a shared memory segment into the process address space.!!SQLite3IOErrorSharedMemoryOpen commentStamp: '' prior: 0!The SQLITE_IOERR_SHMOPEN error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xShmMap method on the sqlite3_io_methods object while trying to open a new shared memory segment.!!SQLite3IOErrorSharedMemorySize commentStamp: '' prior: 0!The SQLITE_IOERR_SHMSIZE error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xShmMap method on the sqlite3_io_methods object while trying to enlarge a "shm" file as part of WAL mode transaction processing. This error may indicate that the underlying filesystem volume is out of space.!!SQLite3IOErrorShortRead commentStamp: '' prior: 0!The SQLITE_IOERR_SHORT_READ error code is an extended error code for SQLITE_IOERR indicating that a read attempt in the VFS layer was unable to obtain as many bytes as was requested. This might be due to a truncated file.!!SQLite3IOErrorTruncate commentStamp: '' prior: 0!The SQLITE_IOERR_TRUNCATE error code is an extended error code for SQLITE_IOERR indicating an I/O error in the VFS layer while trying to truncate a file to a smaller size.!!SQLite3IOErrorUnlock commentStamp: '' prior: 0!The SQLITE_IOERR_UNLOCK error code is an extended error code for SQLITE_IOERR indicating an I/O error within xUnlock method on the sqlite3_io_methods object.!!SQLite3IOErrorWrite commentStamp: '' prior: 0!The SQLITE_IOERR_WRITE error code is an extended error code for SQLITE_IOERR indicating an I/O error in the VFS layer while trying to write into a file on disk. This error might result from a hardware malfunction or because a filesystem came unmounted while the file was open. This error should not occur if the filesystem is full as there is a separate error code (SQLITE_FULL) for that purpose.!!SQLite3Internal commentStamp: '' prior: 0!The SQLITE_INTERNAL result code indicates an internal malfunction. In a working version of SQLite, an application should never see this result code. If application does encounter this result code, it shows that there is a bug in the database engine.SQLite does not currently generate this result code. However, application-defined SQL functions or virtual tables, or VFSes, or other extensions might cause this result code to be returned.!!SQLite3Interrupt commentStamp: '' prior: 0!The SQLITE_INTERRUPT result code indicates that an operation was interrupted by the sqlite3_interrupt() interface. See also: SQLITE_ABORT!!SQLite3Locked commentStamp: '' prior: 0!The SQLITE_LOCKED result code indicates that a write operation could not continue because of a conflict within the same database connection or a conflict with a different database connection that uses a shared cache.For example, a DROP TABLE statement cannot be run while another thread is reading from that table on the same database connection because dropping the table would delete the table out from under the concurrent reader.The SQLITE_LOCKED result code differs from SQLITE_BUSY in that SQLITE_LOCKED indicates a conflict on the same database connection (or on a connection with a shared cache) whereas SQLITE_BUSY indicates a conflict with a different database connection, probably in a different process.!!SQLite3LockedSharedCache commentStamp: '' prior: 0!The SQLITE_LOCKED_SHAREDCACHE error code is an extended error code for SQLITE_LOCKED indicating that the locking conflict has occurred due to contention with a different database connection that happens to hold a shared cache with the database connection to which the error was returned. For example, if the other database connection is holding an exclusive lock on the database, then the database connection that receives this error will be unable to read or write any part of the database file unless it has the read_uncommitted pragma enabled.The SQLITE_LOCKED_SHARECACHE error code works very much like the SQLITE_BUSY error code except that SQLITE_LOCKED_SHARECACHE is for separate database connections that share a cache whereas SQLITE_BUSY is for the much more common case of separate database connections that do not share the same cache. Also, the sqlite3_busy_handler() and sqlite3_busy_timeout() interfaces do not help in resolving SQLITE_LOCKED_SHAREDCACHE conflicts.!!SQLite3LogNotice commentStamp: '' prior: 0!The SQLITE_NOTICE result code is not returned by any C/C++ interface. However, SQLITE_NOTICE (or rather one of its extended error codes) is sometimes used as the first argument in an sqlite3_log() callback to indicate that an unusual operation is taking place.!!SQLite3LogNoticeRecoverRollback commentStamp: '' prior: 0!The SQLITE_NOTICE_RECOVER_ROLLBACK result code is passed to the callback of sqlite3_log() when a hot journal is rolled back.!!SQLite3LogNoticeRecoverWriteAheadLogging commentStamp: '' prior: 0!The SQLITE_NOTICE_RECOVER_WAL result code is passed to the callback of sqlite3_log() when a WAL mode database file is recovered.!!SQLite3LogWarning commentStamp: '' prior: 0!The SQLITE_WARNING result code is not returned by any C/C++ interface. However, SQLITE_WARNING (or rather one of its extended error codes) is sometimes used as the first argument in an sqlite3_log() callback to indicate that an unusual and possibly ill-advised operation is taking place.!!SQLite3LogWarningAutoIndex commentStamp: '' prior: 0!The SQLITE_WARNING_AUTOINDEX result code is passed to the callback of sqlite3_log() whenever automatic indexing is used. This can serve as a warning to application designers that the database might benefit from additional indexes.!!SQLite3Mismatch commentStamp: '' prior: 0!The SQLITE_MISMATCH error code indicates a datatype mismatch.SQLite is normally very forgiving about mismatches between the type of a value and the declared type of the container in which that value is to be stored. For example, SQLite allows the application to store a large BLOB in a column with a declared type of BOOLEAN. But in a few cases, SQLite is strict about types. The SQLITE_MISMATCH error is returned in those few cases when the types do not match.The rowid of a table must be an integer. Attempt to set the rowid to anything other than an integer (or a NULL which will be automatically converted into the next available integer rowid) results in an SQLITE_MISMATCH error.!!SQLite3Misuse commentStamp: '' prior: 0!The SQLITE_MISUSE return code might be returned if the application uses any SQLite interface in a way that is undefined or unsupported. For example, using a prepared statement after that prepared statement has been finalized might result in an SQLITE_MISUSE error.SQLite tries to detect misuse and report the misuse using this result code. However, there is no guarantee that the detection of misuse will be successful. Misuse detection is probabilistic. Applications should never depend on an SQLITE_MISUSE return value.If SQLite ever returns SQLITE_MISUSE from any interface, that means that the application is incorrectly coded and needs to be fixed. Do not ship an application that sometimes returns SQLITE_MISUSE from a standard SQLite interface because that application contains potentially serious bugs.!!SQLite3NoLargeFileSupport commentStamp: '' prior: 0!The SQLITE_NOLFS error can be returned on systems that do not support large files when the database grows to be larger than what the filesystem can handle. "NOLFS" stands for "NO Large File Support".!!SQLite3NoMemory commentStamp: '' prior: 0!The SQLITE_NOMEM result code indicates that SQLite was unable to allocate all the memory it needed to complete the operation. In other words, an internal call to sqlite3_malloc() or sqlite3_realloc() has failed in a case where the memory being allocated was required in order to continue the operation.!!SQLite3NotADatabase commentStamp: '' prior: 0!When attempting to open a file, the SQLITE_NOTADB error indicates that the file being opened does not appear to be an SQLite database file.!!SQLite3NotFound commentStamp: '' prior: 0!The SQLITE_NOTFOUND result code is used in two contexts. SQLITE_NOTFOUND can be returned by the sqlite3_file_control() interface to indicate that the file control opcode passed as the third argument was not recognized by the underlying VFS. SQLITE_NOTFOUND can also be returned by the xSetSystemCall() method of an sqlite3_vfs object.The SQLITE_NOTFOUND result code is also used internally by the SQLite implementation, but those internal uses are not exposed to the application.!!SQLite3OutOfRange commentStamp: '' prior: 0!The SQLITE_RANGE error indices that the parameter number argument to one of the sqlite3_bind routines or the column number in one of the sqlite3_column routines is out of range.!!SQLite3Permission commentStamp: '' prior: 0!The SQLITE_PERM result code indicates that the requested access mode for a newly created database could not be provided.!!SQLite3Protocol commentStamp: '' prior: 0!The SQLITE_PROTOCOL result code indicates a problem with the file locking protocol used by SQLite. The SQLITE_PROTOCOL error is currently only returned when using WAL mode and attempting to start a new transaction. There is a race condition that can occur when two separate database connections both try to start a transaction at the same time in WAL mode. The loser of the race backs off and tries again, after a brief delay. If the same connection loses the locking race dozens of times over a span of multiple seconds, it will eventually give up and return SQLITE_PROTOCOL. The SQLITE_PROTOCOL error should appear in practice very, very rarely, and only when there are many separate processes all competing intensely to write to the same database.!!SQLite3ReadOnly commentStamp: '' prior: 0!The SQLITE_READONLY result code is returned when an attempt is made to alter some data for which the current database connection does not have write permission.!!SQLite3ReadOnlyCantLock commentStamp: '' prior: 0!The SQLITE_READONLY_CANTLOCK error code is an extended error code for SQLITE_READONLY. The SQLITE_READONLY_CANTLOCK error code indicates that SQLite is unable to obtain a read lock on a WAL mode database because the shared-memory file associated with that database is read-only.!!SQLite3ReadOnlyDBMoved commentStamp: '' prior: 0!The SQLITE_READONLY_DBMOVED error code is an extended error code for SQLITE_READONLY. The SQLITE_READONLY_DBMOVED error code indicates that a database cannot be modified because the database file has been moved since it was opened, and so any attempt to modify the database might result in database corruption if the processes crashes because the rollback journal would not be correctly named.!!SQLite3ReadOnlyRecovery commentStamp: '' prior: 0!The SQLITE_READONLY_RECOVERY error code is an extended error code for SQLITE_READONLY. The SQLITE_READONLY_RECOVERY error code indicates that a WAL mode database cannot be opened because the database file needs to be recovered and recovery requires write access but only read access is available.!!SQLite3ReadOnlyRollback commentStamp: '' prior: 0!The SQLITE_READONLY_ROLLBACK error code is an extended error code for SQLITE_READONLY. The SQLITE_READONLY_ROLLBACK error code indicates that a database cannot be opened because it has a hot journal that needs to be rolled back but cannot because the database is readonly.!!SQLite3SchemaChanged commentStamp: '' prior: 0!The SQLITE_SCHEMA result code indicates that the database schema has changed. This result code can be returned from sqlite3_step() for a prepared statement that was generated using sqlite3_prepare() or sqlite3_prepare16(). If the database schema was changed by some other process in between the time that the statement was prepared and the time the statement was run, this error can result.If a prepared statement is generated from sqlite3_prepare_v2() then the statement is automatically re-prepared if the schema changes, up to SQLITE_MAX_SCHEMA_RETRY times (default: 50). The sqlite3_step() interface will only return SQLITE_SCHEMA back to the application if the failure persists after these many retries.!!SQLite3TooBig commentStamp: '' prior: 0!The SQLITE_TOOBIG error code indicates that a string or BLOB was too large. The default maximum length of a string or BLOB in SQLite is 1,000,000,000 bytes. This maximum length can be changed at compile-time using the SQLITE_MAX_LENGTH compile-time option, or at run-time using the sqlite3_limit(db,SQLITE_LIMIT_LENGTH,...) interface. The SQLITE_TOOBIG error results when SQLite encounters a string or BLOB that exceeds the compile-time or run-time limit.The SQLITE_TOOBIG error code can also result when an oversized SQL statement is passed into one of the sqlite3_prepare_v2() interfaces. The maximum length of an SQL statement defaults to a much smaller value of 1,000,000 bytes. The maximum SQL statement length can be set at compile-time using SQLITE_MAX_SQL_LENGTH or at run-time using sqlite3_limit(db,SQLITE_LIMIT_SQL_LENGTH,...).!!SQLite3PreparedStatement commentStamp: '' prior: 0!I represent an SQLite prepared statement.!!SQLite3Result commentStamp: '' prior: 0!I am an abstract superclass for corresponding classes to result codes created by SQLite3 C library.Subclasses should not be instantiated directly. Instead use #forNativeResultCode: with a valid result constant.   SQLite3Result forNativeResultCode: SQLITE_OK!!SQLite3DoneResult commentStamp: '' prior: 0!The SQLITE_DONE result code indicates that an operation has completed. The SQLITE_DONE result code is most commonly seen as a return value from sqlite3_step() indicating that the SQL statement has run to completion. But SQLITE_DONE can also be returned by other multi-step interfaces such as sqlite3_backup_step().!!SQLite3OKResult commentStamp: '' prior: 0!The SQLITE_OK result code means that the operation was successful and that there were no errors. Most other result codes indicate an error.!!SQLite3RowResult commentStamp: '' prior: 0!The SQLITE_ROW result code returned by sqlite3_step() indicates that another row of output is available.!!FFIExternalReference methodsFor: '*SQLite3-Core' stamp: '3/1/2025 19:01'!manualRelease	FFIExternalResourceManager uniqueInstance removeResource: self! !!SQLite3BackupExternalReference methodsFor: 'initialization' stamp: '3/1/2025 19:01'!beNull	^ handle beNull! !!SQLite3DatabaseExternalObject class methodsFor: 'instance finalization' stamp: '3/1/2025 19:01'!doFinalizeResourceData: resourceData	SQLite3Library current ffiCall:		#( int sqlite3_close_v2 #( void * resourceData ) )! !!SQLite3DatabaseExternalObject class methodsFor: 'finalization' stamp: '3/1/2025 19:01'!finalizeResourceData: aHandle	self doFinalizeResourceData: aHandle.	aHandle beNull! !!SQLite3DatabaseExternalObject methodsFor: 'initialization' stamp: '3/1/2025 19:01'!beNull	^ handle beNull! !!SQLite3StatementExternalObject class methodsFor: 'instance finalization' stamp: '3/1/2025 19:01'!doFinalizeResourceData: aHandle	SQLite3Library current ffiCall:		#( int sqlite3_finalize #( void * aHandle ) )! !!SQLite3StatementExternalObject class methodsFor: 'finalization' stamp: '3/1/2025 19:01'!finalizeResourceData: aHandle	self doFinalizeResourceData: aHandle.	aHandle beNull! !!SQLite3StatementExternalObject methodsFor: 'initialization' stamp: '3/1/2025 19:01'!beNull	^ handle beNull! !!SQLite3AbstractError class methodsFor: 'testing' stamp: '3/1/2025 19:01'!isAbstract	^self name = #SQLite3AbstractError! !!SQLite3AbstractError methodsFor: 'accessing' stamp: '3/1/2025 19:01'!resultCode	^ resultCode! !!SQLite3AbstractError methodsFor: 'accessing' stamp: '3/1/2025 19:01'!resultCode: anObject	resultCode := anObject! !!FFIExternalResourceManager methodsFor: '*SQLite3-Core' stamp: '3/1/2025 19:01'!removeResource: anObject	registry remove: anObject ifAbsent: [  ]! !!SQLite3Backup class methodsFor: 'creating' stamp: '3/1/2025 19:01'!to: dConnection named: dName from: sConnection named: sName	^(self new)		dstConnection: dConnection;		dstName: dName;		srcConnection: sConnection;		srcName: sName! !!SQLite3Backup methodsFor: 'accessing' stamp: '3/1/2025 19:01'!dstConnection	^ dstConnection! !!SQLite3Backup methodsFor: 'accessing' stamp: '3/1/2025 19:01'!dstConnection: anObject	dstConnection := anObject! !!SQLite3Backup methodsFor: 'accessing' stamp: '3/1/2025 19:01'!dstName	^ dstName! !!SQLite3Backup methodsFor: 'accessing' stamp: '3/1/2025 19:01'!dstName: anObject	dstName := anObject! !!SQLite3Backup methodsFor: 'finalization' stamp: '3/1/2025 19:01'!finalize	self finish! !!SQLite3Backup methodsFor: 'initialization' stamp: '3/1/2025 19:01'!finish	handle		ifNotNil: [			library apiBackupFinish: handle.			handle beNull.			handle := nil]! !!SQLite3Backup methodsFor: 'accessing' stamp: '3/1/2025 19:01'!handle	^ handle! !!SQLite3Backup methodsFor: 'accessing' stamp: '3/1/2025 19:01'!handle: anObject	handle := anObject! !!SQLite3Backup methodsFor: 'initialization' stamp: '3/1/2025 19:01'!initialize	super initialize.	isOpen := false.	library := SQLite3Library current.	handle := SQLite3DatabaseExternalObject new.	handle autoRelease! !!SQLite3Backup methodsFor: 'accessing' stamp: '3/1/2025 19:01'!isOpen	^ isOpen! !!SQLite3Backup methodsFor: 'accessing' stamp: '3/1/2025 19:01'!open	handle := (library backupTo: dstConnection named: dstName from: srcConnection named: srcName).	isOpen := true! !!SQLite3Backup methodsFor: 'accessing' stamp: '3/1/2025 19:01'!srcConnection	^ srcConnection! !!SQLite3Backup methodsFor: 'accessing' stamp: '3/1/2025 19:01'!srcConnection: anObject	srcConnection := anObject! !!SQLite3Backup methodsFor: 'accessing' stamp: '3/1/2025 19:01'!srcName	^ srcName! !!SQLite3Backup methodsFor: 'accessing' stamp: '3/1/2025 19:01'!srcName: anObject	srcName := anObject! !!SQLite3Backup methodsFor: 'accessing' stamp: '3/1/2025 19:01'!step	"Passing negative number means run to completion"	self step: -1! !!SQLite3Backup methodsFor: 'accessing' stamp: '3/1/2025 19:01'!step: nPages	library backup: handle step: nPages! !!SQLite3BaseConnection class methodsFor: 'testing' stamp: '3/1/2025 19:01'!isAbstract	^ self == SQLite3BaseConnection! !!SQLite3BaseConnection class methodsFor: 'testing' stamp: '3/1/2025 19:01'!isThreadsafe	"Native Library Version http://sqlite.org/c3ref/libversion.html sqlite3_libversion"	^ SQLite3Library current isThreadsafe ~= 0! !!SQLite3BaseConnection class methodsFor: 'accessing' stamp: '3/1/2025 19:01'!libraryVersion	"Native Library Version http://sqlite.org/c3ref/libversion.html sqlite3_libversion"	^ SQLite3Library current libraryVersion! !!SQLite3BaseConnection class methodsFor: 'examples' stamp: '3/1/2025 19:01'!memory	^ self on: ':memory:'! !!SQLite3BaseConnection class methodsFor: 'instance creation' stamp: '3/1/2025 19:01'!on: aFilename	^(self new)		on: aFilename;		yourself! !!SQLite3BaseConnection class methodsFor: 'instance creation' stamp: '3/1/2025 19:01'!openOn: aFilename	^(self new)		on: aFilename;		open;		yourself! !!SQLite3BaseConnection class methodsFor: 'testing' stamp: '3/1/2025 19:01'!threadsafe	"This method is deprecated so consider to migrate."	self deprecated:  'Please use #isThreadsafe instead' transformWith:  '`@receiver threadsafe'						-> '`@receiver isThreadsafe'.	^ self isThreadsafe! !!SQLite3BaseConnection methodsFor: 'public API - backups' stamp: '3/1/2025 19:01'!backupDatabaseNamed: sName to: aConnection named: dName	"database name is either 'main' or 'temp' or the name given to ATTACH DATABASE	See article at https://www.oreilly.com/library/view/using-sqlite/9781449394592/re225.html"	^SQLite3Backup to: aConnection handle named: dName from: dbHandle named: sName! !!SQLite3BaseConnection methodsFor: 'public API - backups' stamp: '3/1/2025 19:01'!backupTo: aConnection	^self backupTo: aConnection named: 'main'! !!SQLite3BaseConnection methodsFor: 'public API - backups' stamp: '3/1/2025 19:01'!backupTo: aConnection named: aName	^SQLite3Backup to: aConnection handle named: aName from: dbHandle named: 'main'! !!SQLite3BaseConnection methodsFor: 'public API - operating' stamp: '3/1/2025 19:01'!basicExecute: anSQLText	^ (self prepare: anSQLText) step; finalize"20190302, pierce: This used to invoke sqlite3_exec() which is an SQLite-internal convenience wrapper around prepare/step/finalize. It is now rewritten as seen to handle UTF8-encoded input properly. Rewriting this method breaks the Bobby Tables test which relies on naive SQL string construction to work."! !!SQLite3BaseConnection methodsFor: 'public API - transactional' stamp: '3/1/2025 19:01'!beginTransaction	^ self basicExecute: 'begin'! !!SQLite3BaseConnection methodsFor: 'public API - introspection' stamp: '3/1/2025 19:01'!changes	^ library changes: dbHandle! !!SQLite3BaseConnection methodsFor: 'public API - operating' stamp: '3/1/2025 19:01'!clearBindings: aStatement	library clearBindings: aStatement handle on: dbHandle! !!SQLite3BaseConnection methodsFor: 'public API - open/close' stamp: '3/1/2025 19:01'!close	"Do the minimal work to close the connection. 	Let FFIExternalResourceManager take care of calling sqlite_close_v2()."	dbHandle ifNil: [ ^ self ].	"Set dbHandle to nil to allow its garbage collection.	The underlying handle should not be switched to NULL here, SQLite3DatabaseExternalObject class>>doFinalizeResourceData: will take care of that"	dbHandle := nil.	isOpen := false! !!SQLite3BaseConnection methodsFor: 'public API - introspection' stamp: '3/1/2025 19:01'!columnNamesFor: aTableName	self isOpen		ifFalse: [ SQLite3NotOpen signal ]		ifTrue: [			^ (self existTableNamed: aTableName)				  ifTrue: [					  | columns s |					  columns := OrderedCollection new.					  s := self prepare: 'pragma table_info([' , aTableName , '])'.					  s basicExecute: [ :row | columns add: (row stringAt: 1) ].					  s finalize.					  columns ]				  ifFalse: [ nil ] ]! !!SQLite3BaseConnection methodsFor: 'public API - transactional' stamp: '3/1/2025 19:01'!commitTransaction	^ self basicExecute: 'commit'! !!SQLite3BaseConnection methodsFor: 'public API - introspection' stamp: '3/1/2025 19:01'!declaredColumnTypesFor: aTableName	self isOpen		ifFalse: [ SQLite3NotOpen signal ]		ifTrue: [			^ (self existTableNamed: aTableName)				  ifTrue: [					  | columns s |					  columns := OrderedCollection new.					  s := self prepare: 'pragma table_info([' , aTableName , '])'.					  s basicExecute: [ :row | columns add: (row stringAt: 2) ].					  s finalize.					  columns ]				  ifFalse: [ nil ] ]! !!SQLite3BaseConnection methodsFor: 'public API - extensions' stamp: '3/1/2025 19:01'!disableExtensions	^ library disableLoadExtension: dbHandle! !!SQLite3BaseConnection methodsFor: 'public API - extensions' stamp: '3/1/2025 19:01'!enableExtensions	^ library enableLoadExtension: dbHandle! !!SQLite3BaseConnection methodsFor: 'private' stamp: '3/1/2025 19:01'!existTableNamed: aTableName	| tableExists s |	tableExists := false.	s := self prepare: 'select count(*) from sqlite_master where type = "table" and tbl_name = ?'.	s at: 1 putString: aTableName.	s basicExecute: [ :row | tableExists := (row integerAt: 0) = 1 ].	s finalize.	^ tableExists! !!SQLite3BaseConnection methodsFor: 'accessing' stamp: '3/1/2025 19:01'!filename	^ dbFilename! !!SQLite3BaseConnection methodsFor: 'public API - operating' stamp: '3/1/2025 19:01'!finalize: aStatementHandle	library finalize: aStatementHandle on: dbHandle! !!SQLite3BaseConnection methodsFor: 'public API - open/close' stamp: '3/1/2025 19:01'!forceClose	"Forces the release of dbHandle, enabling to delete the database file without closing Pharo"	dbHandle ifNotNil: [ library close: dbHandle ].	self close! !!SQLite3BaseConnection methodsFor: 'public API - introspection' stamp: '3/1/2025 19:01'!getAutoCommit	^library getAutoCommit: dbHandle! !!SQLite3BaseConnection methodsFor: 'accessing' stamp: '3/1/2025 19:01'!handle	^dbHandle! !!SQLite3BaseConnection methodsFor: 'initialization' stamp: '3/1/2025 19:01'!initialize	super initialize.	isOpen := false.	library := SQLite3Library current.	dbHandle := SQLite3DatabaseExternalObject new.	dbHandle autoRelease.	statementClass := SQLite3PreparedStatement! !!SQLite3BaseConnection methodsFor: 'testing' stamp: '3/1/2025 19:01'!isOpen	^ isOpen! !!SQLite3BaseConnection methodsFor: 'public API - extensions' stamp: '3/1/2025 19:01'!loadExtension: aFilename	^ library loadExtension: dbHandle with: aFilename! !!SQLite3BaseConnection methodsFor: 'private' stamp: '3/1/2025 19:01'!on: aFilename	dbFilename := aFilename.	^ self! !!SQLite3BaseConnection methodsFor: 'public API - open/close' stamp: '3/1/2025 19:01'!open	library open: dbFilename via: dbHandle.	isOpen := true! !!SQLite3BaseConnection methodsFor: 'public API - operating' stamp: '3/1/2025 19:01'!prepare: anSQLText	| s |	s := self statementClass new.	s connection: self.	s prepare: anSQLText.	^ s! !!SQLite3BaseConnection methodsFor: 'public API - cleaning' stamp: '3/1/2025 19:01'!reset: aStatement	^library reset: aStatement handle! !!SQLite3BaseConnection methodsFor: 'public API - transactional' stamp: '3/1/2025 19:01'!rollbackTransaction	^ self basicExecute: 'rollback'! !!SQLite3BaseConnection methodsFor: 'private' stamp: '3/1/2025 19:01'!signal: exceptionClass with: value	library signal: exceptionClass with: value on: dbHandle! !!SQLite3BaseConnection methodsFor: 'accessing' stamp: '3/1/2025 19:01'!statementClass	^ statementClass! !!SQLite3BaseConnection methodsFor: 'public API - introspection' stamp: '3/1/2025 19:01'!tableNames	| tables s |	self isOpen		ifFalse: [ SQLite3NotOpen signal ]		ifTrue: [			tables := OrderedCollection new.			s := self prepare: 'select tbl_name from sqlite_master where type = "table"'.	  		s basicExecute: [ :row |				(row dataValuesAvailable > 0) ifTrue: [ tables add: (row stringAt: 0) ]].	  		s finalize.			^ tables ]! !!SQLite3BaseConnection methodsFor: 'public API - introspection' stamp: '3/1/2025 19:01'!totalChanges	^ library totalChanges: dbHandle! !!SQLite3BaseConnection methodsFor: 'public API - tracing' stamp: '3/1/2025 19:01'!traceUsing: callback with: appdata	library trace: dbHandle with: callback with: appdata! !!SQLite3Connection methodsFor: 'public API - operating' stamp: '3/1/2025 19:01'!execute: anSQLText	^ self execute: anSQLText with: #()! !!SQLite3Connection methodsFor: 'public API - operating' stamp: '3/1/2025 19:01'!execute: anSQLText value: anObject	^ (self prepare: anSQLText)	execute: (Array with: anObject)! !!SQLite3Connection methodsFor: 'public API - operating' stamp: '3/1/2025 19:01'!execute: anSQLText value: object1 value: object2	^ self execute: anSQLText with: (Array with: object1 with: object2)! !!SQLite3Connection methodsFor: 'public API - operating' stamp: '3/1/2025 19:01'!execute: anSQLText value: object1 value: object2 value: object3	^ self execute: anSQLText		with: (Array with: object1 with: object2 with: object3)! !!SQLite3Connection methodsFor: 'public API - operating' stamp: '3/1/2025 19:01'!execute: anSQLText value: object1 value: object2 value: object3 value: object4	^ self execute: anSQLText		with: (Array with: object1 with: object2 with: object3 with: object4)! !!SQLite3Connection methodsFor: 'public API - operating' stamp: '3/1/2025 19:01'!execute: anSQLText with: aCollection	^(self prepare: anSQLText) execute: aCollection! !!SQLite3Connection methodsFor: 'public API - operating' stamp: '3/1/2025 19:01'!execute: anSQLText with: aCollection doing: aBlock	| cursor |	cursor := self execute: anSQLText with: aCollection.	^ [aBlock value: cursor]			ensure: [ cursor finalizeStatement ]! !!SQLite3Connection methodsFor: 'public API - operating' stamp: '3/1/2025 19:01'!execute: anSQLText withAll: parameterCollection	"execute a sql statement with many parameters"	| stmt |	stmt := self prepare: anSQLText.	parameterCollection do: [ :parameters | stmt execute: parameters ].	stmt finalize! !!SQLite3Column methodsFor: 'accessing' stamp: '3/1/2025 19:01'!cid: anObject	"The cid column should not be taken to mean more than 'rank within the current result set'."	index := anObject! !!SQLite3Column methodsFor: 'accessing' stamp: '3/1/2025 19:01'!hasNotNullConstraint	^ hasNotNullConstraint! !!SQLite3Column methodsFor: 'accessing' stamp: '3/1/2025 19:01'!index	^ index! !!SQLite3Column methodsFor: 'accessing' stamp: '3/1/2025 19:01'!index: anObject	index := anObject! !!SQLite3Column methodsFor: 'initialization' stamp: '3/1/2025 19:01'!initialize	super initialize.	hasNotNullConstraint := false! !!SQLite3Column methodsFor: 'accessing' stamp: '3/1/2025 19:01'!name	^ name! !!SQLite3Column methodsFor: 'accessing' stamp: '3/1/2025 19:01'!name: anObject	name := anObject! !!SQLite3Column methodsFor: 'accessing' stamp: '3/1/2025 19:01'!notnull: anInteger	"whether or not the column can be NULL"	hasNotNullConstraint := anInteger = 1! !!SQLite3Column methodsFor: 'printing' stamp: '3/1/2025 19:01'!printOn: aStream	super printOn: aStream.	aStream		<< '("';		<< self name;		<< '")'! !!SQLite3Column methodsFor: 'accessing' stamp: '3/1/2025 19:01'!type	^ type! !!SQLite3Column methodsFor: 'accessing' stamp: '3/1/2025 19:01'!type: anObject	type := anObject! !!SQLite3Database class methodsFor: 'instance creation' stamp: '3/1/2025 19:01'!forConnection: aConnection	^ self new		initConnection: aConnection;		yourself! !!SQLite3Database class methodsFor: 'instance creation' stamp: '3/1/2025 19:01'!memory	^ self forConnection: SQLite3Connection memory! !!SQLite3Database class methodsFor: 'instance creation' stamp: '3/1/2025 19:01'!on: aFilename	^ self forConnection: (SQLite3Connection on: aFilename)! !!SQLite3Database class methodsFor: 'instance creation' stamp: '3/1/2025 19:01'!openOn: aFilename	^ (self on: aFilename)			open;			yourself! !!SQLite3Database class methodsFor: 'accessing' stamp: '3/1/2025 19:01'!tableInfoFor: aFileName	| db |	db := self on: aFileName.	db connection open.	^ db tables! !!SQLite3Database methodsFor: 'open/close' stamp: '3/1/2025 19:01'!close	^ self connection close! !!SQLite3Database methodsFor: 'accessing' stamp: '3/1/2025 19:01'!connection	^ connection! !!SQLite3Database methodsFor: 'executing' stamp: '3/1/2025 19:01'!execute: anSQLStatement	^ self connection execute: anSQLStatement! !!SQLite3Database methodsFor: 'executing' stamp: '3/1/2025 19:01'!execute: anSQLStatement doing: aBlock	^ self connection execute: anSQLStatement with: #(  ) doing: aBlock! !!SQLite3Database methodsFor: 'private - initialization' stamp: '3/1/2025 19:01'!initConnection: aConnection	connection := aConnection! !!SQLite3Database methodsFor: 'open/close' stamp: '3/1/2025 19:01'!open	^ self connection open! !!SQLite3Database methodsFor: 'printing' stamp: '3/1/2025 19:01'!printOn: aStream	super printOn: aStream.	aStream		<< '("';		<< self connection filename;		<< '")'! !!SQLite3Database methodsFor: 'accessing' stamp: '3/1/2025 19:01'!tables	self connection isOpen ifFalse: [ ^ SQLite3NotOpen signal ].	^ (connection execute: '			SELECT *			FROM sqlite_master			WHERE			    type =''table'' AND    			name NOT LIKE ''sqlite_%'';') rows collect: [ :eachRow |		  SQLite3Table properties: eachRow asDictionary in: self ]! !!SQLite3Row class methodsFor: 'instance creation' stamp: '3/1/2025 19:01'!new: anInteger	^(self new)		columnNames:(Array new:anInteger);		values: (Array new: anInteger);		yourself! !!SQLite3Row methodsFor: 'converting' stamp: '3/1/2025 19:01'!asArray	^ self values asArray! !!SQLite3Row methodsFor: 'converting' stamp: '3/1/2025 19:01'!asCombinedDictionary	^self asDictionary addAll: ((self values collectWithIndex:[:v :i | i -> v]) asDictionary); yourself! !!SQLite3Row methodsFor: 'converting' stamp: '3/1/2025 19:01'!asDictionary	"Borrowed from the future - Pharo 8"	| dict |	dict := Dictionary new.	self columnNames with: self values do: [ :k :v | dict at: k put: v ].	^ dict! !!SQLite3Row methodsFor: 'accessing' stamp: '3/1/2025 19:01'!at: aKey	^ self at: aKey ifAbsent: [  ]! !!SQLite3Row methodsFor: 'accessing' stamp: '3/1/2025 19:01'!at: aKey ifAbsent: aBlock	^ aKey isInteger		ifTrue: [ self values at: aKey ifAbsent: aBlock ]		ifFalse: [ self values at:(self columnNames indexOf: aKey) ifAbsent: aBlock ]! !!SQLite3Row methodsFor: 'accessing' stamp: '3/1/2025 19:01'!at: aKey put: anObject	^ aKey isInteger		ifTrue: [self atIndex: aKey put: anObject]		ifFalse: [ self atName: aKey put: anObject ]! !!SQLite3Row methodsFor: 'accessing' stamp: '3/1/2025 19:01'!atIndex: anIndex	^ values at: anIndex ifAbsent: [  ]! !!SQLite3Row methodsFor: 'accessing' stamp: '3/1/2025 19:01'!atIndex: anIndex put: anObject	^ self values at: anIndex put: anObject! !!SQLite3Row methodsFor: 'accessing' stamp: '3/1/2025 19:01'!atName: aKey	| idx |	idx := self columnNames indexOf: aKey.	^idx = 0		ifTrue: [ SQLite3Misuse				signal: 'Attept to set invalid column name ', aKey, ' in result set'   ]		ifFalse: [ values at: idx ]! !!SQLite3Row methodsFor: 'accessing' stamp: '3/1/2025 19:01'!atName: aKey put: anObject	| idx |	^ (idx := self columnNames indexOf: aKey) isZero		ifTrue: [			columnNames := self columnNames copyWith: aKey.			values := self values copyWith: anObject ]		ifFalse: [ values at: idx put: anObject ]! !!SQLite3Row methodsFor: 'accessing' stamp: '3/1/2025 19:01'!columnNames	^ columnNames ifNil: [ #() ]! !!SQLite3Row methodsFor: 'accessing' stamp: '3/1/2025 19:01'!columnNames: anArray	columnNames := anArray.	values := Array new: anArray size! !!SQLite3Row methodsFor: 'accessing' stamp: '3/1/2025 19:01'!data	"compatibility"	 ^self asCombinedDictionary! !!SQLite3Row methodsFor: 'accessing' stamp: '3/1/2025 19:01'!dataCount	^ self columnNames size! !!SQLite3Row methodsFor: 'reflective operations' stamp: '3/1/2025 19:01'!doesNotUnderstand: aMessage	^ self at: aMessage selector asString			ifAbsent: [				"20160514: This bit, for Glorp integration, feels a bit iffy."				self at: aMessage selector asString asUppercase					ifAbsent: [ super doesNotUnderstand: aMessage ]]! !!SQLite3Row methodsFor: 'accessing' stamp: '3/1/2025 19:01'!first	^ self values ifEmpty: [] ifNotEmpty: [:v | v first ]! !!SQLite3Row methodsFor: 'accessing' stamp: '3/1/2025 19:01'!last	^ self values ifEmpty: [ nil ] ifNotEmpty: [:v | v last ]! !!SQLite3Row methodsFor: 'accessing' stamp: '3/1/2025 19:01'!size	^ self columnNames size! !!SQLite3Row methodsFor: 'accessing' stamp: '3/1/2025 19:01'!values	 ^values ifNil: [ #() ]! !!SQLite3Row methodsFor: 'accessing' stamp: '3/1/2025 19:01'!values: anArray	 values := anArray! !!SQLite3Table class methodsFor: 'instance creation' stamp: '3/1/2025 19:01'!properties: aDictionary in: aDatabase	^ self new		database: aDatabase;		properties: aDictionary;		yourself! !!SQLite3Table methodsFor: 'accessing' stamp: '3/1/2025 19:01'!columnNames	^ self columns collect: [:each | each name ]! !!SQLite3Table methodsFor: 'accessing' stamp: '3/1/2025 19:01'!columns	^ (self database execute: 'pragma table_info([' , self name , ']);')		  rowClass: SQLite3Column;		  rows! !!SQLite3Table methodsFor: 'accessing' stamp: '3/1/2025 19:01'!database	^ database! !!SQLite3Table methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!database: anObject	database := anObject! !!SQLite3Table methodsFor: 'accessing' stamp: '3/1/2025 19:01'!name	^ self properties at: #name ifAbsent: [ '' ]! !!SQLite3Table methodsFor: 'accessing' stamp: '3/1/2025 19:01'!numberOfRows	^ (self database execute: 'SELECT COUNT(*) FROM [' , self name , '];')		  onlyValue! !!SQLite3Table methodsFor: 'printing' stamp: '3/1/2025 19:01'!printOn: aStream	super printOn: aStream.	aStream		<< '("';		<< self name;		<< '")'! !!SQLite3Table methodsFor: 'accessing' stamp: '3/1/2025 19:01'!properties	^ properties ifNil: [ properties := Dictionary new ]! !!SQLite3Table methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!properties: anObject	properties := anObject! !!SQLite3Table methodsFor: 'accessing' stamp: '3/1/2025 19:01'!rows	^ (self database execute: 'SELECT *			FROM [' , self name , ']			LIMIT 1000;') rows! !!SQLite3Table methodsFor: 'accessing' stamp: '3/1/2025 19:01'!schema	^ self properties at: #sql ifAbsent: ''! !!SQLite3Constants class methodsFor: 'private - initialization' stamp: '3/1/2025 19:01'!initCheckpointModes    SQLITE_CHECKPOINT_PASSIVE := 0.    SQLITE_CHECKPOINT_FULL := 1.    SQLITE_CHECKPOINT_RESTART := 2.    SQLITE_CHECKPOINT_TRUNCATE := 3! !!SQLite3Constants class methodsFor: 'private - initialization' stamp: '3/1/2025 19:01'!initConstants	self		initResultCodes;		initErrorCodes;		initExtendedErrorCodes;		initFileOpenFlags! !!SQLite3Constants class methodsFor: 'private - initialization' stamp: '3/1/2025 19:01'!initDataTypes	"Fundamental Datatypes"	SQLITE_INTEGER := 1.	SQLITE_FLOAT := 2.	SQLITE_TEXT := 3.	SQLITE3_TEXT := 3.	SQLITE_BLOB := 4.	SQLITE_NULL := 5! !!SQLite3Constants class methodsFor: 'private - initialization constants' stamp: '3/1/2025 19:01'!initErrorCodes	"In its default configuration, SQLite API routines return one of 26 integer	[SQLITE_OK | result codes]."	SQLITE_ERROR := 1. 			"SQL error or missing database"	SQLITE_INTERNAL := 2.			"Internal logic error in SQLite"	SQLITE_PERM := 3.				"Access permission denied"	SQLITE_ABORT := 4.				"Callback routine requested an abort"	SQLITE_BUSY := 5.  			"The database file is locked"	SQLITE_LOCKED := 6. 			"A table in the database is locked"	SQLITE_NOMEM := 7.				"A malloc() failed"	SQLITE_READONLY := 8.			"Attempt to write a readonly database"	SQLITE_INTERRUPT := 9.		"Operation terminated by sqlite3_interrupt()"	SQLITE_IOERR := 10.			"Some kind of disk I/O error occurred"	SQLITE_CORRUPT := 11.			"The database disk image is malformed"	SQLITE_NOTFOUND := 12.		"Unknown opcode in sqlite3_file_control()"	SQLITE_FULL := 13.				"Insertion failed because database is full"	SQLITE_CANTOPEN := 14.   	"Unable to open the database file"	SQLITE_PROTOCOL := 15.		"Database lock protocol error"	SQLITE_EMPTY := 16.			"Database is empty"	SQLITE_SCHEMA := 17.			"The database schema changed"	SQLITE_TOOBIG := 18.			"String or BLOB exceeds size limit"	SQLITE_CONSTRAINT := 19.		"Abort due to constraint violation"	SQLITE_MISMATCH := 20.		"Data type mismatch"	SQLITE_MISUSE := 21. 			"Library used incorrectly"	SQLITE_NOLFS := 22.			"Uses OS features not supported on host"	SQLITE_AUTH := 23.				"Authorization denied"	SQLITE_FORMAT := 24.			"Auxiliary database format error"	SQLITE_RANGE := 25.			"2nd parameter to sqlite3_bind out of range"	SQLITE_NOTADB := 26.			"File opened that is not a database file"	SQLITE_NOTICE := 27.			"Notifications from sqlite3_log()"	SQLITE_WARNING := 28.			"Warnings from sqlite3_log()"! !!SQLite3Constants class methodsFor: 'private - initialization constants' stamp: '3/1/2025 19:01'!initExtendedErrorCodes	"Newer versions of SQLite (version 3.3.8 and later) include support for additional result codes that provide more detailed information about errors. The extended result codes are enabled or disabled on a per database connection basis using the [sqlite3_extended_result_codes()] API."    SQLITE_ERROR_MISSING_COLLSEQ    := (SQLITE_ERROR | (1<<8)).    SQLITE_ERROR_RETRY              := (SQLITE_ERROR | (2<<8)).    SQLITE_ERROR_SNAPSHOT           := (SQLITE_ERROR | (3<<8)).    SQLITE_IOERR_READ               := (SQLITE_IOERR | (1<<8)).    SQLITE_IOERR_SHORT_READ         := (SQLITE_IOERR | (2<<8)).    SQLITE_IOERR_WRITE              := (SQLITE_IOERR | (3<<8)).    SQLITE_IOERR_FSYNC              := (SQLITE_IOERR | (4<<8)).    SQLITE_IOERR_DIR_FSYNC          := (SQLITE_IOERR | (5<<8)).    SQLITE_IOERR_TRUNCATE           := (SQLITE_IOERR | (6<<8)).    SQLITE_IOERR_FSTAT              := (SQLITE_IOERR | (7<<8)).    SQLITE_IOERR_UNLOCK             := (SQLITE_IOERR | (8<<8)).    SQLITE_IOERR_RDLOCK             := (SQLITE_IOERR | (9<<8)).    SQLITE_IOERR_DELETE             := (SQLITE_IOERR | (10<<8)).    SQLITE_IOERR_BLOCKED            := (SQLITE_IOERR | (11<<8)).    SQLITE_IOERR_NOMEM              := (SQLITE_IOERR | (12<<8)).    SQLITE_IOERR_ACCESS             := (SQLITE_IOERR | (13<<8)).    SQLITE_IOERR_CHECKRESERVEDLOCK  := (SQLITE_IOERR | (14<<8)).    SQLITE_IOERR_LOCK               := (SQLITE_IOERR | (15<<8)).    SQLITE_IOERR_CLOSE              := (SQLITE_IOERR | (16<<8)).    SQLITE_IOERR_DIR_CLOSE          := (SQLITE_IOERR | (17<<8)).    SQLITE_IOERR_SHMOPEN            := (SQLITE_IOERR | (18<<8)).    SQLITE_IOERR_SHMSIZE            := (SQLITE_IOERR | (19<<8)).    SQLITE_IOERR_SHMLOCK            := (SQLITE_IOERR | (20<<8)).    SQLITE_IOERR_SHMMAP             := (SQLITE_IOERR | (21<<8)).    SQLITE_IOERR_SEEK               := (SQLITE_IOERR | (22<<8)).    SQLITE_IOERR_DELETE_NOENT       := (SQLITE_IOERR | (23<<8)).    SQLITE_IOERR_MMAP               := (SQLITE_IOERR | (24<<8)).    SQLITE_IOERR_GETTEMPPATH        := (SQLITE_IOERR | (25<<8)).    SQLITE_IOERR_CONVPATH           := (SQLITE_IOERR | (26<<8)).    SQLITE_IOERR_VNODE              := (SQLITE_IOERR | (27<<8)).    SQLITE_IOERR_AUTH               := (SQLITE_IOERR | (28<<8)).    SQLITE_IOERR_BEGIN_ATOMIC       := (SQLITE_IOERR | (29<<8)).    SQLITE_IOERR_COMMIT_ATOMIC      := (SQLITE_IOERR | (30<<8)).    SQLITE_IOERR_ROLLBACK_ATOMIC    := (SQLITE_IOERR | (31<<8)).    SQLITE_LOCKED_SHAREDCACHE       := (SQLITE_LOCKED |  (1<<8)).    SQLITE_LOCKED_VTAB              := (SQLITE_LOCKED |  (2<<8)).    SQLITE_BUSY_RECOVERY            := (SQLITE_BUSY   |  (1<<8)).    SQLITE_BUSY_SNAPSHOT            := (SQLITE_BUSY   |  (2<<8)).    SQLITE_CANTOPEN_NOTEMPDIR       := (SQLITE_CANTOPEN | (1<<8)).    SQLITE_CANTOPEN_ISDIR           := (SQLITE_CANTOPEN | (2<<8)).    SQLITE_CANTOPEN_FULLPATH        := (SQLITE_CANTOPEN | (3<<8)).    SQLITE_CANTOPEN_CONVPATH        := (SQLITE_CANTOPEN | (4<<8)).    SQLITE_CANTOPEN_DIRTYWAL        := (SQLITE_CANTOPEN | (5<<8)). "Not Used"    SQLITE_CORRUPT_VTAB             := (SQLITE_CORRUPT | (1<<8)).    SQLITE_CORRUPT_SEQUENCE         := (SQLITE_CORRUPT | (2<<8)).    SQLITE_READONLY_RECOVERY        := (SQLITE_READONLY | (1<<8)).    SQLITE_READONLY_CANTLOCK        := (SQLITE_READONLY | (2<<8)).    SQLITE_READONLY_ROLLBACK        := (SQLITE_READONLY | (3<<8)).    SQLITE_READONLY_DBMOVED         := (SQLITE_READONLY | (4<<8)).    SQLITE_READONLY_CANTINIT        := (SQLITE_READONLY | (5<<8)).    SQLITE_READONLY_DIRECTORY       := (SQLITE_READONLY | (6<<8)).    SQLITE_ABORT_ROLLBACK           := (SQLITE_ABORT | (2<<8)).    SQLITE_CONSTRAINT_CHECK         := (SQLITE_CONSTRAINT | (1<<8)).    SQLITE_CONSTRAINT_COMMITHOOK    := (SQLITE_CONSTRAINT | (2<<8)).    SQLITE_CONSTRAINT_FOREIGNKEY    := (SQLITE_CONSTRAINT | (3<<8)).    SQLITE_CONSTRAINT_FUNCTION      := (SQLITE_CONSTRAINT | (4<<8)).    SQLITE_CONSTRAINT_NOTNULL       := (SQLITE_CONSTRAINT | (5<<8)).    SQLITE_CONSTRAINT_PRIMARYKEY    := (SQLITE_CONSTRAINT | (6<<8)).    SQLITE_CONSTRAINT_TRIGGER       := (SQLITE_CONSTRAINT | (7<<8)).    SQLITE_CONSTRAINT_UNIQUE        := (SQLITE_CONSTRAINT | (8<<8)).    SQLITE_CONSTRAINT_VTAB          := (SQLITE_CONSTRAINT | (9<<8)).    SQLITE_CONSTRAINT_ROWID         := (SQLITE_CONSTRAINT |(10<<8)).    SQLITE_NOTICE_RECOVER_WAL       := (SQLITE_NOTICE | (1<<8)).    SQLITE_NOTICE_RECOVER_ROLLBACK  := (SQLITE_NOTICE | (2<<8)).    SQLITE_WARNING_AUTOINDEX        := (SQLITE_WARNING | (1<<8)).    SQLITE_AUTH_USER                := (SQLITE_AUTH | (1<<8)).    SQLITE_OK_LOAD_PERMANENTLY      := (SQLITE_OK | (1<<8))! !!SQLite3Constants class methodsFor: 'private - initialization constants' stamp: '3/1/2025 19:01'!initFileOpenFlags	SQLITE_OPEN_READONLY      	  := Integer readFrom: '00000001' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_READWRITE         := Integer readFrom: '00000002' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_CREATE            := Integer readFrom: '00000004' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_DELETEONCLOSE     := Integer readFrom: '00000008' base: 16.  " VFS only "	SQLITE_OPEN_EXCLUSIVE         := Integer readFrom: '00000010' base: 16.  " VFS only "	SQLITE_OPEN_AUTOPROXY         := Integer readFrom: '00000020' base: 16.  " VFS only "	SQLITE_OPEN_URI               := Integer readFrom: '00000040' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_MEMORY            := Integer readFrom: '00000080' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_MAIN_DB           := Integer readFrom: '00000100' base: 16.  " VFS only "	SQLITE_OPEN_TEMP_DB           := Integer readFrom: '00000200' base: 16.  " VFS only "	SQLITE_OPEN_TRANSIENT_DB      := Integer readFrom: '00000400' base: 16.  " VFS only "	SQLITE_OPEN_MAIN_JOURNAL      := Integer readFrom: '00000800' base: 16.  " VFS only "	SQLITE_OPEN_TEMP_JOURNAL      := Integer readFrom: '00001000' base: 16.  " VFS only "	SQLITE_OPEN_SUBJOURNAL        := Integer readFrom: '00002000' base: 16.  " VFS only "	SQLITE_OPEN_MASTER_JOURNAL    := Integer readFrom: '00004000' base: 16.  " VFS only "	SQLITE_OPEN_NOMUTEX           := Integer readFrom: '00008000' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_FULLMUTEX         := Integer readFrom: '00010000' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_SHAREDCACHE       := Integer readFrom: '00020000' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_PRIVATECACHE      := Integer readFrom: '00040000' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_WAL               := Integer readFrom: '00080000' base: 16.  " VFS only "! !!SQLite3Constants class methodsFor: 'private - initialization constants' stamp: '3/1/2025 19:01'!initResultCodes	SQLITE_OK := 0.		 			"Successful result"	SQLITE_ROW := 100.				"sqlite3_step() has another row ready"	SQLITE_DONE := 101 			"sqlite3_step() has finished executing"! !!SQLite3Constants class methodsFor: 'initialization' stamp: '3/1/2025 19:01'!initialize	self		initConstants;		initDataTypes;		initCheckpointModes! !!SQLite3Cursor class methodsFor: 'instance creation' stamp: '3/1/2025 19:01'!on: aStatement	^(self new) statement: aStatement; yourself! !!SQLite3Cursor methodsFor: 'accessing' stamp: '3/1/2025 19:01'!changes	^statement changes! !!SQLite3Cursor methodsFor: 'API' stamp: '3/1/2025 19:01'!close	" closing a cursor is not the same as closing the statement - we may reuse a prepared statement"	statement ifNotNil: [ statement reset ].	statement := nil.	mutators := nil! !!SQLite3Cursor methodsFor: 'accessing' stamp: '3/1/2025 19:01'!columnNames	^ statement ifNotNil: [ statement columnNames ] ifNil: [ #() ]! !!SQLite3Cursor methodsFor: 'accessing' stamp: '3/1/2025 19:01'!connection	^statement connection! !!SQLite3Cursor methodsFor: 'enumerating' stamp: '3/1/2025 19:01'!do: aBlock	"Evaluate aBlock with each of the receiver's rows as the argument."	| eachRow |	[ (eachRow := self next) isNotNil ] whileTrue: [		aBlock value: eachRow ]! !!SQLite3Cursor methodsFor: 'API' stamp: '3/1/2025 19:01'!finalizeStatement	statement finalize! !!SQLite3Cursor methodsFor: 'initialization' stamp: '3/1/2025 19:01'!initialize	"Initializes the receiver"	super initialize.	moreRows := true.	rowClass := SQLite3Row! !!SQLite3Cursor methodsFor: 'accessing' stamp: '3/1/2025 19:01'!mutators	^ mutators		ifNil: [ mutators := self columnNames				collect: [ :c |					(((c substrings: ' _-()') collect: [ :ea | ea capitalized ])						joinUsing: '') uncapitalized asSymbol asMutator ] ]! !!SQLite3Cursor methodsFor: 'API' stamp: '3/1/2025 19:01'!next	^ self nextOfClass: self rowClass! !!SQLite3Cursor methodsFor: 'API' stamp: '3/1/2025 19:01'!nextOfClass: aRowClass	| rr |	moreRows ifFalse: [ ^nil ].	statement		ifNil: [ SQLite3Misuse				signal: 'This result set does not contain a prepared statement.' ].	moreRows		ifTrue: [			rr := aRowClass new.			(rr respondsTo: #columnNames:)				ifTrue: [ "generic row class"					rr columnNames: self columnNames.					1 to: statement dataValuesAvailable do: [ :c | rr at: c put: (statement valueOfColumn: c - 1) ].					 ]				ifFalse: [ | msgs |					"custom object"					msgs := self mutators.					1 to: msgs size do: [ :c |						(rr respondsTo: (msgs at: c))							ifTrue: [ rr perform: (msgs at: c) with: (statement valueOfColumn: c - 1) ] ]						].			moreRows := statement step = SQLITE_ROW.			moreRows ifFalse: [ self close ].			^ rr ].	^ nil! !!SQLite3Cursor methodsFor: 'API' stamp: '3/1/2025 19:01'!onlyRow	^ self onlyRow: [ ]"For the common case where there is exactly one row expected. Returns nil if there is no row."! !!SQLite3Cursor methodsFor: 'API' stamp: '3/1/2025 19:01'!onlyRow: ifNoneBlock	^self rows		ifEmpty: [ ifNoneBlock value ]		ifNotEmpty: [ rows first ]."For the common case where there is exactly one row expected. Returns the evaluation of ifNoneBlock if there is no row."! !!SQLite3Cursor methodsFor: 'API' stamp: '3/1/2025 19:01'!onlyValue	^(self onlyRow: []) ifNotNil: [ :r | r first ]! !!SQLite3Cursor methodsFor: 'accessing' stamp: '3/1/2025 19:01'!rowClass	^ rowClass! !!SQLite3Cursor methodsFor: 'accessing' stamp: '3/1/2025 19:01'!rowClass: anObject	rowClass := anObject! !!SQLite3Cursor methodsFor: 'API' stamp: '3/1/2025 19:01'!rows	^ self rowsOfClass: self rowClass! !!SQLite3Cursor methodsFor: 'API' stamp: '3/1/2025 19:01'!rowsOfClass: aRowClass	rows ifNil: [ rows := OrderedCollection new ].	[ moreRows ] whileTrue: [			rows add: (self nextOfClass: aRowClass) ].	^ rows! !!SQLite3Cursor methodsFor: 'accessing' stamp: '3/1/2025 19:01'!statement	^ statement! !!SQLite3Cursor methodsFor: 'accessing' stamp: '3/1/2025 19:01'!statement: anObject	statement := anObject.	moreRows := (statement ifNil:[false ] ifNotNil: [ statement dataValuesAvailable > 0 ])! !!SQLite3Library class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!booleanSQLFalseWords	^ #('false' 'f')! !!SQLite3Library class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!booleanSQLTrueWords	^ #('true' 't')! !!SQLite3Library class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!booleanTypes	^ #('boolean' 'bool')! !!SQLite3Library class methodsFor: 'factory' stamp: '3/1/2025 19:01'!current	^self uniqueInstance! !!SQLite3Library class methodsFor: 'unified FFI - binding' stamp: '3/1/2025 19:01'!ffiBindingOf: aTypeName	^ TypeMap at: aTypeName ifAbsent: [ super ffiBindingOf: aTypeName ]! !!SQLite3Library class methodsFor: 'class initialization' stamp: '3/1/2025 19:01'!initialize	self		initializeTypeMap;		initializeDataTypeMap;		initializeDateTimeTypeMap! !!SQLite3Library class methodsFor: 'private - initialization' stamp: '3/1/2025 19:01'!initializeDataTypeMap	DataTypeMap := Dictionary newFromPairs: #(		1			#integerAt:		2			#floatAt:		3			#stringAt:		4			#byteArrayAt:		5			#nilAt:	)! !!SQLite3Library class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!initializeDateTimeTypeMap	DateTimeTypeMap := {		'datetime' -> #dateTimeAt:.		'date' -> #dateAt:.		'timestamp' -> #timestampAt:.		'time' -> #timeAt: } asDictionary! !!SQLite3Library class methodsFor: 'private - initialization' stamp: '3/1/2025 19:01'!initializeTypeMap	TypeMap := Dictionary newFromPairs: #(		sqlite3		      #SQLite3DatabaseExternalObject		sqlite3_stmt			#SQLite3StatementExternalObject		sqlite3_backup		#NBSQLite3BackupExternalObject		"sqlite3_blob			NBSQLite3BlobExternalObject "		sqlite3_int64		FFIInt64	)! !!SQLite3Library class methodsFor: 'factory' stamp: '3/1/2025 19:01'!reset	uniqueInstance := nil! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiBackupFinish: backupHandle	"int sqlite3_backup_finish(sqlite3_backup *p)"	^ self ffiCall: #(int sqlite3_backup_finish(SQLite3BackupExternalReference *backupHandle))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiBackupPageCount: backupHandle	"int sqlite3_backup_pagecount(sqlite3_backup *p)"	^ self ffiCall: #(int sqlite3_backup_pagecount(sqlite3_backup *backupHandle))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiBackupRemaining: backupHandle	"int sqlite3_backup_remaining(sqlite3_backup *p)"	^ self ffiCall: #(int sqlite3_backup_remaining(sqlite3_backup *backupHandle))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiBackupStep:nPage via: backupHandle	"int sqlite3_backup_step(sqlite3_backup *p, int nPage)"	^ self ffiCall: #(int sqlite3_backup_step(SQLite3BackupExternalReference *backupHandle, int nPage))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiBackupTo: pDest named: zDestName from: pSource named: zSourceName	"sqlite3_backup *sqlite3_backup_init(  sqlite3 *pDest,                        /* Destination database handle */  const char *zDestName,                 /* Destination database name */  sqlite3 *pSource,                      /* Source database handle */  const char *zSourceName                /* Source database name */)"	^ self ffiCall: #(SQLite3BackupExternalReference *sqlite3_backup_init(  sqlite3 *pDest, String zDestName, sqlite3 *pSource, String zSourceName))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiBindBlob: aStatement atColumn: aColumn with: aByteArray with: anInteger with: aPointer	"int sqlite3_bind_blob(sqlite3_stmt*, int, const void *, int, void(*)(void*))"	^ self ffiCall: #(int sqlite3_bind_blob (sqlite3_stmt* aStatement, int aColumn, void* aByteArray, int anInteger, int aPointer)) "SQLITE_TRANSIENT"! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiBindDouble: aStatement atColumn: aColumn with: aFloat	"int sqlite3_bind_double(sqlite3_stmt*, int, double)"	^ self ffiCall: #(int sqlite3_bind_double (sqlite3_stmt* aStatement, int aColumn, double aFloat))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiBindInteger: aStatement atColumn: aColumn with: anInteger	"int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite_int64)"	^ self		ffiCall: #(int sqlite3_bind_int64 (sqlite3_stmt* aStatement,int aColumn,sqlite3_int64 anInteger))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiBindNull: aStatement atColumn: aColumn	"int sqlite3_bind_null(sqlite3_stmt*, int)"	^ self ffiCall: #(int sqlite3_bind_null (sqlite3_stmt* aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiBindParameterCount: aStatement	"int sqlite3_bind_parameter_count(sqlite3_stmt*)"	^ self ffiCall: #(int sqlite3_bind_parameter_count (sqlite3_stmt* aStatement))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiBindParameterIndex: aStatement for: aName	"int sqlite3_bind_parameter_index(sqlite3_stmt*, const char* zName)"	^ self ffiCall: #(int sqlite3_bind_parameter_index (sqlite3_stmt* aStatement, String aName))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiBindText: aStatement atColumn: aColumn with: aString with: anInteger with: anotherInteger	"int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int, void(*)(void*))"	^ self ffiCall: #(int sqlite3_bind_text (sqlite3_stmt* aStatement, int aColumn, String aString, int anInteger, int anotherInteger))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiChanges: handle	"int sqlite3_changes(sqlite3*)"	^ self ffiCall: #(int sqlite3_changes (sqlite3 *handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiClearBindings: aStatement	"int sqlite3_clear_bindings(sqlite3_stmt*)"	^ self ffiCall: #(int sqlite3_clear_bindings (sqlite3_stmt* aStatement))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiClose: handle	"int sqlite3_close_v2(sqlite3*)"	^self ffiCall: #(int sqlite3_close_v2(sqlite3 *handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiColumnBlob: aStatement atColumn: aColumn	"const void *sqlite3_column_blob(sqlite3_stmt*, int)"	^ self ffiCall: #(const void *sqlite3_column_blob (sqlite3_stmt* aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiColumnBytes: aStatement atColumn: aColumn	"int sqlite3_column_bytes(sqlite3_stmt*, int)"	^ self ffiCall: #(int sqlite3_column_bytes (sqlite3_stmt* aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiColumnCount: aStatement	"int sqlite3_column_count(sqlite3_stmt *pStmt)"	^ self ffiCall: #(int sqlite3_column_count(sqlite3_stmt *aStatement))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiColumnDeclaredType: aStatement atColumn: aColumn	"const char *sqlite3_column_decltype(sqlite3_stmt*, int)"	^ self		ffiCall: #(String sqlite3_column_decltype #(sqlite3_stmt *aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiColumnDouble: aStatement atColumn: aColumn	"double sqlite3_column_double(sqlite3_stmt*, int)"	^ self ffiCall: #(double sqlite3_column_double (sqlite3_stmt* aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiColumnInt: aStatement atColumn: aColumn	"int sqlite3_column_int(sqlite3_stmt*, int)"	^ self ffiCall: #(sqlite3_int64 sqlite3_column_int64 (sqlite3_stmt* aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiColumnName: aStatement atColumn: aColumn	"const char *sqlite3_column_name(sqlite3_stmt*, int)"	^ self		ffiCall: #(String sqlite3_column_name(sqlite3_stmt* aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiColumnText: aStatement atColumn: aColumn	"const unsigned char *sqlite3_column_text(sqlite3_stmt*, int)"	^ self ffiCall: #(String sqlite3_column_text (sqlite3_stmt* aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiColumnType: aStatement atColumn: aColumn	"int sqlite3_column_type(sqlite3_stmt*, int)"	^ self		ffiCall: #(int sqlite3_column_type(sqlite3_stmt* aStatement,int aColumn))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiConfigLoadExtension: dbHandle with: op with: onoff with: retpointer	"This is a specific invocation of sqlite3_db_config(sqlite3*, int, ...)."	^self ffiCall: #(int sqlite3_db_config (sqlite3 *dbHandle, int op, int onoff, int *retpointer))"Notes from https://www.sqlite.org/c3ref/c_dbconfig_enable_fkey.html:op == SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSIONThis option is used to enable or disable the sqlite3_load_extension() interface independently of the load_extension() SQL function. The sqlite3_enable_load_extension() API enables or disables both the C-API sqlite3_load_extension() and the SQL function load_extension(). There should be two additional arguments. When the first argument to this interface is 1, then only the C-API is enabled and the SQL function remains disabled. If the first argument to this interface is 0, then both the C-API and the SQL function are disabled. If the first argument is -1, then no changes are made to state of either the C-API or the SQL function. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether sqlite3_load_extension() interface is disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the new setting is not reported back."! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiDBHandle: statementHandle	"sqlite3 *sqlite3_db_handle(sqlite3_stmt*);"	^self ffiCall: #(SQLite3DatabaseExternalObject *sqlite3_db_handle(SQLite3StatementExternalObject *statementHandle))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiDataCount: handle	"int sqlite3_data_count(sqlite3_stmt*)"	^ self ffiCall: #(int sqlite3_data_count (sqlite3_stmt *handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiErrorMessage: handle	"const char *sqlite3_errmsg(sqlite3*)"	^self ffiCall: #(String sqlite3_errmsg(sqlite3 *handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiExec: dbHandle withSQLText: anSQLText with: callback with: callbackData with: errorMessageBuffer	"int sqlite3_exec(sqlite3*, const char*, int (*callback), void*, char **)"	^self ffiCall: #(int sqlite3_exec (sqlite3 *dbHandle, String anSQLText, void *callback, void *callbackData, char **errorMessageBuffer))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiFinalize: handle	"int sqlite3_finalize(sqlite3_stmt*)"	^self ffiCall: #(int sqlite3_finalize(sqlite3_stmt *handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiGetAutocommit: handle	"int sqlite3_get_autocommit(sqlite3*);"	^ self ffiCall: #(int sqlite3_get_autocommit (sqlite3 *handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiLastInsertRowid: handle	"sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*)"	^ self ffiCall: #(long sqlite3_last_insert_rowid(SQLite3DatabaseExternalObject *handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiLibVersion	"const char *sqlite3_libversion(void)"	^self ffiCall: #(String sqlite3_libversion(void))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiLoadExtension: dbHandle with: zFile with: zProc with: pzErrMsg	"int sqlite3_load_extension(sqlite3*, const char*, const char*, char **)."	^self ffiCall: #(int sqlite3_load_extension (sqlite3 *dbHandle, String zFile, const char *zProc, char **pzErrMsg))		module: self library! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiOpen: filename via: handle	"int sqlite3_open(const char*, sqlite3**)"	^self ffiCall: #(int sqlite3_open(String filename, sqlite3 **handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiOpen: filename withFlags: flags vfs: vfs via: handle	"int sqlite3_open_v2(  const char *filename,   /* Database filename (UTF-8) */  sqlite3 **ppDb,         /* OUT: SQLite db handle */  int flags,              /* Flags */  const char *zVfs        /* Name of VFS module to use */)"	^self ffiCall: #(int sqlite3_open_v2(String filename, sqlite3 **handle, int flags, String vfs))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiPrepare: dbHandle withSQLText: anSQLText with: textSize with: sHandle with: tail	"int sqlite3_prepare_v2(sqlite3*, const char*, int, sqlite3_stmt**, const char **)"	^ self ffiCall: #(int sqlite3_prepare_v2 (sqlite3* dbHandle, String anSQLText, int textSize, sqlite3_stmt** sHandle, const char** tail))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiReset: handle	"int sqlite3_reset(sqlite3_stmt*)"	^ self ffiCall: #(int sqlite3_reset (sqlite3_stmt *handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiSleep	"int sqlite3_sleep(int)"	^ self ffiCall: #(int sqlite3_sleep(int))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiSql: handle	"const char *sqlite3_sql(sqlite3_stmt*)"	^ self ffiCall: #(String sqlite3_sql (sqlite3_stmt* handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiStatementReadOnly: handle	"int sqlite3_stmt_readonly(sqlite3_stmt *pStmt)"	^ self ffiCall: #(int sqlite3_stmt_readonly (SQLite3StatementExternalObject * handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiStep: handle	"int sqlite3_step(sqlite3_stmt*)"	^ self ffiCall: #(int sqlite3_step (sqlite3_stmt* handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiThreadsafe	"int sqlite3_threadsafe(void)"	^self ffiCall: #(int sqlite3_threadsafe(void))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiTotalChanges: handle	"int sqlite3_total_changes(sqlite3*)"	^ self ffiCall: #(int sqlite3_total_changes (sqlite3 *handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!apiTrace: handle with: callback with: appdata	^ self ffiCall: #(void* sqlite3_trace (sqlite3* handle, FFICallback callback, ExternalAddress appdata))! !!SQLite3Library methodsFor: 'operating' stamp: '3/1/2025 19:01'!backup: backupHandle step: nPages	^self apiBackupStep: nPages via: backupHandle! !!SQLite3Library methodsFor: 'operating' stamp: '3/1/2025 19:01'!backupTo: dstConnection named: dstName from: srcConnection named: srcName	^self apiBackupTo: dstConnection named: dstName from: srcConnection named: srcName! !!SQLite3Library methodsFor: 'operating' stamp: '3/1/2025 19:01'!bindParameterCount: aStatementHandle	^ self apiBindParameterCount: aStatementHandle! !!SQLite3Library methodsFor: 'operating' stamp: '3/1/2025 19:01'!bindParameterIndex: aStatementHandle for: aName	^ self apiBindParameterIndex: aStatementHandle for: aName! !!SQLite3Library methodsFor: 'accessing' stamp: '3/1/2025 19:01'!blobFrom: aStatement at: aColumn	| address size array |	address := self apiColumnBlob: aStatement atColumn: aColumn.	size := self apiColumnBytes: aStatement atColumn: aColumn.	array := address copyFrom: 1 to: size.	^array! !!SQLite3Library methodsFor: 'accessing' stamp: '3/1/2025 19:01'!booleanFrom: aStatement at: aColumn	| declared selector value |	declared := self apiColumnDeclaredType: aStatement atColumn: aColumn.	(self class booleanTypes includes: declared asLowercase) ifFalse: [		SQLite3AbstractError signal: 'Column is not declared as a boolean.' ].	selector := DataTypeMap at: (self apiColumnType: aStatement atColumn: aColumn).	(selector = #nilAt:) ifTrue: [ ^ nil ].	(selector = #stringAt:)		ifTrue: [			value := self apiColumnText: aStatement atColumn: aColumn.			(self class booleanSQLTrueWords includes: value asLowercase)				ifTrue: [ ^ true ]				ifFalse: [					(self class booleanSQLFalseWords includes: value asLowercase)						ifTrue: [ ^ false ]						ifFalse: [ SQLite3AbstractError signal: 'Column value cannot be read as a boolean.' ]]].	(selector = #integerAt:)		ifTrue: [			value := self apiColumnInt: aStatement atColumn: aColumn.			(value = 1)				ifTrue: [ ^ true ]				ifFalse: [					(value = 0)						ifTrue: [ ^ false ]						ifFalse: [ SQLite3AbstractError signal: 'Column value cannot be read as a boolean.' ]]]! !!SQLite3Library methodsFor: 'introspection' stamp: '3/1/2025 19:01'!changes: aHandle	^ self apiChanges: aHandle! !!SQLite3Library methodsFor: 'private - utilities' stamp: '3/1/2025 19:01'!checkForOk: anInteger on: aHandle	^ self sqlite3ResultFor: anInteger ifNoneMatch: [		 (SQLite3NativeError forNativeErrorCode: anInteger messageText: (self apiErrorMessage: aHandle)) signal ]! !!SQLite3Library methodsFor: 'cleaning' stamp: '3/1/2025 19:01'!clearBindings: sHandle on: dbHandle	^ self checkForOk: (self apiClearBindings: sHandle) on: dbHandle! !!SQLite3Library methodsFor: 'connection handling' stamp: '3/1/2025 19:01'!close: aHandle	^ self apiClose: aHandle! !!SQLite3Library methodsFor: 'connection handling' stamp: '3/1/2025 19:01'!columnCount: aStatementHandle	^ self apiColumnCount: aStatementHandle! !!SQLite3Library methodsFor: 'accessing' stamp: '3/1/2025 19:01'!dataValuesAvailable: aStatementHandle	^ self apiDataCount: aStatementHandle! !!SQLite3Library methodsFor: 'connection handling' stamp: '3/1/2025 19:01'!dbHandle: statementHandle	^self apiDBHandle: statementHandle! !!SQLite3Library methodsFor: 'configuring' stamp: '3/1/2025 19:01'!disableLoadExtension: aHandle	^ self checkForOk: (self apiConfigLoadExtension: aHandle with: 1005 with: 0 with: ExternalAddress new)		on: aHandle"Magic number 1005 = SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION.See comment in #apiConfigLoadExtension:with:with:with:."! !!SQLite3Library methodsFor: 'configuring' stamp: '3/1/2025 19:01'!enableLoadExtension: aHandle	^ self checkForOk: (self apiConfigLoadExtension: aHandle with: 1005 with: 1 with: ExternalAddress new)		on: aHandle"Magic number 1005 = SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION.See comment in #apiConfigLoadExtension:with:with:with:."! !!SQLite3Library methodsFor: 'operating' stamp: '3/1/2025 19:01'!execute: anSQLText on: aDBHandle	| null |	null := ExternalAddress new.	^ self checkForOk: (self apiExec: aDBHandle							withSQLText: anSQLText							with: null							with: null							with: null)		 on: aDBHandle! !!SQLite3Library methodsFor: 'operating' stamp: '3/1/2025 19:01'!finalize: aStatementHandle on: aDBHandle	| result |	result := self checkForOk: (self apiFinalize: aStatementHandle) on: aDBHandle.	aStatementHandle beNull.	^ result! !!SQLite3Library methodsFor: 'accessing' stamp: '3/1/2025 19:01'!floatFrom: aStatement at: aColumn	^ self apiColumnDouble: aStatement atColumn: aColumn! !!SQLite3Library methodsFor: 'accessing' stamp: '3/1/2025 19:01'!getAutoCommit: aHandle	^ (self apiGetAutocommit: aHandle) ~= 0! !!SQLite3Library methodsFor: 'operating' stamp: '3/1/2025 19:01'!integerFrom: aStatement at: aColumn	^ self apiColumnInt: aStatement atColumn: aColumn! !!SQLite3Library methodsFor: 'testing' stamp: '3/1/2025 19:01'!isThreadsafe	"http://sqlite.org/c3ref/threadsafe.html"	^ self apiThreadsafe! !!SQLite3Library methodsFor: 'accessing' stamp: '3/1/2025 19:01'!lastInsertRowId: dbHandle	^ self apiLastInsertRowid: dbHandle! !!SQLite3Library methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!library	^self libraryName! !!SQLite3Library methodsFor: 'accessing' stamp: '3/1/2025 19:01'!libraryVersion	"See http://sqlite.org/c3ref/libversion.html"	^self apiLibVersion! !!SQLite3Library methodsFor: 'private - api' stamp: '3/1/2025 19:01'!loadExtension: dbHandle with: aFilename	^ self checkForOk: (self apiLoadExtension: dbHandle										with: aFilename										with: ExternalAddress new										with: ExternalAddress new)		on: dbHandle! !!SQLite3Library methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!macLibraryName	| pluginDir |	pluginDir := FileSystem /'usr'/'lib'.	#('libsqlite3.dylib' 'libsqlite3.0.dylib' 'sqlite3/libtclsqlite3.dylib')		detect: [ :each | (pluginDir / each) exists ]		ifFound: [ :libName | ^ (pluginDir / libName) fullName  ].	self error: 'Module not found.'! !!SQLite3Library methodsFor: 'accessing' stamp: '3/1/2025 19:01'!nameFor: aStatement at: aColumn	^ self apiColumnName: aStatement atColumn: aColumn! !!SQLite3Library methodsFor: 'connection handling' stamp: '3/1/2025 19:01'!open: aFilename via: aHandle	^ self checkForOk: (self apiOpen: aFilename via: aHandle) on: aHandle! !!SQLite3Library methodsFor: 'accessing' stamp: '3/1/2025 19:01'!open: aFilename withFlags: flags vfs: vfs via: aHandle	^ self checkForOk: (self apiOpen: aFilename withFlags: flags vfs: vfs via: aHandle) on: aHandle! !!SQLite3Library methodsFor: 'accessing' stamp: '3/1/2025 19:01'!open: aFilename withFlags: flags via: aHandle	^ self checkForOk: (self apiOpen: aFilename withFlags: flags vfs: nil via: aHandle) on: aHandle! !!SQLite3Library methodsFor: 'private - conversion' stamp: '3/1/2025 19:01'!pharoStringToUTF8: aPharoString	"Converts from Pharo Multibyte Characters to SQLite3 UTF-8 storage format"	^ZnUTF8Encoder new encodeString: aPharoString! !!SQLite3Library methodsFor: 'operating' stamp: '3/1/2025 19:01'!prepare: aStatementHandle on: aDBHandle with: anSQLText	| utf8SQL |	utf8SQL := self pharoStringToUTF8: anSQLText.	^ self checkForOk: (self apiPrepare: aDBHandle							withSQLText: utf8SQL							with: utf8SQL size							with: aStatementHandle							with: (ExternalAddress new))		 on: aDBHandle! !!SQLite3Library methodsFor: 'cleaning' stamp: '3/1/2025 19:01'!reset: aStatementHandle	^ aStatementHandle		ifNil: [ 0 ]		ifNotNil: [ self apiReset: aStatementHandle ]! !!SQLite3Library methodsFor: 'private - utilities' stamp: '3/1/2025 19:01'!signal: exceptionClass with: value on: handle	(exceptionClass new)		resultCode: value;		signal: (self apiErrorMessage: handle)! !!SQLite3Library methodsFor: 'stepping' stamp: '3/1/2025 19:01'!sqlText: aStatementHandle	^ self apiSql: aStatementHandle! !!SQLite3Library methodsFor: 'private - utilities' stamp: '3/1/2025 19:01'!sqlite3ResultFor: anInteger ifNoneMatch: aBlock	^[		SQLite3Result forNativeResultCode: anInteger	] on: NotFound do: aBlock! !!SQLite3Library methodsFor: 'stepping' stamp: '3/1/2025 19:01'!statementReadOnly: handle	"int sqlite3_stmt_readonly(sqlite3_stmt *pStmt)"	^ (self apiStatementReadOnly: handle) ~= 0! !!SQLite3Library methodsFor: 'stepping' stamp: '3/1/2025 19:01'!step: aStatementHandle	^ self apiStep: aStatementHandle! !!SQLite3Library methodsFor: 'testing' stamp: '3/1/2025 19:01'!threadsafe	"This method is deprecated so consider to migrate."	self deprecated:  'Please use #isThreadsafe instead' transformWith:  '`@receiver threadsafe'						-> '`@receiver isThreadsafe'.	^ self isThreadsafe! !!SQLite3Library methodsFor: 'introspection' stamp: '3/1/2025 19:01'!totalChanges: aHandle	^ self apiTotalChanges: aHandle! !!SQLite3Library methodsFor: 'tracing' stamp: '3/1/2025 19:01'!trace: handle with: callback with: appdata	^ self apiTrace: handle with: callback with: appdata! !!SQLite3Library methodsFor: 'private - utilities' stamp: '3/1/2025 19:01'!typeFor: aStatement at: aColumn	| selector declared |	declared := self apiColumnDeclaredType: aStatement atColumn: aColumn.	declared ifNotNil: [ "Handle column type of boolean as a special case."		(self class booleanTypes includes: declared) ifTrue: [ ^ #booleanAt: ] ].	selector := DataTypeMap at: (self apiColumnType: aStatement atColumn: aColumn).	selector = #stringAt: ifTrue: [		declared ifNotNil: [ "Handle column type of date/time as a special case."			^ DateTimeTypeMap at: declared asLowercase ifAbsent: [ selector ] ] ].	^ selector! !!SQLite3Library methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!unix32LibraryName	(#('/usr/lib/i386-linux-gnu' '/usr/lib32' '/usr/lib'),			((OSEnvironment current at: 'LD_LIBRARY_PATH' ifAbsent: [ '' ]) substrings: ':'))		do: [ :path |			#('libsqlite3.so.0' 'libsqlite3.so') do: [ :libraryName |			| libraryPath |			libraryPath := path asFileReference / libraryName.			libraryPath exists				ifTrue: [ ^ libraryPath fullName ] ] ].	self error: 'Module not found.'! !!SQLite3Library methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!unix64LibraryName	(#('/usr/lib/x86_64-linux-gnu' '/lib/x86_64-linux-gnu' '/usr/lib'),			((OSEnvironment current at: 'LD_LIBRARY_PATH' ifAbsent: [ '' ]) substrings: ':'))		do: [ :path |			#('libsqlite3.so.0' 'libsqlite3.so') do: [ :libraryName |				| libraryPath |				libraryPath := path asFileReference /  libraryName.				libraryPath exists					ifTrue: [ ^ libraryPath fullName ]]].	self error: 'Module not found.'! !!SQLite3Library methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!win32LibraryName	^ 'sqlite3'! !!SQLite3Library methodsFor: 'operating' stamp: '3/1/2025 19:01'!with: aStatement at: aColumn putBlob: aByteArray	^ self		  apiBindBlob: aStatement		  atColumn: aColumn		  with: aByteArray		  with: aByteArray size		  with: 0! !!SQLite3Library methodsFor: 'operating' stamp: '3/1/2025 19:01'!with: aStatement at: aColumn putFloat: aFloat	^ self apiBindDouble: aStatement atColumn: aColumn with: aFloat! !!SQLite3Library methodsFor: 'operating' stamp: '3/1/2025 19:01'!with: aStatement at: aColumn putInteger: anInteger	^ self apiBindInteger: aStatement atColumn: aColumn with: anInteger! !!SQLite3Library methodsFor: 'operating' stamp: '3/1/2025 19:01'!with: aStatement at: aColumn putText: aString	| bytes |	bytes := self pharoStringToUTF8: aString.	^ self		  apiBindText: aStatement		  atColumn: aColumn		  with: bytes		  with: bytes size		  with: 0! !!SQLite3Library methodsFor: 'operating' stamp: '3/1/2025 19:01'!with: aStatement putNullAt: aColumn	^ self apiBindNull: aStatement atColumn: aColumn! !!SQLite3Abort class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_ABORT! !!SQLite3AbortRollback class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_ABORT_ROLLBACK! !!SQLite3AuthorizationDenied class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_AUTH! !!SQLite3Busy class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_BUSY! !!SQLite3BusyRecovery class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_BUSY_RECOVERY! !!SQLite3BusySnapshot class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_BUSY_SNAPSHOT! !!SQLite3CantOpen class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_CANTOPEN! !!SQLite3CantOpenConvertPath class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_CANTOPEN_CONVPATH! !!SQLite3CantOpenFullPath class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_CANTOPEN_FULLPATH! !!SQLite3CantOpenIsDir class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_CANTOPEN_ISDIR! !!SQLite3CantOpenNoTempDir class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_CANTOPEN_NOTEMPDIR! !!SQLite3ConstraintViolation class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_CONSTRAINT! !!SQLite3ConstraintViolationCheck class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_CONSTRAINT_CHECK! !!SQLite3ConstraintViolationCommitHook class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_CONSTRAINT_COMMITHOOK! !!SQLite3ConstraintViolationForeignKey class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_CONSTRAINT_FOREIGNKEY! !!SQLite3ConstraintViolationFunction class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_CONSTRAINT_FUNCTION! !!SQLite3ConstraintViolationNotNull class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_CONSTRAINT_NOTNULL! !!SQLite3ConstraintViolationPrimaryKey class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_CONSTRAINT_PRIMARYKEY! !!SQLite3ConstraintViolationRowID class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_CONSTRAINT_ROWID! !!SQLite3ConstraintViolationTrigger class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_CONSTRAINT_TRIGGER! !!SQLite3ConstraintViolationUnique class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_CONSTRAINT_UNIQUE! !!SQLite3ConstraintViolationVirtualTable class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_CONSTRAINT_VTAB! !!SQLite3Corrupt class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_CORRUPT! !!SQLite3CorruptVirtualTable class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_CORRUPT_VTAB! !!SQLite3Empty class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_EMPTY! !!SQLite3Error class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_ERROR! !!SQLite3Format class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_FORMAT! !!SQLite3Full class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_FULL! !!SQLite3IOError class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR! !!SQLite3IOErrorAccess class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_ACCESS! !!SQLite3IOErrorBlocked class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_BLOCKED! !!SQLite3IOErrorCheckReservedLock class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_CHECKRESERVEDLOCK! !!SQLite3IOErrorClose class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_CLOSE! !!SQLite3IOErrorConvertPath class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_CONVPATH! !!SQLite3IOErrorDelete class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_DELETE! !!SQLite3IOErrorDeleteNoEntry class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_DELETE_NOENT! !!SQLite3IOErrorDirClose class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_DIR_CLOSE! !!SQLite3IOErrorDirFSync class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_DIR_FSYNC! !!SQLite3IOErrorFStat class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_FSTAT! !!SQLite3IOErrorFSync class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_FSYNC! !!SQLite3IOErrorGetTempPath class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_GETTEMPPATH! !!SQLite3IOErrorLock class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_LOCK! !!SQLite3IOErrorMemoryMap class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_MMAP! !!SQLite3IOErrorNoMemory class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_NOMEM! !!SQLite3IOErrorRead class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_READ! !!SQLite3IOErrorReadLock class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_RDLOCK! !!SQLite3IOErrorSeek class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_SEEK! !!SQLite3IOErrorSharedMemoryError class methodsFor: 'testing' stamp: '3/1/2025 19:01'!isAbstract	^self name = #SQLite3IOErrorSharedMemoryError! !!SQLite3IOErrorSharedMemoryLock class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_SHMLOCK! !!SQLite3IOErrorSharedMemoryMap class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_SHMMAP! !!SQLite3IOErrorSharedMemoryOpen class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_SHMOPEN! !!SQLite3IOErrorSharedMemorySize class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_SHMSIZE! !!SQLite3IOErrorShortRead class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_SHORT_READ! !!SQLite3IOErrorTruncate class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_TRUNCATE! !!SQLite3IOErrorUnlock class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_UNLOCK! !!SQLite3IOErrorWrite class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_IOERR_WRITE! !!SQLite3Internal class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_INTERNAL! !!SQLite3Interrupt class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_INTERRUPT! !!SQLite3Locked class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_LOCKED! !!SQLite3LockedSharedCache class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_LOCKED_SHAREDCACHE! !!SQLite3LogNotice class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_NOTICE! !!SQLite3LogNoticeRecoverRollback class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_NOTICE_RECOVER_ROLLBACK! !!SQLite3LogNoticeRecoverWriteAheadLogging class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_NOTICE_RECOVER_WAL! !!SQLite3LogWarning class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_WARNING! !!SQLite3LogWarningAutoIndex class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_WARNING_AUTOINDEX! !!SQLite3Mismatch class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_MISMATCH! !!SQLite3Misuse class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_MISUSE! !!SQLite3NativeError class methodsFor: 'examples' stamp: '3/1/2025 19:01'!example	(SQLite3NativeError forNativeErrorCode: SQLITE_INTERRUPT  messageText: 'Interrupted') signal! !!SQLite3NativeError class methodsFor: 'accessing' stamp: '3/1/2025 19:01'!forNativeErrorCode: anInteger messageText: aString	^(self subclassForNativeErrorCode: anInteger) new			messageText: aString;			yourself! !!SQLite3NativeError class methodsFor: 'testing' stamp: '3/1/2025 19:01'!isAbstract	^self name = #SQLite3NativeError! !!SQLite3NativeError class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	"Returns the native error code as defined by SQLite C library."	^ self subclassResponsibility! !!SQLite3NativeError class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!subclassForNativeErrorCode: anInteger	^ self subclasses		detect: [ :subclass | subclass nativeErrorCode = anInteger ]! !!SQLite3NoLargeFileSupport class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_NOLFS! !!SQLite3NoMemory class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^SQLITE_NOMEM! !!SQLite3NotADatabase class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_NOTADB! !!SQLite3NotFound class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_NOTFOUND! !!SQLite3OutOfRange class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_RANGE! !!SQLite3Permission class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_PERM! !!SQLite3Protocol class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_PROTOCOL! !!SQLite3ReadOnly class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_READONLY! !!SQLite3ReadOnlyCantLock class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_READONLY_CANTLOCK! !!SQLite3ReadOnlyDBMoved class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_READONLY_DBMOVED! !!SQLite3ReadOnlyRecovery class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_READONLY_RECOVERY! !!SQLite3ReadOnlyRollback class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_READONLY_ROLLBACK! !!SQLite3SchemaChanged class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_SCHEMA! !!SQLite3TooBig class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeErrorCode	^ SQLITE_TOOBIG! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '3/1/2025 19:01'!at: aColumn putBoolean: aBoolean	^ self library		with: handle		at: aColumn		putInteger: (aBoolean ifTrue: [ 1 ] ifFalse: [ 0 ])"See http://www.sqlite.org/datatype3.html."! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '3/1/2025 19:01'!at: aColumn putByteArray: anObject	| byteArray |	byteArray := self bindingAt: anObject ifAbsentPut: [ anObject ].	^ self library with: handle at: aColumn putBlob: byteArray! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '3/1/2025 19:01'!at: aColumn putDate: aDate	| string |	string := self bindingAt: aDate ifAbsentPut: [		          String streamContents: [ :stream |			          BasicDatePrinter new printDate: aDate format: #(  ) on: stream ] ].	^ self library with: handle at: aColumn putText: string! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '3/1/2025 19:01'!at: aColumn putDateTime: aDateTime	| string |	string := self		     bindingAt: aDateTime		     ifAbsentPut: [ String streamContents: [ :stream | aDateTime asDateAndTime printOn: stream ] ].	^ self library with: handle at: aColumn putText: string! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '3/1/2025 19:01'!at: aColumn putFloat: aFloat	| f |	f := (aFloat isKindOf: Fraction)		ifTrue: [ aFloat asFloat ]		ifFalse: [ aFloat ].	^ self library with: handle at: aColumn putFloat: f! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '3/1/2025 19:01'!at: aColumn putInteger: anInteger	^ self library with: handle at: aColumn putInteger: anInteger! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '3/1/2025 19:01'!at: aColumn putNil: anObject	"Goofy interface note - anObject is ignored here."	"When used by SQLite3Connection, anObject will always be nil."	^ self library with: handle putNullAt: aColumn! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '3/1/2025 19:01'!at: aColumn putObject: anObject	| blob |	blob := self bindingAt: anObject ifAbsentPut: [ FLSerializer serializeToByteArray: anObject ].	^ self library		  with: handle		  at: aColumn		  putBlob: blob! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '3/1/2025 19:01'!at: aColumn putString: aString	| s |	s := self bindingAt: aString ifAbsentPut: [ aString ].	^ self library with: handle at: aColumn putText: s! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '3/1/2025 19:01'!at: aColumn putTime: aTime	| string |	string := self		          bindingAt: aTime		          ifAbsentPut: [ String streamContents: [ :stream | aTime printOn: stream ] ].	^ self library with: handle at: aColumn putText: string! !!SQLite3PreparedStatement methodsFor: 'public' stamp: '3/1/2025 19:01'!basicExecute: aBlock	| ret |	ret := self step.	(ret = SQLITE_DONE) " == SQLITE_DONE, meaning step should not be sent again."		ifTrue: [ aBlock value: self ]		ifFalse: [			[ ret = SQLITE_ROW ] whileTrue: [ " == SQLITE_ROW, meaning another row is available."				aBlock value: self.				ret := self step ]]! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '3/1/2025 19:01'!bindParameterCount	^ self library bindParameterCount: handle! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '3/1/2025 19:01'!bindParameterIndex: aName	^ self library bindParameterIndex: handle for: aName! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '3/1/2025 19:01'!bindParameters: parameters	"A 'variable' or 'parameter' token specifies a placeholder in the expression for a value that is filled in at runtime using the sqlite3_bind() family of C/C++ interfaces. Parameters can take several forms:?NNN		A question mark followed by a number NNN holds a spot for the NNN-th parameter. NNN must be between 1 and SQLITE_MAX_VARIABLE_NUMBER.?		A question mark that is not followed by a number creates a parameter with a number one greater than the largest parameter number already assigned. If this means the parameter number is greater than SQLITE_MAX_VARIABLE_NUMBER, it is an error. This parameter format is provided for compatibility with other database engines. But because it is easy to miscount the question marks, the use of this parameter format is discouraged. Programmers are encouraged to use one of the symbolic formats below or the ?NNN format above instead.:AAAA		A colon followed by an identifier name holds a spot for a named parameter with the name :AAAA. Named parameters are also numbered. The number assigned is one greater than the largest parameter number already assigned. If this means the parameter would be assigned a number greater than SQLITE_MAX_VARIABLE_NUMBER, it is an error. To avoid confusion, it is best to avoid mixing named and numbered parameters.@AAAA		An 'at' sign works exactly like a colon, except that the name of the parameter created is @AAAA.$AAAA		A dollar-sign followed by an identifier name also holds a spot for a named parameter with the name $AAAA. The identifier name in this case can include one or more occurrences of '::' and a suffix enclosed in '(...)' containing any text at all. This syntax is the form of a variable name in the Tcl programming language. The presence of this syntax results from the fact that SQLite is really a Tcl extension that has escaped into the wild.Parameters that are not assigned values using sqlite3_bind() are treated as NULL. The sqlite3_bind_parameter_index() interface can be used to translate a symbolic parameter name into its equivalent numeric index."	(parameters isCollection and: [ parameters isString not ]) ifFalse: [		SQLite3AbstractError signal:			'Unable to execute SQL on instance of ' , parameters class asString ].	parameters keysAndValuesDo: [ :k :v |		| idx |		k isInteger			ifTrue: [ idx := k ]			ifFalse: [				idx := self bindParameterIndex: k.				idx = 0 ifTrue: [ idx := self bindParameterIndex: '@' , k ].				idx = 0 ifTrue: [ idx := self bindParameterIndex: ':' , k ].				idx = 0 ifTrue: [ idx := self bindParameterIndex: '$' , k ].				(idx = 0 and: [ k isAllDigits ]) ifTrue: [ idx := k asInteger ] ].		idx > 0 ifTrue: [			self perform: (self dataTypeForObject: v) with: idx with: v ] ]! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '3/1/2025 19:01'!bindingAt: anObject ifAbsentPut: aBlock	^bindings at: anObject ifAbsentPut: aBlock! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '3/1/2025 19:01'!booleanAt: aColumn	^self library booleanFrom: handle at: aColumn! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '3/1/2025 19:01'!byteArrayAt: aColumn	^ self library blobFrom: handle at: aColumn! !!SQLite3PreparedStatement methodsFor: 'public - accessing' stamp: '3/1/2025 19:01'!changes	^changes ifNil: [ changes := 0 ]! !!SQLite3PreparedStatement methodsFor: 'private' stamp: '3/1/2025 19:01'!checkOk: aValue	"These are normal conditions."	aValue = SQLITE_OK ifTrue: [ ^aValue ].	"These are error conditions."	(aValue = SQLITE_BUSY)		ifTrue: [ connection signal: SQLite3Busy with: aValue ].	(aValue = SQLITE_MISUSE)		ifTrue: [ connection signal: SQLite3Misuse with: aValue ].	"Catch any error not specifically handled above."	connection signal: SQLite3AbstractError with: aValue! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '3/1/2025 19:01'!clearBindings	| cleared |	cleared := self library clearBindings: handle on: connection handle.	bindings removeAll.	^cleared! !!SQLite3PreparedStatement methodsFor: 'public' stamp: '3/1/2025 19:01'!columnCount	^self library columnCount: handle! !!SQLite3PreparedStatement methodsFor: 'public - accessing' stamp: '3/1/2025 19:01'!columnNames	^ columnNames ifNil: [		  columnNames := (1 to: self columnCount) collect: [ :c | self nameOfColumn: c - 1 ].		  columnNames ]! !!SQLite3PreparedStatement methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!connection: anObject	connection := anObject! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '3/1/2025 19:01'!dataTypeForObject: anObject	anObject ifNil: [ ^ #at:putNil: ].	( anObject isKindOf: Boolean )		ifTrue: [ ^ #at:putBoolean: ].	( anObject isKindOf: Integer )		ifTrue: [ ^ #at:putInteger: ].	( self isFloatLike: anObject )		ifTrue: [ ^ #at:putFloat: ].	( anObject isKindOf: String )		ifTrue: [ ^ #at:putString: ].	( anObject isKindOf: ByteArray )		ifTrue: [ ^ #at:putByteArray: ].	( anObject isKindOf: DateAndTime )		ifTrue: [ ^ #at:putDateTime: ].	( anObject isKindOf: Time )		ifTrue: [ ^ #at:putTime: ].	( anObject isKindOf: Date )		ifTrue: [ ^ #at:putDate: ].	^ #at:putObject:! !!SQLite3PreparedStatement methodsFor: 'public - accessing' stamp: '3/1/2025 19:01'!dataValuesAvailable	^ self library dataValuesAvailable: handle! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '3/1/2025 19:01'!dateAt: aColumn	^ Date fromString: ( self stringAt: aColumn )! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '3/1/2025 19:01'!dateTimeAt: aColumn	^ DateAndTime fromString: ( self stringAt: aColumn )! !!SQLite3PreparedStatement methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!dbHandle	^(self library dbHandle: handle)! !!SQLite3PreparedStatement methodsFor: 'operating' stamp: '3/1/2025 19:01'!execute: parameters	| result |	self checkOk: self reset.	self clearBindings.	self bindParameters: parameters.	result := self step.	changes := connection changes.	^ SQLite3Cursor on: self! !!SQLite3PreparedStatement methodsFor: 'initialization' stamp: '3/1/2025 19:01'!finalize	"Finalize the statement as required by the SQLite3 API. As per the API, the user is expected to finalize a statement after use.	Since executing a new statement without having finalized the previous one might cause SQLITE_BUSY errors, we can't rely on the garbage collector to execute the finalization, or we'll be exposed to non-deterministic behaviour."	handle		ifNotNil:			[ "Remove the statement object from its finalization registry. This should happen before the actual finalization to avoid finalizing the statement twice, which might result in 'undefined and undesirable behavior such as segfaults and heap corruption' as per the SQLite3 API"			handle manualRelease.			connection finalize: handle.			handle := nil ].	^ 0! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '3/1/2025 19:01'!floatAt: aColumn	^self library floatFrom: handle at: aColumn! !!SQLite3PreparedStatement methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!handle	^ handle! !!SQLite3PreparedStatement methodsFor: 'initialization' stamp: '3/1/2025 19:01'!initialize	super initialize.	bindings := IdentityDictionary new.	handle := SQLite3StatementExternalObject new.	handle autoRelease! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '3/1/2025 19:01'!integerAt: aColumn	^self library integerFrom: handle at: aColumn! !!SQLite3PreparedStatement methodsFor: 'private - testing' stamp: '3/1/2025 19:01'!isFloatLike: anObject	^ (anObject isKindOf: Float) or: [ anObject isKindOf: Fraction ]! !!SQLite3PreparedStatement methodsFor: 'public - accessing' stamp: '3/1/2025 19:01'!isReadOnly	^self library statementReadOnly: handle! !!SQLite3PreparedStatement methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!library	^SQLite3Library current! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '3/1/2025 19:01'!nameOfColumn: aColumn	^ self library nameFor: handle at: aColumn! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '3/1/2025 19:01'!nilAt: aColumn	^ nil! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '3/1/2025 19:01'!objectAt: aColumn	^ FLMaterializer materializeFromByteArray: (self library blobFrom: handle at: aColumn)! !!SQLite3PreparedStatement methodsFor: 'public' stamp: '3/1/2025 19:01'!prepare: anSQLText	self library prepare: handle on: connection handle with: anSQLText! !!SQLite3PreparedStatement methodsFor: 'public' stamp: '3/1/2025 19:01'!reset	^connection reset: self! !!SQLite3PreparedStatement methodsFor: 'operating' stamp: '3/1/2025 19:01'!sqlText	^ self library sqlText: handle! !!SQLite3PreparedStatement methodsFor: 'public' stamp: '3/1/2025 19:01'!step	^ self stepOk: (self library step: handle)! !!SQLite3PreparedStatement methodsFor: 'private' stamp: '3/1/2025 19:01'!stepOk: aValue	"These are normal conditions."	(aValue = SQLITE_ROW or: [aValue = SQLITE_DONE]) ifTrue: [		changes := connection changes.		^aValue  ].	"These are error conditions."	(aValue = SQLITE_BUSY)		ifTrue: [ connection signal: SQLite3Busy with: aValue ].	(aValue = SQLITE_MISUSE)		ifTrue: [ connection signal: SQLite3Misuse with: aValue ].	(aValue = SQLITE_CONSTRAINT)		ifTrue:  [ connection signal: SQLite3ConstraintViolation with: aValue].	"Catch any error not specifically handled above."	connection signal: SQLite3AbstractError with: aValue! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '3/1/2025 19:01'!stringAt: aColumn	"Answer the string from the specified column"	"#stringFrom:at: is supplied in a version specific package.	If there are no implementers the appropriate package needs to be loaded. :-)"	^ self library stringFrom: handle at: aColumn! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '3/1/2025 19:01'!timeAt: aColumn	^ Time fromString: ( self stringAt: aColumn )! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '3/1/2025 19:01'!timestampAt: aColumn	^ DateAndTime fromString: ( self stringAt: aColumn )! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '3/1/2025 19:01'!typeOfColumn: aColumn	^ self library typeFor: handle at: aColumn! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '3/1/2025 19:01'!valueOfColumn: aColumn	^ self perform: (self typeOfColumn: aColumn) with: aColumn! !!SQLite3DoneResult class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeResultCode	^ SQLITE_DONE! !!SQLite3OKResult class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeResultCode	^ SQLITE_OK! !!SQLite3Result class methodsFor: 'accessing' stamp: '3/1/2025 19:01'!forNativeResultCode: anInteger	^ (self subclassForNativeResultCode: anInteger) new! !!SQLite3Result class methodsFor: 'testing' stamp: '3/1/2025 19:01'!isAbstract	^self name = #SQLite3Result! !!SQLite3Result class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeResultCode	^ self subclassResponsibility! !!SQLite3Result class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!subclassForNativeResultCode: anInteger	^ self subclasses		detect: [ :subclass | subclass nativeResultCode = anInteger ]! !!SQLite3RowResult class methodsFor: 'private - accessing' stamp: '3/1/2025 19:01'!nativeResultCode	^ SQLITE_ROW! !"SQLite3-Core"!!SQLite3Benchmark commentStamp: '' prior: 0!Benchmarking harness.!!ManifestSQLite3CoreBenchmarks commentStamp: '' prior: 0!Please describe the package using the class comment of the included manifest class. The manifest class also includes other additional metadata for the package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!SQLite3Benchmark methodsFor: 'running' stamp: '3/1/2025 19:01'!basicExecute: anSQLText times: aCount	db beginTransaction.	1 to: aCount do: [ :i |		db basicExecute: anSQLText ].	db commitTransaction! !!SQLite3Benchmark methodsFor: 'connecting-disconnecting' stamp: '3/1/2025 19:01'!connectBy: aConnectionClass	db := aConnectionClass openOn: ':memory:'! !!SQLite3Benchmark methodsFor: 'connecting-disconnecting' stamp: '3/1/2025 19:01'!disconnect	db close! !!SQLite3Benchmark methodsFor: 'running' stamp: '3/1/2025 19:01'!execute: anSQLText times: aCount bindingsBlock: bindingsBlock	db beginTransaction.	1 to: aCount do: [ :i |		db execute: anSQLText with: (bindingsBlock value: i) ].	db commitTransaction! !!SQLite3Benchmark methodsFor: 'running' stamp: '3/1/2025 19:01'!finalizeStatement	stmt ifNotNil: [ stmt finalize ]! !!SQLite3Benchmark methodsFor: 'running' stamp: '3/1/2025 19:01'!prepStep: anSQLText times: aCount bindingsBlock: bindingsBlock	stmt := db prepare: anSQLText.	db beginTransaction.	1 to: aCount do: [ :i |		bindingsBlock value: stmt value: i.		stmt step; clearBindings; reset ].	db commitTransaction! !!SQLite3Benchmark methodsFor: 'running' stamp: '3/1/2025 19:01'!runBlock: aBlock	db beginTransaction.	aBlock value: db.	db commitTransaction! !!ManifestSQLite3CoreBenchmarks class methodsFor: 'code coverage' stamp: '3/1/2025 19:01'!classNamesNotUnderTest	^ #( ManifestSQLite3CoreBenchmarks )! !!ManifestSQLite3CoreBenchmarks class methodsFor: 'code-critics' stamp: '3/1/2025 19:01'!ruleClassNotReferencedRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#SQLite3Benchmark)) #'2022-05-10T08:25:40.035+02:00') )! !"SQLite3-Core-Benchmarks"!!SQLite3Library methodsFor: '*SQLite3-Pharo9' stamp: '3/1/2025 19:01'!stringFrom: aStatement at: aColumn	^ self apiColumnText: aStatement atColumn: aColumn! !"SQLite3-Pharo9"!!Random methodsFor: '*SQLite3-Pharo10' stamp: '3/1/2025 19:01'!nextInt: anInteger	^ self nextInteger: anInteger! !"SQLite3-Pharo10"!!SQLite3BaseConnectionTest commentStamp: '' prior: 0!Unit tests for SQLiteBaseConnection!!SQLite3ConnectionTest commentStamp: '' prior: 0!Unit tests for SQLiteConnection!!SQLite3DatabaseTest commentStamp: '' prior: 0!A test class for `SQLite3Database`!!SQLite3RowTest commentStamp: '' prior: 0!Unit tests for SQLite3Row!!SQLite3TableTest commentStamp: '' prior: 0!A test class for `SQLite3Table`!!ManifestSQLite3CoreTests commentStamp: '' prior: 0!Please describe the package using the class comment of the included manifest class. The manifest class also includes other additional metadata for the package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!SQLite3BaseConnectionTest methodsFor: 'tests - DEACTIVATED' stamp: '3/1/2025 19:01'!deactivatedTestTracing	| sql callback expected actual  |	(SystemVersion current major >= 7) ifTrue: [ self skip ].	"This test invokes a callback from SQLite to Pharo. It works in Pharo 6 and earlier but not in Pharo 7."	sql := #('create table if not exists x (xk integer primary key, iv integer, tv text)'			'insert into x values (NULL, 1, ''two'')'			'drop table x').	expected := String streamContents: [ :s |		s nextPutAll: sql first; cr;			nextPutAll: sql second; cr;			nextPutAll: sql third; cr ].	actual := WriteStream on: String new.	callback := FFICallback						signature: #(void (ExternalAddress appData, String sqlText))						block: [ :appdata :sqltext |							"We ignore appdata in this test, because we're passing a null pointer in."							actual nextPutAll: sqltext; cr ].	"The null pointer appears as appdata in the callback."	db traceUsing: callback with: ExternalAddress new.	res := db basicExecute: sql first.	self assert: res equals: 0.	res := db basicExecute: sql second.	self assert: res equals: 0.	res := db basicExecute: sql third.	self assert: res equals: 0.	self assert: actual contents equals: expected! !!SQLite3BaseConnectionTest methodsFor: 'private' stamp: '3/1/2025 19:01'!executeInDB: anSQLText	| result |	result := db basicExecute: anSQLText.	self assert: result equals: 0! !!SQLite3BaseConnectionTest methodsFor: 'utilities' stamp: '3/1/2025 19:01'!getTempPath	| env |	env := Smalltalk os environment.	^ Smalltalk os isWindows		  ifTrue: [ "See https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-gettemppath2a"			  (env				   at: 'TMP'				   ifAbsent: [ env at: 'TEMP' ifAbsent: [ env at: 'USERPROFILE' ] ])			  , '\' ]		  ifFalse: [ "See https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html"			(env at: 'TMPDIR' ifAbsent: ['/tmp']), '/' ]! !!SQLite3BaseConnectionTest methodsFor: 'utilities' stamp: '3/1/2025 19:01'!invalidFileNameOnCurrentOperatingSystem	^Smalltalk os isWindows		ifTrue: [ '/&*no' ]		ifFalse: [ '/nosuchfile' ]! !!SQLite3BaseConnectionTest methodsFor: 'utilities' stamp: '3/1/2025 19:01'!newUniqueFileName	^ self getTempPath , UUID new asString! !!SQLite3BaseConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!noTestColumnNamesBobbyGo	"In this test, Bobby Tables strikes naive SQL string construction."	"20190302, pierce: #basicExecute: uses prepare/step/finalize internally and is no longer susceptible to injection attacks. "	| tables bobby |	res := db basicExecute: 'create table x (xk integer, xv integer);'.	self assert: res equals: 0.	res := db basicExecute:		       'create table students (sk integer, sname varchar);'.	self assert: res equals: 0.	tables := db tableNames.	self assert: tables size equals: 2.	self assert: tables first equals: 'x'.	self assert: tables second equals: 'students'.	bobby := 'x); drop table students; --'.	res := db basicExecute: 'pragma table_info(' , bobby , ')'.	self assert: res equals: 0.	tables := db tableNames.	self assert: tables size equals: 1.	self assert: tables first equals: 'x'! !!SQLite3BaseConnectionTest methodsFor: 'running' stamp: '3/1/2025 19:01'!setUp	super setUp.	db := SQLite3BaseConnection on: ':memory:'.	db open! !!SQLite3BaseConnectionTest methodsFor: 'running' stamp: '3/1/2025 19:01'!tearDown	[ db close ] on: SQLite3Misuse do: [ ].	super tearDown! !!SQLite3BaseConnectionTest methodsFor: 'tests - connections' stamp: '3/1/2025 19:01'!testBadOpen	| newConnection |	newConnection := SQLite3BaseConnection on: self invalidFileNameOnCurrentOperatingSystem.	self should: [ newConnection open ] raise: SQLite3CantOpen.	self deny: newConnection isOpen! !!SQLite3BaseConnectionTest methodsFor: 'tests - execution' stamp: '3/1/2025 19:01'!testBasicExecuteOk	self executeInDB: 'create table x (xk integer, xv integer);'.	self executeInDB: 'drop table x;'! !!SQLite3BaseConnectionTest methodsFor: 'tests - execution' stamp: '3/1/2025 19:01'!testBasicExecuteSyntaxError	self should: [ db basicExecute: 'create table,;' ]		raise: SQLite3AbstractError! !!SQLite3BaseConnectionTest methodsFor: 'tests - types' stamp: '3/1/2025 19:01'!testBooleanColumnTypeMismatch	self executeInDB: 'create table x (xk integer primary key, xv notboolean);'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row | self should: [ row booleanAt: 0 ] raise: SQLite3AbstractError ] ]! !!SQLite3BaseConnectionTest methodsFor: 'tests - types' stamp: '3/1/2025 19:01'!testBooleanObject	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putObject: true.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row objectAt: 0.			self assert: value equals: true			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing' stamp: '3/1/2025 19:01'!testBooleanWriteIntegerOneThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putInteger: 1.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row booleanAt: 0.			self assert: value equals: true			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing' stamp: '3/1/2025 19:01'!testBooleanWriteIntegerTwoThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putInteger: 2.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row | self should: [ row booleanAt: 0 ] raise: SQLite3AbstractError ] ]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing' stamp: '3/1/2025 19:01'!testBooleanWriteIntegerZeroThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putInteger: 0.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row booleanAt: 0.			self assert: value equals: false			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing' stamp: '3/1/2025 19:01'!testBooleanWriteNilThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putNil: nil.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row booleanAt: 0.			self assert: value isNil			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing' stamp: '3/1/2025 19:01'!testBooleanWriteSQLNullThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, NULL)' do: [ :statement | statement step ].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row booleanAt: 0.			self assert: value isNil			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing' stamp: '3/1/2025 19:01'!testBooleanWriteStringFalseThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putString: 'false'.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row booleanAt: 0.			self assert: value equals: false			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing' stamp: '3/1/2025 19:01'!testBooleanWriteStringTrueThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putString: 'true'.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row booleanAt: 0.			self assert: value equals: true			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing' stamp: '3/1/2025 19:01'!testBooleanWriteStringTwoThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putString: '2'.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row | self should: [ row booleanAt: 0 ] raise: SQLite3AbstractError ] ]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing' stamp: '3/1/2025 19:01'!testBooleanWriteThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putBoolean: true.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row booleanAt: 0.			self assert: value equals: true			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - connections' stamp: '3/1/2025 19:01'!testCloseFile	| fileName newConnection |	fileName := self newUniqueFileName.	newConnection := SQLite3BaseConnection on: fileName.	newConnection		open;		close.	newConnection := nil.	Smalltalk garbageCollect.	self		shouldnt: [ File deleteFile: fileName ]		raise: CannotDeleteFileException! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns' stamp: '3/1/2025 19:01'!testColumnNames	| columns |	self executeInDB: 'create table x (xk integer, xv integer);'.	columns := db columnNamesFor: 'x'.	self assert: columns size equals: 2.	self assert: columns first equals: 'xk'.	self assert: columns second equals: 'xv'! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns' stamp: '3/1/2025 19:01'!testColumnNamesBobbyStop	"In this test, Bobby Tables strikes again, but fails, because #columnNamesFor: uses parameter binding."	| columns tables |	self executeInDB: 'create table x (xk integer, xv integer);'.	self executeInDB: 'create table students (sk integer, sname varchar);'.	tables := db tableNames.	self assert: tables size equals: 2.	self assert: tables first equals: 'x'.	self assert: tables second equals: 'students'.	columns := db columnNamesFor: 'x; drop table students; --'.	self assert: columns isNil.	tables := db tableNames.	self assert: tables size equals: 2.	self assert: tables first equals: 'x'.	self assert: tables second equals: 'students'! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns' stamp: '3/1/2025 19:01'!testColumnNamesForNoSuchTableWithSpaces	| columns |	self executeInDB: 'create table x (xk integer, xv integer);'.	columns := db columnNamesFor: 'no such table with spaces'.	self assert: columns isNil! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns' stamp: '3/1/2025 19:01'!testColumnNamesForTableWithSpaces	| columns |	self executeInDB: 'create table [table name with spaces] (xk integer, xv integer);'.	columns := db columnNamesFor: 'table name with spaces'.	self assert: columns size equals: 2.	self assert: columns first equals: 'xk'.	self assert: columns second equals: 'xv'! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns' stamp: '3/1/2025 19:01'!testColumnNamesNoSuchTable	| columns |	self executeInDB: 'create table x (xk integer, xv integer);'.	columns := db columnNamesFor: 'y'.	self assert: columns isNil! !!SQLite3BaseConnectionTest methodsFor: 'tests - connections' stamp: '3/1/2025 19:01'!testConstraintViolation	self		executeInDB: 'create table x (value integer primary key);';		executeInDB: 'insert into x values(1);'.	self should: [ db basicExecute: 'insert into x values(1);' ] raise: SQLite3ConstraintViolation! !!SQLite3BaseConnectionTest methodsFor: 'tests - execution' stamp: '3/1/2025 19:01'!testDataValuesAvailable	self executeInDB: 'create table x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'insert into x values (NULL, 1, "duh");'.	self		withPreparedStatement: 'select * from x'		do: [ :statement |		statement basicExecute: [ :row | self assert: row dataValuesAvailable equals: 3 ] ]! !!SQLite3BaseConnectionTest methodsFor: 'tests - types' stamp: '3/1/2025 19:01'!testDate	| data |	data := Date year: 2015 month: 4 day: 1.	self executeInDB: 'create table x (xv date);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (?)' do: [ :statement |		statement at: 1 putDateTime: data.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row dateTimeAt: 0.			self				assert: value year equals: 2015;				assert: value month equals: 4;				assert: value dayOfMonth equals: 1			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - types' stamp: '3/1/2025 19:01'!testDateAndTime	| data |	data := DateAndTime year: 2015 month: 4 day: 1.	self executeInDB: 'create table x (xv datetime);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (?)' do: [ :statement |		statement at: 1 putDateTime: data.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row dateTimeAt: 0.			self				assert: value year equals: 2015;				assert: value month equals: 4;				assert: value dayOfMonth equals: 1;				assert: value hours equals: 0;				assert: value minutes equals: 0;				assert: value seconds equals: 0			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns' stamp: '3/1/2025 19:01'!testDeclaredColumnTypes	| columns |	self executeInDB: 'create table x (xk integer, xv blob, xb boolean);'.	columns := db declaredColumnTypesFor: 'x'.	self assert: columns size equals: 3.	self assert: columns first equals: 'INTEGER'.	self assert: columns second equals: 'BLOB'.	self assert: columns third equals: 'boolean'! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns' stamp: '3/1/2025 19:01'!testDeclaredColumnTypesForNoSuchTable	| columns |	self executeInDB: 'create table x (xk integer, xv integer);'.	columns := db declaredColumnTypesFor: 'y'.	self assert: columns isNil! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns' stamp: '3/1/2025 19:01'!testDeclaredColumnTypesForNoSuchTableWithSpaces	| columns |	self executeInDB: 'create table x (xk integer, xv integer);'.	columns := db declaredColumnTypesFor: 'no such table with spaces'.	self assert: columns isNil! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns' stamp: '3/1/2025 19:01'!testDeclaredColumnTypesForTableWithSpaces	| columns |	self executeInDB: 'create table [table name with spaces] (xk INTEGER, xv BLOB, xb BOOLEAN);'.	columns := db declaredColumnTypesFor: 'table name with spaces'.	self assert: columns size equals: 3.	self assert: columns first equals: 'INTEGER'.	self assert: columns second equals: 'BLOB'.	self assert: columns third equals: 'BOOLEAN'! !!SQLite3BaseConnectionTest methodsFor: 'tests - multilingual' stamp: '3/1/2025 19:01'!testDefaultMultilingualStrings	self executeInDB:		'create table x (xk integer primary key, xm1 text default '''', xm2 text default '''');'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x (xk) values (NULL)' do: [ :statement | statement step ].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xm1, xm2 from x order by xk' do: [ :statement |		statement basicExecute: [ :row |			self assert: ( row stringAt: 0 ) equals: ''.			self assert: ( row stringAt: 1 ) equals: ''			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - connections' stamp: '3/1/2025 19:01'!testDoubleClose	db close.	[ db close ] on: SQLite3Misuse do: [ ]	"#tearDown will close the db again, and is similarly guarded."! !!SQLite3BaseConnectionTest methodsFor: 'tests - types' stamp: '3/1/2025 19:01'!testFloat	self executeInDB: 'create table x (xk integer primary key, xv real);'.	self executeInDB: 'insert into x values (NULL, 1.141);'.	self withPreparedStatement: 'select * from x' do: [ :statement |		statement basicExecute: [ :row |			self assert: ( row nameOfColumn: 1 ) equals: 'xv'.			self assert: ( row floatAt: 1 ) equals: 1.141			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - types' stamp: '3/1/2025 19:01'!testInteger	"The large integer comes from Glorp's testInt8."	self executeInDB: 'create table x (xk integer primary key, xv integer);'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putInteger: 3212321555.		statement step		].	self withPreparedStatement: 'select * from x' do: [ :statement |		statement basicExecute: [ :row |			self assert: ( row nameOfColumn: 1 ) equals: 'xv'.			self assert: ( row integerAt: 1 ) equals: 3212321555			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testIsAbstract	self assert: SQLite3BaseConnection isAbstract! !!SQLite3BaseConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testIsThreadsafe	self assert: (SQLite3BaseConnection isThreadsafe isKindOf: Boolean)! !!SQLite3BaseConnectionTest methodsFor: 'tests - multilingual' stamp: '3/1/2025 19:01'!testMultilingualStrings	| data index |	data := OrderedCollection with: 'English' with: '' with: '' , ''.	self executeInDB: 'create table x (xk integer primary key, xv varchar);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		data do: [ :ea |			statement at: 1 putString: ea.			statement				step;				clearBindings;				reset			]		].	self executeInDB: 'commit'.	index := 1.	self withPreparedStatement: 'select xv from x order by xk asc' do: [ :statement |		statement basicExecute: [ :row |			self assert: ( row stringAt: 0 ) equals: ( data at: index ).			index := index + 1			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - multilingual' stamp: '3/1/2025 19:01'!testMultilingualTableName	self executeInDB: 'create table  (xk integer primary key, xm1 text default '''');'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into  (xk) values (NULL)' do: [ :statement | statement step ].	self executeInDB: 'commit'.	self		withPreparedStatement: 'select xm1 from  order by xk'		do: [ :statement |		statement basicExecute: [ :row | self assert: ( row stringAt: 0 ) equals: '' ] ]! !!SQLite3BaseConnectionTest methodsFor: 'tests - types' stamp: '3/1/2025 19:01'!testObjectBlob	| data |	data := OrderedCollection with: 1 with: 'two' with: 3.3.	self		executeInDB: 'create table x (xk integer primary key, xv blob);';		executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putObject: data.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row objectAt: 0.			self				assert: value size equals: 3;				assert: value first equals: 1;				assert: value second equals: 'two';				assert: value third equals: 3.3			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testPrepareStep	self executeInDB: 'create table x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?, ?)' do: [ :statement |		self assert: statement sqlText equals: 'insert into x values (NULL, ?, ?)'.		1 to: 10 do: [ :x |			statement at: 1 putInteger: x * x.			statement at: 2 putString: ( '<1p> * <1p>' expandMacrosWith: x ).			statement step.			statement clearBindings.			statement reset			]		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select * from x' do: [ :statement |		| i |		self assert: statement sqlText equals: 'select * from x'.		statement basicExecute: [ :row |			i := row integerAt: 0.			self assert: ( row integerAt: 1 ) equals: i * i.			self assert: ( row stringAt: 2 ) equals: ( '<1p> * <1p>' expandMacrosWith: i )			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testPrepareStepSelective	| i count |	self executeInDB: 'create table x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?, ?)' do: [ :statement |		self assert: statement sqlText equals: 'insert into x values (NULL, ?, ?)'.		1 to: 10 do: [ :x |			statement				at: 1 putInteger: x * x;				at: 2 putString: x asString , ' * ' , x asString;				step;				clearBindings;				reset			]		].	self executeInDB: 'commit'.	count := 0.	self withPreparedStatement: 'select * from x where iv < ?' do: [ :statement |		self assert: statement sqlText equals: 'select * from x where iv < ?'.		statement at: 1 putInteger: 27.		statement basicExecute: [ :row |			count := count + 1.			i := row integerAt: 0.			self assert: ( row integerAt: 1 ) equals: i * i.			self assert: ( row stringAt: 2 ) equals: i asString , ' * ' , i asString			]		].	self assert: count equals: 5! !!SQLite3BaseConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testResultSetColumnIntrospection	self executeInDB: 'create table x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'insert into x values (NULL, 1, "duh");'.	self withPreparedStatement: 'select * from x' do: [ :statement |		statement basicExecute: [ :row |			self assert: ( row nameOfColumn: 0 ) equals: 'xk'.			self assert: ( row valueOfColumn: 0 ) equals: 1.			self assert: ( row nameOfColumn: 1 ) equals: 'iv'.			self assert: ( row valueOfColumn: 1 ) equals: 1.			self assert: ( row nameOfColumn: 2 ) equals: 'tv'.			self assert: ( row valueOfColumn: 2 ) equals: 'duh'			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - types' stamp: '3/1/2025 19:01'!testScaledDecimal	"This test is a simplified version of GlorpNumericTest>>tesNumeric."	| number float |	number := Number readFrom: '12345678s'.	float := number asFloat.	self executeInDB: 'create table x (xk integer primary key, xv real);'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putFloat: number.		statement step		].	self withPreparedStatement: 'select * from x' do: [ :statement |		statement basicExecute: [ :row |			self				assert: ( row nameOfColumn: 1 ) equals: 'xv';				assert: ( row floatAt: 1 ) equals: float			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - tables' stamp: '3/1/2025 19:01'!testTableNames	| tables |	self executeInDB: 'create table x (xk integer, xv integer);'.	tables := db tableNames.	self assert: tables size equals: 1.	self assert: tables first equals: 'x'! !!SQLite3BaseConnectionTest methodsFor: 'tests - tables' stamp: '3/1/2025 19:01'!testTableNamesOfEmptyDatabase	| tables |	tables := db tableNames.	self assert: tables isEmpty! !!SQLite3BaseConnectionTest methodsFor: 'tests - types' stamp: '3/1/2025 19:01'!testTime	| data |	data := Time noon.	self		executeInDB: 'create table x (xv time);';		executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (?)' do: [ :statement |		statement at: 1 putTime: data.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row timeAt: 0.			self				assert: value hour equals: data hour;				assert: value minute equals: data minute;				assert: value second equals: data second			]		]! !!SQLite3BaseConnectionTest methodsFor: 'private' stamp: '3/1/2025 19:01'!withPreparedStatement: anSQLText do: aBlock	| statement |	statement := db prepare: anSQLText.	[ aBlock value: statement ] ensure: [ statement finalize ]! !!SQLite3ColumnTest methodsFor: 'running' stamp: '3/1/2025 19:01'!setUp	super setUp.	db := SQLite3Database memory.	db connection open.	db connection execute: self tableCreationScript.	table := db tables first.	firstColumn := table columns first.	secondColumn := table columns second! !!SQLite3ColumnTest methodsFor: 'accessing' stamp: '3/1/2025 19:01'!tableCreationScript	^'CREATE TABLE "SAMPLE"(    [ID] INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,    [NAME] NVARCHAR(120))'! !!SQLite3ColumnTest methodsFor: 'running' stamp: '3/1/2025 19:01'!tearDown	db connection close.	db := nil.	super tearDown! !!SQLite3ColumnTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testHasNotNullConstraint	self assert: firstColumn hasNotNullConstraint.	self deny: secondColumn hasNotNullConstraint! !!SQLite3ColumnTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testIndex	self assert: firstColumn index equals: 0.	self assert: secondColumn index equals: 1! !!SQLite3ColumnTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testInitialization	| instance |	instance := SQLite3Column new.	self deny: instance hasNotNullConstraint! !!SQLite3ColumnTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testName	self assert: firstColumn name equals: 'ID'.	self assert: secondColumn name equals: 'NAME'! !!SQLite3ColumnTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testPrintString	self assert: firstColumn printString equals: 'a SQLite3Column("ID")'.	self assert: secondColumn printString equals: 'a SQLite3Column("NAME")'! !!SQLite3ColumnTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testType	self assert: firstColumn type equals: 'INTEGER'.	self assert: secondColumn type equals: 'NVARCHAR(120)'! !!SQLite3ConnectionTest methodsFor: 'private' stamp: '3/1/2025 19:01'!executeInDB: anSQLText	| result |	result := db basicExecute: anSQLText.	self assert: result equals: 0! !!SQLite3ConnectionTest methodsFor: 'utilities' stamp: '3/1/2025 19:01'!populateRowsInto: tableName of: database	| rand rows schema insert rn rt |	 rand := Random new.	rows := rand nextInt: 100.	schema := 'create table ', tableName, ' (rk integer primary key, rn integer, rt text);'.	insert := 'insert into ', tableName, ' values (?, ?, ?)'.	database basicExecute: 'begin'.	database	basicExecute: schema.	1 to: rows do: [ :i |		rn := i * (rand nextInt: 10).		rt := i asString, '-ZZZ'.		database execute: insert with: (Array with: i with: rn with: rt) ].	database basicExecute: 'commit'.	^ rows! !!SQLite3ConnectionTest methodsFor: 'running' stamp: '3/1/2025 19:01'!setUp	super setUp.	db := SQLite3Connection memory.	db open! !!SQLite3ConnectionTest methodsFor: 'running' stamp: '3/1/2025 19:01'!tearDown	[ db close ] on: SQLite3Misuse do: [ ].	[ target ifNotNil:[target close] ] on: SQLite3Misuse do: [ ].	super tearDown! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testBackup	| row backup |	target := SQLite3Connection memory.	target open.	self populateRowsInto: 'junk' of: db.	backup := db backupTo: target.	backup open; step; finish.	row := (target execute: 'select * from junk where rt = ''1-ZZZ''') onlyRow.	self assert: (row at: 'rk') equals: 1.	self assert: (row at: 'rt') equals: '1-ZZZ'.	self assert: (row at: 1) equals: 1.	self assert: (row at: 3) equals: '1-ZZZ'! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testChanges	| count |	count := self populateRowsInto: 'stuff' of: db.	self assert: db changes equals: 1.	(db basicExecute: 'delete from stuff').	self assert: db changes equals: count! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testDo	| arrayResults dictResults |	self executeInDB:		'create table if not exists x (id integer , tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	db basicExecute: 'insert into x values (10, "abc")'.	db basicExecute: 'insert into x values (20, "def")'.	db basicExecute: 'insert into x values (30, "ghi")'.	res := db commitTransaction.	self assert: res equals: 0.	arrayResults := OrderedCollection new.	dictResults := OrderedCollection new.	rs := db execute: 'select * from x;'.	rs do: [ :row |		arrayResults add: row asArray.		dictResults add: row asDictionary ].	rs close.	self deny: arrayResults isEmpty.	self assert: arrayResults size equals: 3.	self assert: arrayResults first equals: #( 10 'abc' ).	self assert: arrayResults second equals: #( 20 'def' ).	self assert: arrayResults third equals: #( 30 'ghi' ).	self deny: dictResults isEmpty.	self assert: dictResults size equals: 3.	self assert: dictResults first equals: { ('id' -> 10). ('tv' -> 'abc') } asDictionary.	self assert: dictResults second equals: { ('id' -> 20). ('tv' -> 'def') } asDictionary.	self assert: dictResults third equals: { ('id' -> 30). ('tv' -> 'ghi') } asDictionary! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExactlyOneRow	| row |	self populateRowsInto: 'junk' of: db.	row := (db execute: 'select * from junk where rt = ''1-ZZZ''') onlyRow.	self assert: (row at: 'rk') equals: 1.	self assert: (row at: 'rt') equals: '1-ZZZ'.	self assert: (row at: 1) equals: 1.	self assert: (row at: 3) equals: '1-ZZZ'! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExactlyOneRowGotNone	| row |	self populateRowsInto: 'junk' of: db.	row := (db execute: 'select * from junk where rt = ''0-ZZZ''') onlyRow.	self assert: row isNil! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteDelete	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	rs := db execute: 'delete from x;'.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteDrop	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	rs := db execute: 'drop table x;'.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteNoResult	rs := db execute: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self assert: (rs next isNil).	rs close.	rs := db execute: 'delete from x;'.	self assert: (rs next isNil).	rs close.	rs := db execute: 'drop table x;'.	self assert: (rs next isNil).	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteValueInsertArray	| rd |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' value: 1 value: 'two'.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rd := ( db execute: 'select * from x' ) rows first.	self assert: ( rd at: 'xk' ) equals: 1.	self assert: ( rd at: 'iv' ) equals: 1.	self assert: ( rd at: 'tv' ) equals: 'two'.	self assert: ( rd at: 1 ) equals: 1.	self assert: ( rd at: 2 ) equals: 1.	self assert: ( rd at: 3 ) equals: 'two'.	self assert: rd first equals: 1.	self assert: rd last equals: 'two'! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteValueInsertBooleanNilThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, bv boolean);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?)' value: nil.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'bv' ) equals: nil.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: nil.	self assert: row first equals: 1.	self assert: row last equals: nil.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteValueInsertBooleanThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, bv boolean);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?)' value: true.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'bv' ) equals: true.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: true.	self assert: row first equals: 1.	self assert: row last equals: true.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteValueInsertChanges	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' value: 1 value: 'two'.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	self assert: db changes equals: 1.	self assert: db totalChanges equals: 1.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' value: 2 value: 'too'.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	self assert: db changes equals: 1.	self assert: db totalChanges equals: 2! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteValueInsertThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' value: 1 value: 'two'.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'iv' ) equals: 1.	self assert: ( row at: 'tv' ) equals: 'two'.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: 1.	self assert: ( row at: 3 ) equals: 'two'.	self assert: row first equals: 1.	self assert: row last equals: 'two'.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteValueInsertThenSelect2	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' value: 1 value: 'two'.	self assert: rs next isNil.	rs close.	rs := db execute: 'insert into x values (NULL, ?, ?)' value: 2 value: 'three'.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'iv' ) equals: 1.	self assert: ( row at: 'tv' ) equals: 'two'.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: 1.	self assert: ( row at: 3 ) equals: 'two'.	self assert: row first equals: 1.	self assert: row last equals: 'two'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 2.	self assert: ( row at: 'iv' ) equals: 2.	self assert: ( row at: 'tv' ) equals: 'three'.	self assert: ( row at: 1 ) equals: 2.	self assert: ( row at: 2 ) equals: 2.	self assert: ( row at: 3 ) equals: 'three'.	self assert: row first equals: 2.	self assert: row last equals: 'three'.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteValueInsertThenSelectDateTime	| row data |	self executeInDB: 'create table if not exists x (xv datetime);'.	res := db beginTransaction.	self assert: res equals: 0.	data := DateAndTime year: 2015 month: 4 day: 1.	rs := db execute: 'insert into x values (?)' value: data.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select xv from x'.	row := rs next.	data := row at: 'xv'.	self assert: data class equals: DateAndTime.	self assert: data year equals: 2015.	self assert: data month equals: 4.	self assert: data dayOfMonth equals: 1.	data := row at: 1.	self assert: data class equals: DateAndTime.	self assert: data year equals: 2015.	self assert: data month equals: 4.	self assert: data dayOfMonth equals: 1.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteWithAllInsertManyValues	| results |	self executeInDB:		'create table if not exists x (iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	db		execute: 'insert into x values (?, ?)'		withAll: #( #( 1 'two' ) #( 2 'three' ) #( 3 'four' ) ).	res := db commitTransaction.	self assert: res equals: 0.	results := OrderedCollection new.	rs := db execute: 'select * from x'.	rs do: [ :each | results add: each asArray ].	rs close.	self deny: results isEmpty.	self assert: results size equals: 3.	self assert: results first equals: #( 1 'two' ).	self assert: results second equals: #( 2 'three' ).	self assert: results third equals: #( 3 'four' )! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteWithAllUpdateManyValues	| results |	self executeInDB:		'create table if not exists x (iv integer, tv text);'.	self executeInDB: 'delete from x;'.	self executeInDB: 'insert into x values (1, ''two'')'.	self executeInDB: 'insert into x values (2, ''three'')'.	self executeInDB: 'insert into x values (3, ''four'')'.	results := OrderedCollection new.	rs := db execute: 'select * from x'.	rs do: [ :each | results add: each asArray ].	rs close.	self deny: results isEmpty.	self assert: results size equals: 3.	self assert: results first equals: #( 1 'two' ).	self assert: results second equals: #( 2 'three' ).	self assert: results third equals: #( 3 'four' ).	res := db beginTransaction.	self assert: res equals: 0.	db		execute: 'update x set tv = ?2 where iv = ?1'		withAll: #( #( 1 'five' ) #( 2 'six' ) #( 3 'seven' ) ).	res := db commitTransaction.	self assert: res equals: 0.	results := OrderedCollection new.	rs := db execute: 'select * from x'.	rs do: [ :each | results add: each asArray ].	rs close.	self deny: results isEmpty.	self assert: results size equals: 3.	self assert: results first equals: #( 1 'five' ).	self assert: results second equals: #( 2 'six' ).	self assert: results third equals: #( 3 'seven' )! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteWithInsertArray	| rd |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' with: #( 1 'two' ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rd := ( db execute: 'select * from x' ) rows first.	self assert: ( rd at: 'xk' ) equals: 1.	self assert: ( rd at: 'iv' ) equals: 1.	self assert: ( rd at: 'tv' ) equals: 'two'.	self assert: ( rd at: 1 ) equals: 1.	self assert: ( rd at: 2 ) equals: 1.	self assert: ( rd at: 3 ) equals: 'two'.	self assert: rd first equals: 1.	self assert: rd last equals: 'two'! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteWithInsertBooleanNilThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, bv boolean);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?)' with: ( Array with: nil ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'bv' ) equals: nil.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: nil.	self assert: row first equals: 1.	self assert: row last equals: nil.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteWithInsertBooleanSQLNullThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, bv boolean);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, NULL)'.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'bv' ) equals: nil.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: nil.	self assert: row first equals: 1.	self assert: row last equals: nil.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteWithInsertBooleanThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, bv boolean);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?)' with: ( Array with: true ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'bv' ) equals: true.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: true.	self assert: row first equals: 1.	self assert: row last equals: true.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteWithInsertChanges	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' with: #( 1 'two' ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	self assert: db changes equals: 1.	self assert: db totalChanges equals: 1.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' with: #( 2 'too' ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	self assert: db changes equals: 1.	self assert: db totalChanges equals: 2! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteWithInsertDictionary	| rd |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db		      execute: 'insert into x values (NULL, :first, :two)'		      with: ( Dictionary newFromPairs: #( ':first' 1 ':two' '2' ':nosuch' 3 ) ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rd := ( db execute: 'select * from x' ) rows first.	self assert: ( rd at: 'xk' ) equals: 1.	self assert: ( rd at: 'iv' ) equals: 1.	self assert: ( rd at: 'tv' ) equals: '2'.	self assert: ( rd at: 1 ) equals: 1.	self assert: ( rd at: 2 ) equals: 1.	self assert: ( rd at: 3 ) equals: '2'.	self assert: rd first equals: 1.	self assert: rd last equals: '2'! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteWithInsertMultilingualStringsThenSelect	| data s row idx |	data := OrderedCollection with: 'English' with: '' with: '' , ''.	self executeInDB: 'create table if not exists x (xk integer primary key, tv text);'.	self executeInDB: 'delete from x;'.	self executeInDB: 'begin'.	s := db prepare: 'insert into x values (NULL, ?)'.	data do: [ :x |		s at: 1 putString: x.		s step.		s clearBindings.		s reset		].	s finalize.	self executeInDB: 'commit'.	idx := 1.	rs := db execute: 'select xk, tv from x order by xk asc'.	[ ( row := rs next ) isNotNil ] whileTrue: [		self assert: ( row at: 'xk' ) equals: idx.		self assert: ( row at: 'tv' ) equals: ( data at: idx ).		idx := idx + 1		].	rs close.	self assert: idx equals: 4! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteWithInsertNoDataThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL)' with: #(  ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 1 ) equals: 1.	self assert: row first equals: 1.	self assert: row last equals: 1.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteWithInsertThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' with: #( 1 'two' ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'iv' ) equals: 1.	self assert: ( row at: 'tv' ) equals: 'two'.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: 1.	self assert: ( row at: 3 ) equals: 'two'.	self assert: row first equals: 1.	self assert: row last equals: 'two'.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteWithInsertThenSelect2	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' with: #( 1 'two' ).	self assert: rs next isNil.	rs close.	rs := db execute: 'insert into x values (NULL, ?, ?)' with: #( 2 'three' ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'iv' ) equals: 1.	self assert: ( row at: 'tv' ) equals: 'two'.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: 1.	self assert: ( row at: 3 ) equals: 'two'.	self assert: row first equals: 1.	self assert: row last equals: 'two'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 2.	self assert: ( row at: 'iv' ) equals: 2.	self assert: ( row at: 'tv' ) equals: 'three'.	self assert: ( row at: 1 ) equals: 2.	self assert: ( row at: 2 ) equals: 2.	self assert: ( row at: 3 ) equals: 'three'.	self assert: row first equals: 2.	self assert: row last equals: 'three'.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteWithInsertThenSelect3	| s row idx |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	self executeInDB: 'begin'.	s := db prepare: 'insert into x values (NULL, ?, ?)'.	1 to: 10 do: [ :x |		s at: 1 putInteger: x * x.		s at: 2 putString: x asString , ' * ' , x asString.		s step.		s clearBindings.		s reset		].	s finalize.	self executeInDB: 'commit'.	idx := 1.	rs := db execute: 'select * from x where iv < ?' with: #( 27 ).	[ ( row := rs next ) isNotNil ] whileTrue: [		self assert: ( row at: 'xk' ) equals: idx.		self assert: ( row at: 'iv' ) equals: idx * idx.		self assert: ( row at: 'tv' ) equals: idx asString , ' * ' , idx asString.		self assert: ( row at: 1 ) equals: idx.		self assert: ( row at: 2 ) equals: idx * idx.		self assert: ( row at: 3 ) equals: idx asString , ' * ' , idx asString.		self assert: row first equals: idx.		self assert: row last equals: idx asString , ' * ' , idx asString.		idx := idx + 1		].	rs close.	self assert: idx equals: 6! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteWithInsertThenSelectChineseTableName	| data s row idx |	data := OrderedCollection with: 'English' with: '' with: '' , ''.	self executeInDB: 'create table if not exists  (xk integer primary key, tv text);'.	self executeInDB: 'delete from ;'.	self executeInDB: 'begin'.	s := db prepare: 'insert into  values (NULL, ?)'.	data do: [ :x |		s at: 1 putString: x.		s step.		s clearBindings.		s reset		].	s finalize.	self executeInDB: 'commit'.	idx := 1.	rs := db execute: 'select xk, tv from  order by xk asc'.	[ ( row := rs next ) isNotNil ] whileTrue: [		self assert: ( row at: 'xk' ) equals: idx.		self assert: ( row at: 'tv' ) equals: ( data at: idx ).		idx := idx + 1		].	rs close.	self assert: idx equals: 4! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteWithInsertThenSelectDateTime	| row data |	self executeInDB: 'create table if not exists x (xv datetime);'.	res := db beginTransaction.	self assert: res equals: 0.	data := DateAndTime year: 2015 month: 4 day: 1.	rs := db execute: 'insert into x values (?)' with: ( Array with: data ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select xv from x'.	row := rs next.	data := row at: 'xv'.	self assert: data class equals: DateAndTime.	self assert: data year equals: 2015.	self assert: data month equals: 4.	self assert: data dayOfMonth equals: 1.	data := row at: 1.	self assert: data class equals: DateAndTime.	self assert: data year equals: 2015.	self assert: data month equals: 4.	self assert: data dayOfMonth equals: 1.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteWithInsertThenSelectJapaneseTableName	| data s row idx |	data := OrderedCollection with: 'English' with: '' with: '' , ''.	self executeInDB: 'create table if not exists  (xk integer primary key, tv text);'.	self executeInDB: 'delete from ;'.	self executeInDB: 'begin'.	s := db prepare: 'insert into  values (NULL, ?)'.	data do: [ :x |		s at: 1 putString: x.		s step.		s clearBindings.		s reset		].	s finalize.	self executeInDB: 'commit'.	idx := 1.	rs := db execute: 'select xk, tv from  order by xk asc'.	[ ( row := rs next ) isNotNil ] whileTrue: [		self assert: ( row at: 'xk' ) equals: idx.		self assert: ( row at: 'tv' ) equals: ( data at: idx ).		idx := idx + 1		].	rs close.	self assert: idx equals: 4! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteWithToFail	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	self		should: [ db execute: 'insert into x values (NULL, ?, ?)' with: 42 ]		raise: SQLite3AbstractError.	res := db rollbackTransaction.	self assert: res equals: 0! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testExecuteWithToFail2	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	self		should: [ db execute: 'insert into x values (NULL, ?, ?)' with: '42' ]		raise: SQLite3AbstractError.	res := db rollbackTransaction.	self assert: res equals: 0! !!SQLite3ConnectionTest methodsFor: 'tests - open / close' stamp: '3/1/2025 19:01'!testForcedClose	| fileRef conn |	fileRef := FileReference		           newTempFilePrefix: 'sqlite3_test_forced_close_'		           suffix: '.db'.	self assert: fileRef exists not.	conn := SQLite3Connection on: fileRef fullName.	conn open.	self assert: fileRef exists.	conn execute: 'create table if not exists BOOK (ID integer primary key, NAME VARCHAR2);'.	"now force closing"	conn forceClose.	Smalltalk garbageCollect.		"it must be possible to delete the DB now"	fileRef delete.	self assert: fileRef exists not! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testGetAutocommit	self assert: db getAutoCommit equals: true.	db beginTransaction.	self assert: db getAutoCommit equals: false.	db rollbackTransaction.	self assert: db getAutoCommit equals: true! !!SQLite3ConnectionTest methodsFor: 'tests - glorp compatibility' stamp: '3/1/2025 19:01'!testGlorpAutoID	| schema rows |	schema := 'CREATE TABLE BOOK (ID INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, STUFF TEXT NOT NULL);'.	db basicExecute: schema.	db beginTransaction.	db execute: 'insert into BOOK (STUFF) values (?)'		with: #('The Bad Beginning').	db execute: 'insert into BOOK (STUFF) values (?)'		with: #('Better Now').	db commitTransaction.	rows := (db execute: 'select last_insert_rowid() as lid') rows.	self assert: (rows first at: 'lid') equals: 2.	rows := (db execute: 'select * from BOOK') rows.	self assert: rows size equals: 2.	self assert: (rows first at: 'ID') equals: 1.	self assert: (rows first at: 'STUFF') equals: 'The Bad Beginning'! !!SQLite3ConnectionTest methodsFor: 'tests - glorp compatibility' stamp: '3/1/2025 19:01'!testGlorpCompositeKey	| schema rows |	"This is the schema generated by Glorp."	schema := 'CREATE TABLE GR_USER (ID integer  NOT NULL ,NAME text  NULL , CONSTRAINT GR_USER_PK PRIMARY KEY  (ID), CONSTRAINT GR_USER_UNIQ UNIQUE  (ID));'.	db basicExecute: schema.	db beginTransaction.	db execute: 'insert into GR_USER values (?, ?)' with: #(1 'User One').	db execute: 'insert into GR_USER values (?, ?)' with: #(2 'User Two').	db commitTransaction.	rs := db execute: 'select ID,NAME from GR_USER'.	rows := rs rows.	self assert: rows size equals: 2.	self assert: (rows first at: 'ID') equals: 1.	self assert: (rows first at: 'NAME') equals: 'User One'! !!SQLite3ConnectionTest methodsFor: 'tests - glorp compatibility' stamp: '3/1/2025 19:01'!testGlorpDoubleInsertPrimaryKey	| schema rows |	schema := 'CREATE TABLE GR_USER (ID integer  NOT NULL ,NAME text  NULL , CONSTRAINT GR_USER_PK PRIMARY KEY  (ID), CONSTRAINT GR_USER_UNIQ UNIQUE  (ID));'.	db basicExecute: schema.	db beginTransaction.	db execute: 'insert into GR_USER values (?, ?)'		with: #(1 'Fred').	self should: [ db execute: 'insert into GR_USER values (?, ?)' with: #(1 'Barney') ]		raise: SQLite3AbstractError.	db commitTransaction.	rs := db execute: 'select * from GR_USER'.	rows := rs rows.	self assert: rows size equals: 1.	self assert: (rows first at: 'ID') equals: 1.	self assert: (rows first at: 'NAME') equals: 'Fred'! !!SQLite3ConnectionTest methodsFor: 'tests - glorp compatibility' stamp: '3/1/2025 19:01'!testGlorpUpdate	| schema rows |	schema := 'CREATE TABLE BOOK (ID INTEGER PRIMARY KEY AUTOINCREMENT  NOT NULL ,TITLE text  NULL ,DESCRIPTION text  NULL ,COPIES_IN_STOCK int  NULL ,VERSION int  NULL );'.	db basicExecute: schema.	db beginTransaction.	db execute: 'insert into BOOK (TITLE,COPIES_IN_STOCK,VERSION) values (?, ?, ?)'		with: #('The Bad Beginning' 3 6).	db execute: 'UPDATE BOOK SET TITLE = ?,COPIES_IN_STOCK = ?,VERSION = ? WHERE ID = ? AND BOOK.VERSION = ?'		with: #('The Bad Beginning' 6 7 1 6).	db commitTransaction.	rs := db execute: 'select * from BOOK'.	rows := rs rows.	self assert: rows size equals: 1.	self assert: (rows first at: 'ID') equals: 1.	self assert: (rows first at: 'TITLE') equals: 'The Bad Beginning'.	self assert: (rows first at: 'COPIES_IN_STOCK') equals: 6! !!SQLite3ConnectionTest methodsFor: 'tests - glorp compatibility' stamp: '3/1/2025 19:01'!testGlorpUpdateTwice	| schema rows |	schema := 'CREATE TABLE BOOK (ID INTEGER PRIMARY KEY AUTOINCREMENT  NOT NULL ,TITLE text  NULL ,DESCRIPTION text  NULL ,COPIES_IN_STOCK int  NULL ,VERSION int  NULL );'.	db basicExecute: schema.	db beginTransaction.	db execute: 'insert into BOOK (TITLE,COPIES_IN_STOCK,VERSION) values (?, ?, ?)'		with: #('The Bad Beginning' 3 6).	db execute: 'UPDATE BOOK SET COPIES_IN_STOCK = 7'.	db execute: 'UPDATE BOOK SET TITLE = ?,COPIES_IN_STOCK = ?,VERSION = ? WHERE ID = ? AND BOOK.VERSION = ?'		with: #('The Bad Beginning' 6 7 1 6).	db commitTransaction.	rs := db execute: 'select * from BOOK'.	rows := rs rows.	self assert: rows size equals: 1.	self assert: (rows first at: 'ID') equals: 1.	self assert: (rows first at: 'TITLE') equals: 'The Bad Beginning'.	self assert: (rows first at: 'COPIES_IN_STOCK') equals: 6! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testInsertThenSelectInTransaction	"From GlorpDatabaseBasicTest>>testNameBinding."	self executeInDB: 'create table if not exists x (id integer , tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	db basicExecute: 'insert into x values (10, "abc")'.	db basicExecute: 'insert into x values (20, "def")'.	db basicExecute: 'insert into x values (30, "ghi")'.	rs := db execute: 'select * from x where id = ? or id = ?' with: { 10. 30 }.	self assert: rs rows size equals: 2.	res := db rollbackTransaction.	self assert: res equals: 0! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testRows	"SQLite uses 1-based column indexing for database rows."	| rowCount rows any |	rowCount := self populateRowsInto: 'junk' of: db.	rs := db execute: 'select * from junk'.	rs rowClass: SQLite3Row.	rows := rs rows.	self assert: rows size equals: rowCount.	self assert: ( rows first at: 'rk' ) equals: 1.	self assert: ( rows first at: 'rt' ) equals: '1-ZZZ'.	self assert: ( rows first at: 1 ) equals: 1.	self assert: ( rows first at: 3 ) equals: '1-ZZZ'.	1 to: 5 do: [ :x |		any := Random new nextInt: rowCount.		self assert: ( ( rows at: any ) at: 'rk' ) equals: any.		self assert: ( ( rows at: any ) at: 'rt' ) equals: any asString , '-ZZZ'.		self assert: ( ( rows at: any ) at: 1 ) equals: any.		self assert: ( ( rows at: any ) at: 3 ) equals: any asString , '-ZZZ'		].	self assert: ( rows last at: 'rk' ) equals: rowCount.	self assert: ( rows last at: 'rt' ) equals: rowCount asString , '-ZZZ'.	self assert: ( rows last at: 1 ) equals: rowCount.	self assert: ( rows last at: 3 ) equals: rowCount asString , '-ZZZ'! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testStatementReadOnly	| stmt |	self populateRowsInto: 'junk' of: db.	stmt := db prepare: 'select * from junk'.	self assert: stmt isReadOnly equals: true.	stmt := db prepare: 'delete from junk'.	self assert: stmt isReadOnly equals: false! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testValueInsertThenSelectInTransaction	"From GlorpDatabaseBasicTest>>testNameBinding."	self executeInDB: 'create table if not exists x (id integer , tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	db basicExecute: 'insert into x values (10, "abc")'.	db basicExecute: 'insert into x values (20, "def")'.	db basicExecute: 'insert into x values (30, "ghi")'.	rs := db execute: 'select * from x where id = ? or id = ?' value: 10 value: 30.	self assert: rs rows size equals: 2.	res := db rollbackTransaction.	self assert: res equals: 0! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!untestStatementInProgress	"XXX Doesn't work yet."	| s1 s2 |	res := db basicExecute: 'create table if not exists x (xk integer primary key, iv integer);'.	self assert: res equals: 0.	db beginTransaction.	s1 := db prepare: 'insert into x values (NULL, ?)'.	s1 at: 1 putInteger: 1.	"s1 step."	db execute: 'delete from x;'.	"self should: [ db rollbackTransaction ] raise: SQLite3Error."	db commitTransaction.	s1 reset.	s1 finalize! !!SQLite3DatabaseTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testPrintString	self assert: SQLite3Database memory printString equals: 'a SQLite3Database(":memory:")'! !!SQLite3RowTest methodsFor: 'running' stamp: '3/1/2025 19:01'!setUp	super setUp.	emptyRow := SQLite3Row new.	filledRow := SQLite3Row new columnNames: {'foo'. 'bar'. 'pi'}; yourself.	filledRow		at: 'foo' put: 1;		at: 'bar' put: true;		at: 'pi' put: '3.14'! !!SQLite3RowTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testAsArray	self assert: emptyRow asArray equals: #().	self assert: filledRow asArray equals: #(1 true '3.14')! !!SQLite3RowTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testAsCombinedDictionary	| dict  |	dict := Dictionary new.	dict at: 'foo' put: 1.	dict at: 'bar' put: true.	dict at: 'pi' put: '3.14'.	dict at: 1 put: 1.	dict at: 2 put: true.	dict at: 3 put: '3.14'.	self assert: emptyRow asCombinedDictionary equals: Dictionary new.	self assert: filledRow asCombinedDictionary equals: dict! !!SQLite3RowTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testAsDictionary	| dict  |	dict := Dictionary new.	dict at: 'foo' put: 1.	dict at: 'bar' put: true.	dict at: 'pi' put: '3.14'.	self assert: emptyRow asDictionary equals: Dictionary new.	self assert: filledRow asDictionary equals: dict! !!SQLite3RowTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testColumnAccessingIfAbsent	|blockExecutedFlag|	blockExecutedFlag := false.	filledRow at: 'foo' ifAbsent: [ blockExecutedFlag := true ].	self deny: blockExecutedFlag.	filledRow at: 'nope' ifAbsent: [ blockExecutedFlag := true ].	self assert: blockExecutedFlag! !!SQLite3RowTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testColumnAccessingOnEmptyRow	self assert: (emptyRow at: 'foo') equals: nil! !!SQLite3RowTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testColumnAccessingOnFilledRow	self assert: (filledRow at: 'foo') equals: 1.	self assert: (filledRow at: 'bar') equals: true.	self assert: (filledRow at: 'pi') equals: '3.14'.	self assert: (filledRow at: 'nope') equals: nil! !!SQLite3RowTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testColumnNamesOnEmptyRow	self assert: emptyRow columnNames equals: #()! !!SQLite3RowTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testColumnNamesOnFilledRow	self assert: filledRow columnNames equals: #('foo' 'bar' 'pi')! !!SQLite3RowTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testColumnPuttingOnEmptyRow	self assert: (emptyRow at: 'foo') equals: nil.	emptyRow at: 'foo' put: 42.	self assert: (emptyRow at: 'foo') equals: 42! !!SQLite3RowTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testColumnPuttingOnFilledRow	self assert: (filledRow at: 'foo') equals: 1.	filledRow at: 'foo' put: 2.	self assert: (filledRow at: 'foo') equals: 2! !!SQLite3TableBasedTest class methodsFor: 'testing' stamp: '3/1/2025 19:01'!isAbstract	^ self == SQLite3TableBasedTest! !!SQLite3TableBasedTest methodsFor: 'running' stamp: '3/1/2025 19:01'!setUp	super setUp.	db := SQLite3Database memory.	db connection open.	db connection execute: self tableCreationScript.	table := db tables first! !!SQLite3TableBasedTest methodsFor: 'accessing' stamp: '3/1/2025 19:01'!tableCreationScript	^ self subclassResponsibility! !!SQLite3TableBasedTest methodsFor: 'running' stamp: '3/1/2025 19:01'!tearDown	db connection close.	db := nil.	super tearDown! !!SQLite3TableBasedTest methodsFor: 'tests - sample' stamp: '3/1/2025 19:01'!testSampleTableSchema	self assert: table schema equals: self tableCreationScript! !!SQLite3TableTest methodsFor: 'accessing' stamp: '3/1/2025 19:01'!tableCreationScript	^'CREATE TABLE "SAMPLE"(    [ID] INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,    [NAME] NVARCHAR(120))'! !!SQLite3TableTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testName	| properties instance |	properties := Dictionary newFromPairs: #( #name 'SimpleTable' ).	instance := SQLite3Table properties: properties in: nil.	self assert: instance name equals: 'SimpleTable'! !!SQLite3TableTest methodsFor: 'tests - sample' stamp: '3/1/2025 19:01'!testNumberOfRows	self assert: table numberOfRows equals: 0! !!SQLite3TableTest methodsFor: 'tests - sample' stamp: '3/1/2025 19:01'!testNumberOfRowsIsOne	db execute: 'INSERT INTO SAMPLE(NAME) VALUES (''first example'');'.	self assert: table numberOfRows equals: 1! !!SQLite3TableTest methodsFor: 'tests - sample' stamp: '3/1/2025 19:01'!testNumberOfRowsIsTwo	db execute: 'INSERT INTO SAMPLE(NAME) VALUES (''first example''), (''second example'');'.	self assert: table numberOfRows equals: 2! !!SQLite3TableTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testPrintString	self assert: table printString equals: 'a SQLite3Table("SAMPLE")'! !!SQLite3TableTest methodsFor: 'tests - sample' stamp: '3/1/2025 19:01'!testRows	self assert: table rows isEmpty! !!SQLite3TableTest methodsFor: 'tests - sample' stamp: '3/1/2025 19:01'!testRowsHasOneRow	| rows |	db execute: 'INSERT INTO SAMPLE(NAME) VALUES (''first example'');'.	rows := table rows.	self deny: rows isEmpty.	self assert: rows size equals: 1.	self assert: (rows first at: 'NAME') equals: 'first example'! !!SQLite3TableTest methodsFor: 'tests - sample' stamp: '3/1/2025 19:01'!testRowsHasTwoRows	| rows |	db execute:		'INSERT INTO SAMPLE(NAME) VALUES (''first example''), (''second example'');'.	rows := table rows.	self deny: rows isEmpty.	self assert: rows size equals: 2.	self assert: (rows first at: 'NAME') equals: 'first example'.	self assert: (rows second at: 'NAME') equals: 'second example'! !!SQLite3TableTest methodsFor: 'tests - sample' stamp: '3/1/2025 19:01'!testSampleTable	self assert: table name equals: 'SAMPLE'! !!SQLite3TableTest methodsFor: 'tests - sample' stamp: '3/1/2025 19:01'!testSampleTableColumnNames	self assert: table columnNames size equals: 2! !!SQLite3TableTest methodsFor: 'tests - sample' stamp: '3/1/2025 19:01'!testSampleTableColumns	self assert: table columns size equals: 2! !!SQLite3TableTest methodsFor: 'tests - sample' stamp: '3/1/2025 19:01'!testSampleTableProperties	|props|	props := table properties.	self assert: props size equals: 5.	self assert: (props at: #type) equals: 'table'.	self assert: (props at: #tbl_name) equals: 'SAMPLE'.	self assert: (props at: #rootpage) equals: 2.	self assert: (props at: #name) equals: 'SAMPLE'.	self assert: (props at: #sql) equals: self tableCreationScript! !!SQLite3TableTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testUnitializedName	self assert: SQLite3Table new name equals: ''! !!SQLite3TableWithSpacesTest methodsFor: 'accessing' stamp: '3/1/2025 19:01'!tableCreationScript	^'CREATE TABLE "ANOTHER TABLE"(    [ID] INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,    [SOME NAME] NVARCHAR(120))'! !!SQLite3TableWithSpacesTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testColumnNameHasSpace	self assert: table columnNames size equals: 2.	self assert: table columnNames second equals: 'SOME NAME'! !!SQLite3TableWithSpacesTest methodsFor: 'tests' stamp: '3/1/2025 19:01'!testPrintStringHasTableNameWithSpace	self assert: table printString equals: 'a SQLite3Table("ANOTHER TABLE")'! !!ManifestSQLite3CoreTests class methodsFor: 'code coverage' stamp: '3/1/2025 19:01'!classNamesNotUnderTest	^ #( ManifestSQLite3CoreTests )! !!ManifestSQLite3CoreTests class methodsFor: 'code-critics' stamp: '3/1/2025 19:01'!ruleEmptyExceptionHandlerRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#SQLite3ConnectionTest #tearDown #false)) #'2022-05-10T08:25:11.111+02:00') #(#(#RGMethodDefinition #(#SQLite3BaseConnectionTest #tearDown #false)) #'2022-05-10T08:27:13.419+02:00') )! !!ManifestSQLite3CoreTests class methodsFor: 'code-critics' stamp: '3/1/2025 19:01'!ruleLiteralArrayContainsCommaRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#SQLite3BaseConnectionTest #deactivatedTestTracing #false)) #'2022-05-10T08:24:31.021+02:00') )! !!ManifestSQLite3CoreTests class methodsFor: 'code-critics' stamp: '3/1/2025 19:01'!ruleLiteralArrayContainsSuspiciousTrueFalseOrNilRuleV1FalsePositive	^ #(#(#(#RGMetaclassDefinition #(#'ManifestSQLite3CoreTests class' #ManifestSQLite3CoreTests)) #'2022-05-10T08:26:37.973+02:00') )! !"SQLite3-Core-Tests"!!SQLite3Row methodsFor: '*SQLite3-Inspector-Extensions' stamp: '3/1/2025 19:01'!inspectionSQLite3Row	<inspectorPresentationOrder: 10 title: 'SQlite3 - Contents'>	| presenter |	presenter := SpTablePresenter new.	presenter items: (Array with: self).	self columnNames do: [:each |		presenter addColumn: (SpStringTableColumn title: each evaluated: [ :assoc | self at: each ])	].	^presenter! !!SQLite3Database methodsFor: '*SQLite3-Inspector-Extensions' stamp: '3/1/2025 19:01'!inspectionSQLite3Tables	<inspectorPresentationOrder: 10 title: 'Sqlite3 - Tables'>	^ SpTablePresenter new		items: self tables;		addColumn: (SpStringTableColumn title: 'Name' evaluated: [ :assoc | assoc name ]);		addColumn: (SpStringTableColumn title: 'Number of rows' evaluated: [ :assoc | assoc numberOfRows ]);		yourself! !!AbstractFileReference methodsFor: '*SQLite3-Inspector-Extensions' stamp: '3/1/2025 19:01'!databaseSize	|s|	s := self size.	s / 1024 > 1024 ifTrue: [ ^ ((s / 1024 / 1024) roundDownTo: 0.01) asString, ' MB' ].	^ ((s / 1024) roundDownTo: 0.01) asString, ' KB'! !!AbstractFileReference methodsFor: '*SQLite3-Inspector-Extensions' stamp: '3/1/2025 19:01'!inspectionSQLite3Info	<inspectorPresentationOrder: -2 title: 'SQLite3 - Info'>	| label1 label2 |	label1 := SpLabeledPresenter		          label: 'Database file:'		          input: (SpTextInputFieldPresenter new text: self fullName).	label2 := SpLabeledPresenter		          label: 'Database size:'		          input: (SpTextInputFieldPresenter new text: self databaseSize).	^ SpPresenter new		  layout: (SpBoxLayout newTopToBottom				   add: label1;					add: label2;				   yourself);		  yourself! !!AbstractFileReference methodsFor: '*SQLite3-Inspector-Extensions' stamp: '3/1/2025 19:01'!inspectionSQLite3InfoContext: aContext	^ aContext active: self isSQlite3Database! !!AbstractFileReference methodsFor: '*SQLite3-Inspector-Extensions' stamp: '3/1/2025 19:01'!inspectionSQLite3Tables	<inspectorPresentationOrder: -1 title: 'SQLite3 - Tables'>	^ SpTablePresenter new			items: (SQLite3Database tableInfoFor: self fullName);			addColumn: (SpStringTableColumn title: 'Table Name' evaluated: [ :assoc | assoc name ]);			addColumn: (SpStringTableColumn title: 'Number of Rows' evaluated: [ :assoc | assoc numberOfRows ]);			yourself! !!AbstractFileReference methodsFor: '*SQLite3-Inspector-Extensions' stamp: '3/1/2025 19:01'!inspectionSQLite3TablesContext: aContext	^ aContext active: self isSQlite3Database! !!AbstractFileReference methodsFor: '*SQLite3-Inspector-Extensions' stamp: '3/1/2025 19:01'!isSQlite3Database	"Return true if the reference is an SQLite3 database file"	^ self isFile and: [		  self extension = 'db' and: [			  (self readStreamDo: [ :s | s next: 16 ])			  = ('SQLite format 3' , Character null asString) ] ]! !!SQLite3Table methodsFor: '*SQLite3-Inspector-Extensions' stamp: '3/1/2025 19:01'!inspectionSQLite3Columns	<inspectorPresentationOrder: 13 title: 'SQLite3 - Columns'>	^ SpTablePresenter new		items: self columns;		addColumn: (SpStringTableColumn title: 'Column Name' evaluated: [ :each | each name ]);		addColumn: (SpStringTableColumn title: 'Column Type' evaluated: [ :each | each type ]);		addColumn: (SpStringTableColumn title: 'Non-empty values' evaluated: [ :each | each hasNotNullConstraint ifTrue: ['NOT NULL'] ifFalse: [''] ]);		yourself! !!SQLite3Table methodsFor: '*SQLite3-Inspector-Extensions' stamp: '3/1/2025 19:01'!inspectionSQLite3Data	<inspectorPresentationOrder: 11 title: 'SQLite3 - Data'>	| presenter |	presenter := SpTablePresenter new.	presenter items: self rows.	self columnNames do: [:col |		presenter addColumn: (SpStringTableColumn title: col evaluated: [ :each | each at: col ])	 ].	^presenter! !!SQLite3Table methodsFor: '*SQLite3-Inspector-Extensions' stamp: '3/1/2025 19:01'!inspectionSQLite3Schema	<inspectorPresentationOrder: 10 title: 'SQLite3 - Schema'>	^ SpTextPresenter new		text: self schema;		yourself! !!SQLite3Table methodsFor: '*SQLite3-Inspector-Extensions' stamp: '3/1/2025 19:01'!inspectionSQLite3TableProperties	<inspectorPresentationOrder: 40 title: 'SQLite3 - Table Properties'>	^ SpTablePresenter new		items: self properties associations;		addColumn: (SpStringTableColumn title: 'Property' evaluated: [ :assoc | assoc key ]);		addColumn: (SpStringTableColumn title: 'Value' evaluated: [ :assoc | assoc value ]);		yourself! !"SQLite3-Inspector-Extensions"!----SNAPSHOT----2025-03-01T19:13:54.339007-05:00 Pharo 12.0 - 64bit (stable).1.image priorSource: 313!----SNAPSHOT----2025-03-01T19:13:54.33939-05:00 Pharo 12.0 - 64bit (stable).1.image priorSource: 202473!!BaselineOfZincHTTPComponents commentStamp: 'SvenVanCaekenberghe 7/5/2020 16:32' prior: 0!I am BaselineOfZincHTTPComponents.I am a BaselineOf.I am used to load the Zinc HTTP Components project from GitHub as in   Metacello new    repository: 'github://svenvc/zinc/repository';    baseline: 'ZincHTTPComponents';    load.The following groups are available to load: - default (Core & Tests) - Core (Zinc-HTTP Zinc-HTTP-Examples Zinc-Zodiac-Core) - Tests (Zinc-Tests Zinc-Character-Encoding-Tests Zinc-Resource-Meta-Tests Zodiac-Tests Zinc-Zodiac-Tests) - Character-Encoding - Resource-Meta - Zodiac - AWS - WebDAV - WebSocket - SSO-OAuth1 - SSO-OAuth2 - SSO-OpenID - SSO-Demo - SSO (SSO-OAuth1 SSO-OAuth2 SSO-OpenID SSO-Demo Zinc-SSO-Demo) - WWS (Zinc-WWS-Server Zinc-WWS-Client) - REST - Server-Sent-EventsSee also https://github.com/svenvc/zincPart of Zinc HTTP Components.!!BaselineOfZincHTTPComponents methodsFor: 'baselines' stamp: '8/31/2024 04:18:34'!baseline: spec	<baseline>	spec for: #common do: [		spec baseline: 'NeoJSON' with: [ spec repository: 'github://svenvc/NeoJSON:master/repository' ].		spec baseline: 'XMLParser' with: [ spec repository: 'github://pharo-contributions/XML-XMLParser:master/src' ].		spec package: 'Zodiac-Core' with: [ spec repository: 'github://svenvc/zodiac:master/repository' ].		spec package: 'Zodiac-Tests' with: [ spec repository: 'github://svenvc/zodiac:master/repository' ].		spec			package: 'Zinc-Character-Encoding-Core';			package: 'Zinc-Character-Encoding-Tests' with: [ spec requires: 'Zinc-Character-Encoding-Core' ];			package: 'Zinc-Resource-Meta-Core' with: [ spec requires: 'Zinc-Character-Encoding-Core' ];			package: 'Zinc-Resource-Meta-Tests' with: [ spec requires: 'Zinc-Resource-Meta-Core' ];			package: 'Zinc-HTTP' with: [ 				spec postLoadDoIt: #recompileZnLogEventHierarchy; requires: #('Zinc-Character-Encoding-Core' 'Zinc-Resource-Meta-Core') ];			package: 'Zinc-HTTP-Examples' with: [ spec requires: #('Zinc-HTTP') ];			package: 'Zinc-Tests' with: [ spec requires: 'Zinc-HTTP' ];			package: 'Zinc-Zodiac-Core' with: [ spec requires: #('Zinc-HTTP' 'Zodiac-Core') ];			package: 'Zinc-Zodiac-Tests' with: [ spec requires:  #('Zinc-Zodiac-Core') ].		spec			package: 'Zinc-AWS' with: [ spec requires: #('Zinc-HTTP' 'XMLParser') ];			package: 'Zinc-REST' with: [ spec requires: #('Zinc-HTTP' 'NeoJSON') ];			package: 'Zinc-WebSocket-Core' with: [ spec requires: 'Zinc-HTTP' ];			package: 'Zinc-WebSocket-Tests' with: [ spec requires: 'Zinc-WebSocket-Core' ];			package: 'Zinc-SSO-OAuth1-Core' with: [ spec requires: #('Zinc-HTTP' 'NeoJSON') ];			package: 'Zinc-SSO-OAuth2-Core' with: [ spec requires: #('Zinc-HTTP' 'NeoJSON') ];			package: 'Zinc-SSO-OpenID-Core' with: [ spec requires: #('Zinc-HTTP' 'XMLParser') ];			package: 'Zinc-SSO-Demo' with: [ spec requires: #('Zinc-SSO-OAuth1-Core' 'Zinc-SSO-OAuth2-Core' 'Zinc-SSO-OpenID-Core') ];			package: 'Zinc-SSO-OAuth1-Tests' with: [ spec requires: #('Zinc-SSO-OAuth1-Core') ];			package: 'Zinc-SSO-OpenID-Tests' with: [ spec requires: #('Zinc-SSO-OpenID-Core') ];			package: 'Zinc-WebDAV' with: [ spec requires: 'Zinc-HTTP' ];			package: 'Zinc-WWS-Server' with: [ spec requires: 'Zinc-HTTP' ];			package: 'Zinc-WWS-Client' with: [ spec requires: 'Zinc-HTTP' ];			package: 'Zinc-Server-Sent-Events' with: [ spec requires: 'Zinc-HTTP' ].		spec			group: 'default' with: #('Core' 'Tests');			group: 'Core' with: #('Zinc-HTTP' 'Zinc-HTTP-Examples' 'Zinc-Zodiac-Core');			group: 'Tests' with: #('Zinc-Tests' 'Zinc-Character-Encoding-Tests' 'Zinc-Resource-Meta-Tests' 'Zodiac-Tests' 'Zinc-Zodiac-Tests');			group: 'Character-Encoding' with: #('Zinc-Character-Encoding-Core' 'Zinc-Character-Encoding-Tests');			group: 'Resource-Meta' with: #('Zinc-Resource-Meta-Core' 'Zinc-Resource-Meta-Tests');			group: 'Zodiac' with: #('Zodiac-Core' 'Zodiac-Tests');			group: 'AWS' with: #('Zinc-AWS');			group: 'WebDAV' with: #('Zinc-WebDAV');			group: 'WebSocket' with: #('Zinc-WebSocket-Core' 'Zinc-WebSocket-Tests');			group: 'SSO-OAuth1' with: #('Zinc-SSO-OAuth1-Core' 'Zinc-SSO-OAuth1-Tests');			group: 'SSO-OAuth2' with: #('Zinc-SSO-OAuth2-Core');			group: 'SSO-OpenID' with: #('Zinc-SSO-OpenID-Core' 'Zinc-SSO-OpenID-Tests');			group: 'SSO-Demo' with: #('Zinc-SSO-OAuth1-Core' 'Zinc-SSO-OAuth2-Core' 'Zinc-SSO-OpenID-Core');			group: 'SSO' with: #('SSO-OAuth1' 'SSO-OAuth2' 'SSO-OpenID' 'SSO-Demo' 'Zinc-SSO-Demo');			group: 'WWS' with: #('Zinc-WWS-Server' 'Zinc-WWS-Client');			group: 'REST' with: #('Zinc-REST');			group: 'Server-Sent-Events' with: #('Zinc-Server-Sent-Events') ]! !!BaselineOfZincHTTPComponents methodsFor: 'doits' stamp: '8/31/2024 04:18:34'!recompileZnLogEventHierarchy	"This is a hack, but somehow there is something wrong in the instance variables layout, 	which can only be fixed by recompiling, which should happen but doesn't, so force it."	ZnLogEvent withAllSubclassesDo: #recompile! !"BaselineOfZincHTTPComponents"!!ZdcUtils commentStamp: 'Anonymous 6/16/2024 18:13' prior: 0!I am ZdcUtils.!!ZdcAbstractSocketStream methodsFor: 'private - socket' stamp: '6/16/2024 11:15:59' prior: 83227256!socketWaitForSendDone	"Compatibility shim for Pharo <11, where #waitForSendDone: returns a boolean	indicating success, rather than signaling exceptions on failure.	A true return (in P11) or nothing/self (in P12) both indicate success,	so check for specifically false."	(socket waitForSendDoneFor: self timeout) == false ifTrue: [		ConnectionTimedOut signal: 'Data send timed out.' ]! !!ZdcPluginSSLSession methodsFor: 'initialization' stamp: '6/16/2024 11:15:59' prior: 83322274!initialize	"Initialize the receiver"	[ handle := self primitiveSSLCreate ]		on: (ZdcUtils exceptionSet: #( #SocketError #PrimitiveFailed ))		do: [ :exception |			"Give a more human friendly error message"			ZdcPluginMissing signal ].	self logging: false! !!ZdcSimpleSocketStream methodsFor: 'private - out' stamp: '6/16/2024 11:15:59' prior: 83367484!flushBytes: bytes startingAt: offset count: count	"Ask the socket to write count bytes starting from offset. Wait. Fail if not successful"	| writeCount |	self isConnected ifFalse: [ ConnectionClosed signal: 'Cannot write data' ].	writeCount := 0.	[ | written |		written := self socketSendData: bytes startingAt: offset + writeCount count: count - writeCount.		(writeCount := writeCount + written) = count ] whileFalse: [		self socketWaitForSendDone ]! !!ZdcSecureSocketStream methodsFor: 'testing' stamp: '6/16/2024 11:15:59' prior: 83349316!atEnd	"I am atEnd when there is no more data to be read and there never will be.	This means that readBuffer must be empty, there must be no more unread data	available at the socket, and the socket must be closed"	readBuffer isEmpty ifFalse: [ ^ false ].	socket notNil		ifTrue: [			"Try reading (there might stil be data in the SSL session) and test again"			[ self fillReadBufferNoWait ]				on: ConnectionClosed				do: [ ^ true ].			readBuffer isEmpty ifFalse: [ ^ false ] ].	^ self isConnected not! !!ZdcSecureSocketStream methodsFor: 'testing' stamp: '6/16/2024 11:15:59' prior: 83360526!isDataAvailable	"Return true when there is data available for reading.	This does not block."	readBuffer isEmpty ifFalse: [ ^ true ].	socket notNil		ifTrue: [			"Try reading (there might stil be data in the SSL session) and test again"			[ self fillReadBufferNoWait ]				on: ConnectionClosed				do: [ ^ false ].			readBuffer isEmpty ifFalse: [ ^ true ] ].	^ false! !!ZdcUtils class methodsFor: 'converting' stamp: '6/16/2024 11:15:59'!exceptionSet: classNames	^ classNames inject: ExceptionSet new into: [ :set :each |		  (Smalltalk globals includesKey: each)			  ifTrue: [				  set					  add: (Smalltalk at: each);					  yourself ]			  ifFalse: [ set ] ]! !"Zodiac-Core"!!ZdcPluginSSLSessionTest methodsFor: 'tests' stamp: '6/16/2024 11:15:59' prior: 83325078!testServerName	[ session serverName; serverName: nil ] 		on: (ZdcUtils exceptionSet: #( #SocketError #PrimitiveFailed )) 		do: [ ^ self skip ].	self assert: session serverName equals: nil.	session serverName: 'pharo.org'.	self assert: session serverName equals: 'pharo.org'.	session serverName: 'smalltalkhub.com'.	self assert: session serverName equals: 'smalltalkhub.com'.	session serverName: nil.	self assert: session serverName equals: nil! !"Zodiac-Tests"!!ZnLossyUTF8Encoder commentStamp: '<historical>' prior: 0!I am ZnLossyUTF8Decoder.I am a ZnUTF8Decoder.I behave like my superclass but will not signal errors when I see illegal UTF-8 encoded input,instead I will output a Unicode Replacement Character (U+FFFD) for each error.In contrast to my superclass I can read any random byte sequence, decoding both legal and illegal UTF-8 sequences. Due to my stream based design and usage as well as my stateless implementation,  I will output multiple replacement characters when multiple illegal sequences occur.  My convenience method #decodeBytesSingleReplacement: shows how to decode bytes so that  only a single replacement character stands for any amount of illegal encoding between legal encodings. Part of Zinc HTTP Components.!!Stream methodsFor: '*Zinc-Character-Encoding-Core' stamp: '8/31/2024 04:18:34'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Since this the base stream, answer ourself."	^ self! !!Stream methodsFor: '*Zinc-Character-Encoding-Core' stamp: '8/31/2024 04:18:34'!wrappedStream	"Answer the stream that the receiver wraps.	Since this the base stream, answer nil"	^ nil! !!ZnBufferedReadWriteStream methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!SocketStream methodsFor: '*Zinc-Character-Encoding-Core' stamp: '8/31/2024 04:18:34'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Since this the base stream, answer ourself."	^ self! !!SocketStream methodsFor: '*Zinc-Character-Encoding-Core' stamp: '8/31/2024 04:18:34'!wrappedStream	"Answer the stream that the receiver wraps.	Since this the base stream, answer nil"	^ nil! !!ZnPositionableReadStream methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnEncodedReadStream class methodsFor: 'testing' stamp: '8/31/2024 04:18:34'!isAbstract	^ self == ZnEncodedReadStream! !!ZnEncodedReadStream methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!collectionSpecies	^ self subclassResponsibility! !!ZnUTF16Encoder methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!byteOrderMarkLE	"My little endian sequence of the Unicode BOM. See #byteOrderMark"		^ 16rFFFE! !!ZnUTF16Encoder methodsFor: 'encoding - decoding' stamp: '8/31/2024 04:18:34' prior: 85217420!nextCodePointFromStream: stream	"Read and return the next integer code point from stream"	| word leadSurrogate trailSurrogate code |	word := self read16BitWordFromStream: stream.	((self processByteOrderMark: word) and: [ self ignoreByteOrderMark ])		ifTrue: [ word := self read16BitWordFromStream: stream ].	^ (word < 16rD800 or: [ word > 16rDBFF ])		ifTrue: [			word ]		ifFalse: [			leadSurrogate := word.			trailSurrogate := self read16BitWordFromStream: stream.			code := (leadSurrogate - 16rD800) * 16r400 + (trailSurrogate - 16rDC00).			16r10000 + code ]! !!ZnUTF16Encoder methodsFor: 'private' stamp: '8/31/2024 04:18:34' prior: 85220926!processByteOrderMark: word	^ (word = self byteOrderMark or: [ word = self byteOrderMarkLE ])		ifTrue: [			word = self byteOrderMarkLE 				ifTrue: [ self swapEndianness ].			true ]		ifFalse: [ false ]! !!ZnBufferedWriteStream methodsFor: 'initialize-release' stamp: '8/31/2024 04:18:34'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnBufferedWriteStream methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!reset	self flushBuffer.	stream reset! !!ZnBufferedWriteStream methodsFor: 'initialize-release' stamp: '8/31/2024 04:18:34'!wrappedStream	^ stream! !!ZnCharacterEncoder class methodsFor: 'testing' stamp: '8/31/2024 04:18:34'!isAbstract	^ self == ZnCharacterEncoder! !!ZnEndianSensitiveUTFEncoder class methodsFor: 'testing' stamp: '8/31/2024 04:18:34'!isAbstract	^ self = ZnEndianSensitiveUTFEncoder! !!ZnEndianSensitiveUTFEncoder class methodsFor: 'instance creation' stamp: '8/31/2024 04:18:34' prior: 84338906!newForEncoding: string	"Return a new character encoder object for an encoding described by string.	Try to infer endianness from string, defaulting to big endian."	| encoder |	encoder := self new.	encoder identifier: string.	(string asLowercase endsWith: 'be') ifTrue: [ encoder beBigEndian ].	(string asLowercase endsWith: 'le') ifTrue: [ encoder beLittleEndian ].	^ encoder! !!ZnEndianSensitiveUTFEncoder methodsFor: 'comparing' stamp: '8/31/2024 04:18:34' prior: 84337022!= anObject	^ super = anObject and: [ self identifier == anObject identifier ]! !!ZnEndianSensitiveUTFEncoder methodsFor: 'comparing' stamp: '8/31/2024 04:18:34' prior: 84336316!hash	^ self identifier hash! !!ZnEndianSensitiveUTFEncoder methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!identifier	^ identifier! !!ZnEndianSensitiveUTFEncoder methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!identifier: anObject	identifier := anObject! !!ZnEndianSensitiveUTFEncoder methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 84337344!printOn: stream	super printOn: stream.	stream nextPut: $(.	stream print: self identifier asString; space.	stream nextPutAll: endianness; nextPutAll: ' endian'.	stream nextPut: $)! !!ZnUTFEncoder class methodsFor: 'testing' stamp: '8/31/2024 04:18:34'!isAbstract	^ self = ZnUTFEncoder ! !!ZnUTFEncoder methodsFor: 'accessing' stamp: '8/31/2024 04:18:34' prior: 85254212!byteOrderMark	"The code point of the Unicode Byte-Order-Mark or BOM character.	This is the big endian sequence.	See https://en.wikipedia.org/wiki/Byte_order_mark"	^ 16rFEFF! !!ZnUTFEncoder methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!ignoreByteOrderMark	"Return true when I ignore Unicode byte-order mark (BOM) occurences that I read (the default)."		^ ignoreByteOrderMark ifNil: [ ignoreByteOrderMark := true ]! !!ZnUTFEncoder methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!ignoreByteOrderMark: boolean	"When boolean is true I ignore Unicode byte-order mark (BOM) occurences that I read (the default)."	ignoreByteOrderMark := boolean! !!ZnBufferedReadStream methodsFor: 'accessing' stamp: '8/31/2024 04:18:34' prior: 83714868!back	"Move backwards one element and return it"	^ position > limit		ifTrue: [			stream back ]		ifFalse: [ | targetPosition bufferPosition char |			position = 1 ifTrue:				[ stream position = 0 ifTrue:					[ self error: 'Cannot move back from beginning' ]				ifFalse:					[ targetPosition := self position - 1.					"Assume that the caller may want to go back a few elements before reading forward again"					bufferPosition := targetPosition - 10 max: 0.					self position: bufferPosition.					self nextBuffer.					self position: targetPosition.					self peek ] ]			ifFalse:				[ char := buffer at: position.				position := position - 1.				char ] ]! !!ZnBufferedReadStream methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnBufferedReadStream methodsFor: 'accessing' stamp: '8/31/2024 04:18:34' prior: 83698650!readInto: collection startingAt: offset count: requestedCount	"Read requestedCount elements into collection starting at offset,	answering the number of elements read, there could be fewer elements available."	| countRead countYetToRead |	"First, read from elements already in my buffer."	countRead := self readFromBufferInto: collection startingAt: offset count: requestedCount.	countYetToRead := requestedCount - countRead.	countYetToRead > 0		ifTrue: [ "See if there are more elements to be read from the underlying stream"			| newOffset |			newOffset := offset + countRead.			(self shouldBufferReadOfCount: countYetToRead)				ifTrue: [					self nextBuffer.					limit > 0						ifTrue: [ countRead := countRead + (self readInto: collection startingAt: newOffset count: countYetToRead) ] ]				ifFalse: [					self discardBuffer.					countRead := countRead + (stream readInto: collection startingAt: newOffset count: countYetToRead) ] ].	^ countRead! !!ZnEncodedWriteStream class methodsFor: 'testing' stamp: '8/31/2024 04:18:34'!isAbstract	^ self == ZnEncodedWriteStream! !!ZnNullEncoder methodsFor: 'accessing' stamp: '8/31/2024 04:18:34' prior: 84775526!identifier	^ #null! !!ZnEncodedStream class methodsFor: 'testing' stamp: '8/31/2024 04:18:34'!isAbstract	^ self == ZnEncodedStream! !!ZnEncodedStream methodsFor: 'testing' stamp: '8/31/2024 04:18:34'!isBinary	^ false! !!ZnEncodedStream methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnEncodedStream methodsFor: 'initialization' stamp: '8/31/2024 04:18:34'!reset	^ stream reset! !!ZnLossyUTF8Encoder class methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!handlesEncoding: string	"Return true when my instances handle the encoding described by string"	^ (self canonicalEncodingIdentifier: string) = 'utf8lossy'! !!ZnLossyUTF8Encoder class methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!knownEncodingIdentifiers	^ #( utf8lossy )! !!ZnLossyUTF8Encoder methodsFor: 'convenience' stamp: '8/31/2024 04:18:34'!decodeBytesSingleReplacement: bytes	"Decode bytes and return the resulting string.	This variant of #decodeBytes: will only ever use 	a single replacement character for each illegal UTF-8 sequence"	| byteStream replaced replacement char |	byteStream := bytes readStream.	replaced := false.	replacement := self replacementCodePoint asCharacter.	^ String streamContents: [ :stream |		[ byteStream atEnd ] whileFalse: [			char := self nextFromStream: byteStream.			char = replacement				ifTrue: [					replaced 						ifFalse: [							replaced := true.							stream nextPut: replacement ] ]				ifFalse: [					replaced := false.					stream nextPut: char ] ] ]! !!ZnLossyUTF8Encoder methodsFor: 'error handling' stamp: '8/31/2024 04:18:34'!errorIllegalContinuationByte	^ self replacementCodePoint! !!ZnLossyUTF8Encoder methodsFor: 'error handling' stamp: '8/31/2024 04:18:34'!errorIllegalLeadingByte	^ self replacementCodePoint! !!ZnLossyUTF8Encoder methodsFor: 'error handling' stamp: '8/31/2024 04:18:34'!errorIncomplete	^ self replacementCodePoint! !!ZnLossyUTF8Encoder methodsFor: 'error handling' stamp: '8/31/2024 04:18:34'!errorOutsideRange	^ self replacementCodePoint! !!ZnLossyUTF8Encoder methodsFor: 'error handling' stamp: '8/31/2024 04:18:34'!errorOverlong	^ self replacementCodePoint! !!ZnLossyUTF8Encoder methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!identifier	^ #utf8lossy! !!ZnLossyUTF8Encoder methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!replacementCodePoint	"Return the code point for the Unicode Replacement Character U+FFFD"		^ 16rFFFD! !!ZnUTF8Encoder methodsFor: 'encoding - decoding' stamp: '8/31/2024 04:18:34' prior: 85245414!ensureAtBeginOfCodePointOnStream: stream	"Ensure that the current position of stream is a the beginning of an encoded code point,	if not move further backwards. This is necessary when a position in the binary stream is set,	not knowing if that position is on a proper encoded character boundary."	"If we are at end-of-stream, we can't be in the middle of an encoded codepoint	(unless that codepoint is incomplete and thus invalid, which we won't worry about)"	stream atEnd ifTrue: [ ^ self ].	"Back up until we are not longer on a continuation byte but on a leading byte"	[ (stream peek bitAnd: 2r11000000) == 2r10000000 ] whileTrue: [ stream back ]! !!ZnUTF8Encoder methodsFor: 'encoding - decoding' stamp: '8/31/2024 04:18:34' prior: 85240972!nextCodePointFromStream: stream	"Read and return the next integer code point from stream"	| code byte next |	(byte := stream next ifNil: [ ^ self errorIncomplete ]) < 128		ifTrue: [ ^ byte ].	(byte bitAnd: 2r11100000) == 2r11000000		ifTrue: [			code := byte bitAnd: 2r00011111.			((next := stream next ifNil: [ ^ self errorIncomplete ]) bitAnd: 2r11000000) == 2r10000000				ifTrue: [ code := (code bitShift: 6) + (next bitAnd: 2r00111111) ]				ifFalse: [ ^ self errorIllegalContinuationByte ].			code < 128 ifTrue: [ ^ self errorOverlong ].			^ code ].	(byte bitAnd: 2r11110000) == 2r11100000		ifTrue: [			code := byte bitAnd: 2r00001111.			2 timesRepeat: [				((next := stream next ifNil: [ ^ self errorIncomplete ]) bitAnd: 2r11000000) == 2r10000000					ifTrue: [ code := (code bitShift: 6) + (next bitAnd: 2r00111111) ]					ifFalse: [ ^ self errorIllegalContinuationByte ] ].			code < 2048 ifTrue: [ ^ self errorOverlong ].			(self isSurrogateCodePoint: code) ifTrue: [ ^ self errorOutsideRange ].			(code = self byteOrderMark and: [ self ignoreByteOrderMark ]) ifTrue: [				stream atEnd ifTrue: [ ^ self errorIncomplete ].				^ self nextCodePointFromStream: stream ].			^ code ].	(byte bitAnd: 2r11111000) == 2r11110000		ifTrue: [			code := byte bitAnd: 2r00000111.			3 timesRepeat: [				((next := stream next ifNil: [ ^ self errorIncomplete ]) bitAnd: 2r11000000) == 2r10000000					ifTrue: [ code := (code bitShift: 6) + (next bitAnd: 2r00111111) ]					ifFalse: [ ^ self errorIllegalContinuationByte ] ].			code < 65535 ifTrue: [ ^ self errorOverlong ].			code > self maximumUTFCode ifTrue: [ self errorOutsideRange ].			^ code ].	^ self errorIllegalLeadingByte! !!ZnNewLineWriterStream methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnNewLineWriterStream methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!wrappedStream	^ stream! !!ZnUTF32Encoder methodsFor: 'private' stamp: '8/31/2024 04:18:34'!byteOrderMarkLE	"My little endian sequence of the Unicode BOM. See #byteOrderMark"		^ 16rFFFE0000! !!ZnUTF32Encoder methodsFor: 'encoding - decoding' stamp: '8/31/2024 04:18:34' prior: 85230430!nextCodePointFromStream: stream	"Read and return the next integer code point from stream"	| codePoint |	codePoint := self readCodePointFrom: stream.	((self processByteOrderMark: codePoint) and: [ self ignoreByteOrderMark ])		ifTrue: [ codePoint := self readCodePointFrom: stream ].	((self isSurrogateCodePoint: codePoint) or: [ codePoint > self maximumUTFCode ])		ifTrue: [ ^ self errorOutsideRange ].	^ codePoint! !!ZnUTF32Encoder methodsFor: 'private' stamp: '8/31/2024 04:18:34' prior: 85225694!processByteOrderMark: codePoint	^ (codePoint = self byteOrderMark or: [ codePoint = self byteOrderMarkLE ])		ifTrue: [			codePoint = self byteOrderMarkLE 				ifTrue: [ self swapEndianness ].			true ]		ifFalse: [ false ]! !ZnUTF16Encoder removeSelector: #identifier!ZnUTF32Encoder removeSelector: #identifier!ZnEncodedWriteStream removeSelector: #isBinary!ZnEncodedReadStream removeSelector: #isBinary!"Zinc-Character-Encoding-Core"!!ZnCharacterEncoderTest methodsFor: 'testing' stamp: '8/31/2024 04:18:34' prior: 83929808!testKnownEncodingIdentifiers	| all minimal asciiString notSelfIdentifying|	all := ZnCharacterEncoder knownEncodingIdentifiers asSet.	minimal := #(utf8 latin1 null ascii iso88591) asSet.	"make sure at least a minimal set is present"	self assert: (all intersection: minimal) equals: minimal.	asciiString := String withAll: ($a to: $z) , ($A to: $Z) , ($0 to: $9).	"make sure that each identifier can be used to instanciate a decoder,	and that those decoders at least work on a ASCII string in both directions"	all do: [ :each |		| encoder bytes |		encoder := ZnCharacterEncoder newForEncoding: each.		bytes := encoder encodeString: asciiString.		self assert: (encoder decodeBytes: bytes) equals: asciiString ].	"make sure identifiers are preserved"	notSelfIdentifying := ZnCharacterEncoder knownEncodingIdentifiers reject: [ :each | 		each asZnCharacterEncoder identifier = each ].	self assert: notSelfIdentifying isEmpty! !!ZnCharacterEncoderTest methodsFor: 'testing' stamp: '8/31/2024 04:18:34'!testLossyUTF8	| encoder replacement |	encoder := ZnLossyUTF8Encoder new.	self assert: #utf8lossy asZnCharacterEncoder equals: encoder.	replacement := encoder replacementCodePoint asCharacter.	self 		assert: (#[65 160 66] decodeWith: encoder) 		equals: ({ $A. replacement . $B } as: String).	self 		assert: (#[16rE1 16rA0 16rC0] decodeWith: encoder) 		equals: replacement asString.	self 		assert: (encoder decodeBytes: #[16r41 16rA1 16rA2 16rA3 16r42]) 		equals: ({ $A. replacement . replacement . replacement . $B } as: String).	self 		assert: (encoder decodeBytesSingleReplacement: #[16r41 16rA1 16rA2 16rA3 16r42])		equals: ({ $A. replacement . $B } as: String).! !!ZnCharacterEncoderTest methodsFor: 'testing' stamp: '8/31/2024 04:18:34'!testLossyUTF8Random	| bytes string |	bytes := ((1 to: 10000) collect: [ :_ | 256 atRandom - 1 ]) asByteArray.	string := bytes decodeWith: ZnLossyUTF8Encoder new.	self assert: string isString! !!ZnCharacterEncoderTest methodsFor: 'testing' stamp: '8/31/2024 04:18:34'!testUTF8ByteOrderMarkSignificant	| input encoder result |	input := #[16r41 16rEF 16rBB 16rBF 16r42].	encoder := ZnUTF8Encoder new.	encoder ignoreByteOrderMark: false.	result := encoder decodeBytes: input.	self assert: result first equals: $A.	self assert: result second equals: encoder byteOrderMark asCharacter.	self assert: result third equals: $B! !!ZnBufferedWriteStreamTest methodsFor: 'tests' stamp: '8/31/2024 04:18:34'!testWritingReset	| file writeStream readStream |	file := 'test.txt' asFileReference ensureCreateFile.	writeStream := file binaryWriteStream.	writeStream nextPutAll: 'pedro'.	writeStream reset.	writeStream nextPutAll: 'pha'.	writeStream close.	readStream := file readStream.	self assert: readStream contents equals: 'pharo'! !!ZnCharacterStreamTest methodsFor: 'tests' stamp: '8/31/2024 04:18:34'!testReset	| stream |	stream := ZnCharacterReadStream on: 'abc' asByteArray readStream.	self assert: stream next equals: $a.	stream reset.	self assert: stream next equals: $a! !!ZnCharacterStreamTest methodsFor: 'tests' stamp: '8/31/2024 04:18:34' prior: 83984082!testUTF8ReadStreamPositioning	| bytes stream |	bytes := 'lve' utf8Encoded.	stream := ZnCharacterReadStream on: bytes readStream.	self assert: stream position equals: 0.	stream position: 0.	self assert: stream next equals: $.	stream position: 1.	self assert: stream next equals: $.	stream position: 2.	self assert: stream next equals: $l.	stream position: 3.	self assert: stream next equals: $.	stream position: 4.	self assert: stream next equals: $.	stream position: 5.	self assert: stream next equals: $v.	stream position: 6.	self assert: stream next equals: $e.	stream position: 7.	self assert: stream atEnd.! !"Zinc-Character-Encoding-Tests"!!ZnDataUrl commentStamp: 'SvenVanCaekenberghe 10/6/2023 18:45' prior: 0!I am ZnDataUrl, I implement the Data URI scheme as defined in RFC 2397.I am like a URL/URI, but as an immediate value. As such I encapsulate a mime type and data. The data can optionally be base64 encoded, which is needed for non textual types.Note that there is a difference between my external and internal representation. See #printOn: and #parseFrom:References- https://en.wikipedia.org/wiki/Data_URI_scheme- https://datatracker.ietf.org/doc/html/rfc2397!!ZnMimeType methodsFor: 'testing' stamp: '8/31/2024 04:18:34' prior: 84647566!isBinary	"Answers whether the contents of a resource described by me	should be considered as binary instead of textual."		| subParts |	self main = 'text'		ifTrue: [ ^ false ].	subParts := self sub substrings: '+-'.	(subParts anySatisfy: [ :subPart |				self class textSubTypeFragments includes: subPart ])		ifTrue: [ ^ false ].	(subParts anySatisfy: [ :subPart | 				self class textSubTypeFragments anySatisfy: [ :fragment | 						subPart includesSubstring: fragment ] ])		ifTrue: [ ^ false ].	^ true! !!ZnDataUrl class methodsFor: 'instance creation' stamp: '8/31/2024 04:18:34'!bytes: bytes type: mimeType	"self bytes: #[71 73 70 56 55 97 48 0 48 0 240 0 0 0 0 0 255 255 255 44 0 0 0 0 48 0 48 0 0 2 240 140 143 169 203 237 223 0 156 14 72 139 115 176 180 171 12 134 30 20 150 166 52 46 231 42 166 9 139 26 167 43 175 81 73 111 56 217 142 102 215 243 128 92 193 201 48 117 209 8 49 57 29 19 168 20 30 142 20 77 204 231 228 84 159 185 98 37 42 173 113 121 99 153 74 135 240 222 184 215 15 231 34 214 26 193 27 180 184 142 74 150 191 76 248 59 38 146 71 199 39 167 119 53 147 5 245 244 115 19 167 40 248 224 7 56 184 118 40 167 88 103 100 23 201 35 117 249 242 113 6 87 101 230 6 122 57 137 149 151 134 151 216 182 137 197 106 104 213 90 138 84 250 23 152 137 247 73 186 154 251 147 75 131 138 211 147 52 188 57 52 67 133 212 183 11 202 59 58 220 119 120 170 246 232 172 23 205 76 212 226 28 71 185 68 123 12 28 46 158 237 184 211 100 51 123 141 157 173 197 216 148 5 163 222 213 174 44 191 94 94 63 127 87 31 229 85 179 95 44 166 236 241 225 135 30 29 110 6 10 0 0 59] type: ZnMimeType imageGif"		^ self new		mediaType: mimeType;		data: bytes;		base64Encoded: true;		yourself! !!ZnDataUrl class methodsFor: 'instance creation' stamp: '8/31/2024 04:18:34'!fromString: string	"Parse the external representation of a Data URI from string.	The general format being data:[<mediatype>][;base64],<data>"		"self fromString: 'data:image/gif;base64,R0lGODdhMAAwAPAAAAAAAP///ywAAAAAMAAwAAAC8IyPqcvt3wCcDkiLc7C0qwyGHhSWpjQu5yqmCYsapyuvUUlvONmOZtfzgFzByTB10QgxOR0TqBQejhRNzOfkVJ+5YiUqrXF5Y5lKh/DeuNcP5yLWGsEbtLiOSpa/TPg7JpJHxyendzWTBfX0cxOnKPjgBzi4diinWGdkF8kjdfnycQZXZeYGejmJlZeGl9i2icVqaNVailT6F5iJ90m6mvuTS4OK05M0vDk0Q4XUtwvKOzrcd3iq9uisF81M1OIcR7lEewwcLp7tuNNkM3uNna3F2JQFo97Vriy/Xl4/f1cf5VWzXyym7PHhhx4dbgYKAAA7'"		^ self new		parseFrom: string;		yourself! !!ZnDataUrl class methodsFor: 'instance creation' stamp: '8/31/2024 04:18:34'!text: string	"self text: 'Hello there !!'"		^ self new		mediaType: ZnMimeType textPlain;		data: string;		yourself! !!ZnDataUrl methodsFor: 'comparing' stamp: '8/31/2024 04:18:34'!= anObject	"Answer whether the receiver and anObject represent the same object."	self == anObject ifTrue: [ ^ true ].	self class = anObject class ifFalse: [ ^ false ].	^ mediaType = anObject mediaType and: [		  base64Encoded = anObject isBase64Encoded and: [			  data = anObject data ] ]! !!ZnDataUrl methodsFor: 'initialization' stamp: '8/31/2024 04:18:34'!base64Encoded: boolean	base64Encoded := boolean! !!ZnDataUrl methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!data	"Answer the data that I hold, either a ByteArray or a String"		^ data! !!ZnDataUrl methodsFor: 'initialization' stamp: '8/31/2024 04:18:34'!data: stringOrBytes	data := stringOrBytes! !!ZnDataUrl methodsFor: 'comparing' stamp: '8/31/2024 04:18:34'!hash	"Answer an integer value that is related to the identity of the receiver."	^ mediaType hash bitXor: (base64Encoded hash bitXor: data hash)! !!ZnDataUrl methodsFor: 'initialization' stamp: '8/31/2024 04:18:34'!initialize	super initialize.	mediaType := 'text/plain;charset=ASCII' asZnMimeType.	base64Encoded := false.	data := #[]! !!ZnDataUrl methodsFor: 'testing' stamp: '8/31/2024 04:18:34'!isBase64Encoded	"Am I using Base64 encoding ?"		^ base64Encoded! !!ZnDataUrl methodsFor: 'testing' stamp: '8/31/2024 04:18:34'!isBinary	"Am I binary ?"		^ mediaType isBinary! !!ZnDataUrl methodsFor: 'testing' stamp: '8/31/2024 04:18:34'!isEmpty	^ data isEmpty! !!ZnDataUrl methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!mediaType	"Answer the media type that described my content, a ZnMimeType"		^ mediaType! !!ZnDataUrl methodsFor: 'initialization' stamp: '8/31/2024 04:18:34'!mediaType: mimeType	mediaType := mimeType asZnMimeType! !!ZnDataUrl methodsFor: 'parsing' stamp: '8/31/2024 04:18:34'!parseFrom: string	| commaIndex |	(string beginsWith: 'data:')		ifFalse: [ ^ self error: 'missing data: scheme' ].	(commaIndex := string indexOf: $,) isZero		ifTrue: [ ^ self error: 'missing comma in data: scheme' ].	commaIndex = string size 		ifTrue: [ ^ self ].	commaIndex > 7		ifTrue: [ mediaType := ZnMimeType fromString: (string copyFrom: 6 to: commaIndex - 1) ].	(base64Encoded := mediaType parameters includesKey: 'base64')		ifTrue: [ 			 mediaType removeParameter: 'base64' ].	data := string copyFrom: commaIndex + 1 to: string size.	data := base64Encoded 		ifTrue: [ 			ZnBase64Encoder new				decode: data ]		ifFalse: [			ZnPercentEncoder new 				characterEncoder: mediaType charSet asZnCharacterEncoder;				decode:	data ]! !!ZnDataUrl methodsFor: 'printing' stamp: '8/31/2024 04:18:34'!printOn: stream	stream nextPutAll: 'data:'.	mediaType printOn: stream.	base64Encoded		ifTrue: [ 			stream nextPutAll: ';base64,'.			ZnBase64Encoder new 				encode: data readStream to: stream ]		ifFalse: [			stream nextPut: $,.			ZnPercentEncoder new 				characterEncoder: mediaType charSet asZnCharacterEncoder;				encode: data readStream to: stream ]! !!ZnDataUrl methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!scheme	"Answer my URL scheme"		^ #data! !!ZnUrl methodsFor: 'parsing' stamp: '8/31/2024 04:18:34' prior: 85282332!parseFrom: string defaultScheme: defaultScheme	| start end index |	start := 1.	end := string size.	(index := string indexOf: $#) > 0		ifTrue: [			self fragment: (self decodePercent: (string copyFrom: index + 1 to: end)).			end := index - 1 ].	((index := (string indexOf: $?)) between: 1 and: end)		ifTrue: [			self query: (self parseQueryFrom: (ReadStream on: string from: index + 1 to: end)).			end := index - 1 ].	((index := string indexOfSubCollection: '://') > 0 and: [ index <= end ])		ifTrue: [			self scheme: (string copyFrom: 1 to: index - 1).			start := index + 3 ]		ifFalse: [			((index := string indexOf: $:) > 0					and: [ index <= end						and: [ self isSchemeNotUsingDoubleSlash: (string copyFrom: 1 to: index - 1) ] ])				ifTrue: [					self scheme: (string copyFrom: 1 to: index - 1).					start := index + 1 ]				ifFalse: [					defaultScheme ifNotNil: [ self scheme: defaultScheme ] ] ].	self hasScheme		ifTrue: [			(index := string indexOf: $/ startingAt: start) > 0				ifTrue: [					self parseAuthority: string from: start to: index - 1.					start := index ]				ifFalse: [					^ self parseAuthority: string from: start to: end ] ].	self parsePath: (ReadStream on: string from: start to: end)! !"Zinc-Resource-Meta-Core"!!ZnDataUrlTest methodsFor: 'tests' stamp: '8/31/2024 04:18:34'!testABriefNote	| dataUrl |	dataUrl := ZnDataUrl fromString: 'data:,A%20brief%20note'.	self assert: dataUrl data equals: 'A brief note'.	self deny: dataUrl isBase64Encoded.! !!ZnDataUrlTest methodsFor: 'tests' stamp: '8/31/2024 04:18:34'!testBinary	self		assert: (ZnDataUrl bytes: #[1 2 3] type: 'application/octet-stream')		equals: (ZnDataUrl bytes: #[1 2 3] type: 'application/octet-stream').	self		assert: (ZnDataUrl bytes: #[1 2 3] type: 'application/octet-stream') hash		equals: (ZnDataUrl bytes: #[1 2 3] type: 'application/octet-stream') hash.	self		assert: (ZnDataUrl bytes: #[1 2 3] type: 'application/octet-stream') printString		equals: (ZnDataUrl bytes: #[1 2 3] type: 'application/octet-stream') printString! !!ZnDataUrlTest methodsFor: 'tests' stamp: '8/31/2024 04:18:34'!testBinaryAll	| dataUrl |	dataUrl := ZnDataUrl new.	dataUrl data: (0 to: 255) asByteArray.	dataUrl mediaType: ZnMimeType applicationOctetStream.	dataUrl base64Encoded: true.	self assert: dataUrl data equals: (0 to: 255) asByteArray.	self assert: dataUrl isBase64Encoded.	self assert: dataUrl mediaType equals: ZnMimeType applicationOctetStream.	self assert: (ZnDataUrl fromString: dataUrl printString) data equals: (0 to: 255) asByteArray! !!ZnDataUrlTest methodsFor: 'tests' stamp: '8/31/2024 04:18:34'!testEmpty	| dataUrl |	dataUrl := ZnDataUrl new.	self assert: dataUrl isEmpty.	self assert: dataUrl scheme equals: #data.	self assert: ('text/plain' asZnMimeType matches: dataUrl mediaType).	self assert: dataUrl equals: ZnDataUrl new! !!ZnDataUrlTest methodsFor: 'tests' stamp: '8/31/2024 04:18:34'!testGreek	| dataUrl |	dataUrl := ZnDataUrl fromString: 'data:text/plain;charset=iso-8859-7,%e1%f8%e2'.	self assert: dataUrl data equals: ''.	self deny: dataUrl isBase64Encoded.	self assert: (dataUrl printString sameAs: 'data:text/plain;charset=iso-8859-7,%e1%f8%e2')! !!ZnDataUrlTest methodsFor: 'tests' stamp: '8/31/2024 04:18:34'!testParseMinimal	| dataUrl |	dataUrl := ZnDataUrl fromString: 'data:,'.	self assert: dataUrl isEmpty.	self assert: dataUrl scheme equals: #data.	self assert: ('text/plain' asZnMimeType matches: dataUrl mediaType).! !!ZnDataUrlTest methodsFor: 'tests' stamp: '8/31/2024 04:18:34'!testPng	| logoPngBytes dataUrl representation |	logoPngBytes := PolymorphSystemSettings pharoLogoContents base64Decoded.	dataUrl := ZnDataUrl bytes: logoPngBytes type: ZnMimeType imagePng.	representation := dataUrl printString.	dataUrl := ZnDataUrl fromString: representation.	self assert: dataUrl data equals: logoPngBytes ! !!ZnDataUrlTest methodsFor: 'tests' stamp: '8/31/2024 04:18:34'!testSimpleBinary	| dataUrl |	dataUrl := ZnDataUrl new.	dataUrl data: #[ 0 1 2 3 4 5 6 7 8 9 ].	dataUrl mediaType: ZnMimeType applicationOctetStream.	dataUrl base64Encoded: true.	self assert: dataUrl data equals: #[ 0 1 2 3 4 5 6 7 8 9 ].	self assert: dataUrl isBase64Encoded.	self assert: dataUrl mediaType equals: ZnMimeType applicationOctetStream! !!ZnDataUrlTest methodsFor: 'tests' stamp: '8/31/2024 04:18:34'!testSimpleString	| dataUrl |	dataUrl := ZnDataUrl new.	dataUrl data: 'foo'.	self assert: dataUrl data equals: 'foo'! !!ZnDataUrlTest methodsFor: 'tests' stamp: '8/31/2024 04:18:34'!testSmallGif	| dataUrl |	dataUrl := ZnDataUrl fromString: 'data:image/gif;base64,R0lGODdhMAAwAPAAAAAAAP///ywAAAAAMAAwAAAC8IyPqcvt3wCcDkiLc7C0qwyGHhSWpjQu5yqmCYsapyuvUUlvONmOZtfzgFzByTB10QgxOR0TqBQejhRNzOfkVJ+5YiUqrXF5Y5lKh/DeuNcP5yLWGsEbtLiOSpa/TPg7JpJHxyendzWTBfX0cxOnKPjgBzi4diinWGdkF8kjdfnycQZXZeYGejmJlZeGl9i2icVqaNVailT6F5iJ90m6mvuTS4OK05M0vDk0Q4XUtwvKOzrcd3iq9uisF81M1OIcR7lEewwcLp7tuNNkM3uNna3F2JQFo97Vriy/Xl4/f1cf5VWzXyym7PHhhx4dbgYKAAA7'.	self assert: dataUrl mediaType equals: ZnMimeType imageGif.	self deny: dataUrl isEmpty.	self assert: dataUrl isBase64Encoded.	ImageReadWriter formFromStream: dataUrl data readStream.	self assert: dataUrl printString equals: 'data:image/gif;base64,R0lGODdhMAAwAPAAAAAAAP///ywAAAAAMAAwAAAC8IyPqcvt3wCcDkiLc7C0qwyGHhSWpjQu5yqmCYsapyuvUUlvONmOZtfzgFzByTB10QgxOR0TqBQejhRNzOfkVJ+5YiUqrXF5Y5lKh/DeuNcP5yLWGsEbtLiOSpa/TPg7JpJHxyendzWTBfX0cxOnKPjgBzi4diinWGdkF8kjdfnycQZXZeYGejmJlZeGl9i2icVqaNVailT6F5iJ90m6mvuTS4OK05M0vDk0Q4XUtwvKOzrcd3iq9uisF81M1OIcR7lEewwcLp7tuNNkM3uNna3F2JQFo97Vriy/Xl4/f1cf5VWzXyym7PHhhx4dbgYKAAA7'! !!ZnDataUrlTest methodsFor: 'tests' stamp: '8/31/2024 04:18:34'!testText	self 		assert: (ZnDataUrl text: 'Les lves Franais')		equals: (ZnDataUrl text: 'Les lves Franais').	self 		assert: (ZnDataUrl text: 'Les lves Franais') hash		equals: (ZnDataUrl text: 'Les lves Franais') hash.	self 		assert: (ZnDataUrl text: 'Les lves Franais') printString		equals: (ZnDataUrl text: 'Les lves Franais') printString! !!ZnMimeTypeTest methodsFor: 'accessing' stamp: '8/31/2024 04:18:34' prior: 84698518!someNonBinaryMimeTypes	^ #(		'text/plain;charset=ascii'		'application/json;charset=utf-8'		'application/ston'		'application/vnd.com.runkeeper.user+json;charset=ISO-8859-1'		'application/xml-dtd'		'application/xslt+xml'		'image/svg+xml'		'application/SGML'		'model/x3d+xml'		'application/csv'		'application/x-ndjson')! !"Zinc-Resource-Meta-Tests"!!ZnTooManyRedirects commentStamp: '<historical>' prior: 85212222!ZnTooManyRedirects is signalled when an HTTP client has been following more redirects than allowed.The default resume behavior is to retry, signal with any other value to give up just return the redirect.Part of Zinc HTTP Components. !!ZnClientTransactionEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 84193856!printContentsOn: stream	super printContentsOn: stream.	request requestLine printMethodAndUriOn: stream.	stream space; print: response code.	response hasEntity		ifTrue: [			stream space; print: response entity contentLength; nextPut: $B ].	stream space; print: self duration; nextPutAll: 'ms'! !!ZnServerStartedEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 85018538!printContentsOn: stream	super printContentsOn: stream.	description ifNotNil: [ stream << 'Started '; << description ]! !!ZnServer methodsFor: 'options' stamp: '8/31/2024 04:18:34' prior: 84968944!delegate	"Return the optional delegate,	the object that will be sent #handleRequest: to handle a request and produce a response.	The default delegate is ZnDefaultServerDelegate"	^ self 		optionAt: #delegate		ifAbsentPut: [ ZnDefaultServerDelegate new server: self; yourself ]! !!ZnBivalentWriteStream methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!print: object	object printOn: self! !!ZnClientIgnoringExceptionOnConnectionReuseEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 84128504!printContentsOn: stream	super printContentsOn: stream.	stream << 'Ignoring Exception On Connection Reuse '; print: exception! !!ZnRequestResponseHandledEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 84904800!printContentsOn: stream	super printContentsOn: stream.	stream << 'Request Handled '; print: request; space; print: duration; << 'ms'! !!ZnClientFollowingRedirectEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 84127290!printContentsOn: stream	super printContentsOn: stream.	stream << 'Following Redirect '; print: target! !!ZnRequestWrittenEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 84916482!printContentsOn: stream	super printContentsOn: stream.	stream << 'Request Written '; print: request; space; print: duration; << 'ms'! !!ZnUtils class methodsFor: 'converting' stamp: '8/31/2024 04:18:34'!exceptionSet: classNames	^ classNames inject: ExceptionSet new into: [ :set :each |		  (Smalltalk globals includesKey: each)			  ifTrue: [				  set					  add: (Smalltalk at: each);					  yourself ]			  ifFalse: [ set ] ]! !!ZnUtils class methodsFor: 'streaming' stamp: '8/31/2024 04:18:34' prior: 85397124!signalProgress: amount total: total	(ZnCurrentOptions at: #signalProgress)		ifTrue: [			total				ifNil: [					HTTPProgress new						signal: ('Transferred {1} bytes ...' format: { amount humanReadableSIByteSize }) ]				ifNotNil: [					HTTPProgress new						total: total;						amount: amount;						signal: 'Transferring...' ] ]! !!ZnDefaultServerDelegate methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!server	"Return the ZnServer I was configured with, the one I am the delegate for"		^ server! !!ZnDefaultServerDelegate methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!server: znServer	"Set my server to snServer, the one I am the delegate for"		server := znServer! !!ZnServerReadErrorEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 85005074!printContentsOn: stream	super printContentsOn: stream.	stream << 'Server Read Error ';  print: exception! !!ZnServerLogEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 85003628!printHeaderOn: stream	super printHeaderOn: stream.	serverId ifNotNil: [ stream space; << serverId asString ]! !!ZnClient methodsFor: 'private - protocol' stamp: '8/31/2024 04:18:34'!executeWithRedirectsRemaining: redirectCount trail: collectionOfUrls	self getConnectionAndExecute.	response isRedirect		ifTrue: [			(redirectCount > 0 and: [ self followRedirects ])				ifTrue: [					self prepareRedirect.					collectionOfUrls add: self request url.					self 						executeWithRedirectsRemaining: redirectCount - 1 						trail: collectionOfUrls ]				ifFalse: [					self followRedirects						ifTrue: [ | exception |							(exception := ZnTooManyRedirects new) 									trail: collectionOfUrls. 							exception signal = exception defaultResumeValue								ifTrue: [									"when resumed with default resume value, start over"									self 										executeWithRedirectsRemaining: self maxNumberOfRedirects 										trail: collectionOfUrls ] ] ] ].	^ self handleResponse! !!ZnClient methodsFor: 'private - protocol' stamp: '8/31/2024 04:18:34' prior: 84059342!executeWithRetriesRemaining: retryCount	^ [ self 			executeWithRedirectsRemaining: self maxNumberOfRedirects			trail: OrderedCollection new ]		on: self retryExceptionSet		do: [ :exception |			retryCount > 0				ifTrue: [					self						handleRetry: exception;						executeWithRetriesRemaining: retryCount - 1 ]				ifFalse: [					exception pass ] ]! !!ZnClient methodsFor: 'private' stamp: '8/31/2024 04:18:34' prior: 84056166!setupTLSTo: url	(ZnNetworkingUtils shouldProxyUrl: url)		ifTrue: [ | originalRequest |			"http://www.ietf.org/rfc/rfc2817.txt (section 5)"			"https://en.wikipedia.org/wiki/HTTP_tunnel#HTTP_CONNECT_tunneling"			originalRequest := request copy.			request entity: nil. "to prevent #resetEntity from being called, resulting in #close of the shared entity"			self method: #CONNECT; writeRequest; readResponse.			response isSuccess ifFalse: [ self error: 'Failed to CONNECT to proxy for TLS/SSL' ].			connection := ZnNetworkingUtils secureSocketStreamOn: connection socket.			request := originalRequest ].	connection sslSession certificateName: self certificate.	[ connection sslSession serverName: url host ]		on: (ZnUtils exceptionSet: #( #SocketError #PrimitiveFailed ))		do: [ :error | "log it?" ].	connection connect! !!ZnConnectionAcceptedEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 84205562!printContentsOn: stream	super printContentsOn: stream.	stream << 'Connection Accepted '.	self class printAddress: address on: stream ! !!ZnServerSocketReleasedEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 85016874!printContentsOn: stream	super printContentsOn: stream.	stream << 'Server Socket Released '.	self class printAddress: address on: stream. 	stream nextPut: $:; print: port! !!ZnConnectionRejectedEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 84210504!printContentsOn: stream	super printContentsOn: stream.	stream << 'Connection Rejected '.	self class printAddress: address on: stream! !!ZnRequestReadEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 84903008!printContentsOn: stream	super printContentsOn: stream.	stream << 'Request Read '; print: request; space; print: duration; << 'ms'! !!ZnServerConnectionClosedEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 84999262!printContentsOn: stream	super printContentsOn: stream.	stream << 'Server Connection Closed '.	self class printAddress: address on: stream ! !!ZnLoggingReadStream methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnServerHandlerErrorEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 85002896!printContentsOn: stream	super printContentsOn: stream.	stream << 'Server Handler Error ';  print: exception! !!ZnSimplifiedServerTransactionEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 85096778!printContentsOn: stream	super printContentsOn: stream.	stream nextPutAll: method; space.	url printPathQueryFragmentOn: stream.	stream space; print: response.	size ifNotNil: [		stream space; print: size; nextPut: $B ].	stream space; print: duration; nextPutAll: 'ms'! !!ZnServerWriteErrorEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 85069282!printContentsOn: stream	super printContentsOn: stream.	stream << 'Server Write Error ';  print: exception! !!ZnResponseReadEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 84947584!printContentsOn: stream	super printContentsOn: stream.	stream << 'Response Read '; print: response; space; print: duration; << 'ms'! !!ZnMimePart methodsFor: 'testing' stamp: '8/31/2024 04:18:34' prior: 84634472!hasHeaders	^ headers isNotNil and: [ self headers isEmpty not ]! !!ZnConnectionEstablishedEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 84208188!printContentsOn: stream	super printContentsOn: stream.	stream << 'Connection Established '; nextPutAll: hostname asString; nextPut: $:; print: port.	proxy ifNotNil: [ stream << ' via proxy '; print: proxy ].	stream space.	self class printAddress: address on: stream.	stream nextPut: $:; print: port.	stream space; print: duration; << 'ms'! !!ZnServerSocketBoundEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 85015162!printContentsOn: stream	super printContentsOn: stream.	stream << 'Server Socket Bound '.	self class printAddress: address on: stream.	stream nextPut: $:; print: port! !!ZnLogEvent class methodsFor: 'convenience' stamp: '8/31/2024 04:18:34' prior: 84572360!logToTranscript	self stopLoggingToTranscript.	^ self announcer 		when: ZnLogEvent 		do: [ :event | self crTrace: event ]		for: self! !!ZnLogEvent class methodsFor: 'utilities' stamp: '8/31/2024 04:18:34'!printAddress: address on: stream	"Try printing address as a IPv4 dotted address to stream.	If that fails, just print address as an object to stream."		[ address asSocketAddress printOn: stream ] on: Error do: [ stream print: address ]! !!ZnTooManyRedirects methodsFor: 'private' stamp: '8/31/2024 04:18:34'!defaultResumeValue	^ #retry! !!ZnTooManyRedirects methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!trail	^ trail! !!ZnTooManyRedirects methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!trail: aCollectionOfUrls	trail := aCollectionOfUrls! !!ZnSimplifiedClientTransactionEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 85091814!printContentsOn: stream	super printContentsOn: stream.	stream nextPutAll: method; space.	url printPathQueryFragmentOn: stream.	stream space; print: response.	size ifNotNil: [		stream space; print: size; nextPut: $B ].	stream space; print: duration; nextPutAll: 'ms'! !!ZnClientRetryingEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 84130738!printContentsOn: stream	super printContentsOn: stream.	stream << 'Retrying '; print: exception! !!ZnResponseWrittenEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 84961506!printContentsOn: stream	super printContentsOn: stream.	stream << 'Response Written '; print: response; space; print: duration; << 'ms'! !!ZnServerTransactionEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 85063870!printContentsOn: stream	super printContentsOn: stream.	request requestLine printMethodAndUriOn: stream.	stream space; print: response code.	response hasEntity		ifTrue: [			stream space; print: response entity contentLength; nextPut: $B ].	stream space; print: self duration; nextPutAll: 'ms'! !!ZnHtmlOutputStream methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnServerGenericLogEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 85001780!printContentsOn: stream	super printContentsOn: stream.	stream nextPutAll: subject asString! !!ZnServerStoppedEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 85019552!printContentsOn: stream	super printContentsOn: stream.	description ifNotNil: [ stream << 'Stopped '; << description ]! !!ZnMultiThreadedServer methodsFor: 'private' stamp: '8/31/2024 04:18:34' prior: 84730186!readRequestBadExceptionSet	"Return the set of exceptions which, when they occur while reading a request,	are interpreted as equivalent to a request parse error or bad request."	^ ZnUtils		exceptionSet:			#(#ZnParseError #ZnCharacterEncodingError #ZnUnknownScheme #ZnPortNotANumber #ZnTooManyDictionaryEntries #ZnEntityTooLarge)! !!ZnMultiThreadedServer methodsFor: 'private' stamp: '8/31/2024 04:18:34' prior: 84735094!readRequestTerminationExceptionSet	"Return the set of exceptions which, when they occur while reading a request,	are interpreted as equivalent to a timeout or connection close."	^ ZnUtils		exceptionSet:			#(#ConnectionClosed #ConnectionTimedOut #SocketError #PrimitiveFailed)! !!ZnMultiThreadedServer methodsFor: 'private' stamp: '8/31/2024 04:18:34' prior: 84726586!writeResponseTerminationExceptionSet	"Return the set of exceptions which, when they occur while writing a response,	are interpreted as equivalent to a timeout or connection close."	^ ZnUtils 		exceptionSet:			#(#ConnectionClosed #ConnectionTimedOut #SocketError #PrimitiveFailed)! !!ZnClientConnectionClosedEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 84125098!printContentsOn: stream	super printContentsOn: stream.	stream << 'Connection Closed '.	self class printAddress: address on: stream.	stream nextPut: $:; print: port! !!ZnClientLogEvent methodsFor: 'printing' stamp: '8/31/2024 04:18:34' prior: 84129612!printHeaderOn: stream	super printHeaderOn: stream.	clientId ifNotNil: [ stream space; << clientId asString ]! !!ZnCookie methodsFor: 'testing' stamp: '8/31/2024 04:18:34' prior: 84229264!isInDomain: urlObject	| domain |	domain := (self domain beginsWith: '.')		ifTrue: [ self domain allButFirst ]		ifFalse: [ self domain ].	^ urlObject host includesSubstring: domain! !ManifestZincHTTP class removeSelector: #ruleNotEliminationRuleV1FalsePositive!Smalltalk globals removeClassNamed: #AnObsoleteManifestZincHTTP!ZnClient removeSelector: #executeWithRedirectsRemaining:!ZnMultiThreadedServer removeSelector: #exceptionSet:!ZnConstants class removeSelector: #frameworkMCVersion!"Zinc-HTTP"!!ZnProxyServerDelegate commentStamp: '<historical>' prior: 0!I am a ZnDelegate that acts as a proxy.I handle requests by passing them to a proxyBlock which can change the request before I execute it.The idea is that the changed request is to a different server, the one that we proxy.Usage example	| proxiedServer proxyServer proxyDelegate client  |	proxiedServer := ZnServer startOn: 8080.	proxyServer := ZnServer on: 9090.	proxyDelegate := ZnProxyServerDelegate new		server: proxyServer;		proxyBlock: [ :request | 			request url: (request url port: 8080) ].	proxyServer		delegate: proxyDelegate;		start.	client := ZnClient new.	client get: proxyServer url / #echo.!!ZnProxyServerDelegateTest methodsFor: 'testing' stamp: '8/31/2024 04:18:34'!testEcho	| proxiedServer proxyServer proxyDelegate client  |	proxiedServer := ZnServer startOn: 8080.	proxyServer := ZnServer on: 9090.	proxyDelegate := ZnProxyServerDelegate new		server: proxyServer;		proxyBlock: [ :request | 			request url: (request url port: 8080) ].	proxyServer		delegate: proxyDelegate;		start.	client := ZnClient new.	client get: proxyServer url / #echo.	self assert: client isSuccess.	self assert: (client contents includesSubstring: 'echoing').	self assert: (client contents includesSubstring: 'running 8080').	proxiedServer stop.	proxyServer stop! !!ZnProxyServerDelegate methodsFor: 'private' stamp: '8/31/2024 04:18:34'!augmentUrl: aUrl	"The URL in a server request has no scheme, host or port set.	Augment aUrl by taking those elements from #serverUrl"	self server ifNil: [ ^ aUrl ].	^ aUrl inContextOf: self server url! !!ZnProxyServerDelegate methodsFor: 'private' stamp: '8/31/2024 04:18:34'!copyAndPrepareRequest: aRequest	"We make a copy of the request and augment its URL"	| copiedRequest |	copiedRequest := aRequest copy.	copiedRequest url: (self augmentUrl: copiedRequest url).	^ copiedRequest! !!ZnProxyServerDelegate methodsFor: 'public' stamp: '8/31/2024 04:18:34'!handleRequest: incomingRequest	"Ask our proxy block to transform a incoming ZnRequest copy into an outgoing ZnRequest"	| outgoingRequest |	outgoingRequest := self proxyBlock 		cull: (self copyAndPrepareRequest: incomingRequest) 		cull: self server.	^ ZnClient new		request: outgoingRequest;		beOneShot;		execute;		response! !!ZnProxyServerDelegate methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!proxyBlock	^ proxyBlock! !!ZnProxyServerDelegate methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!proxyBlock: aBlock	"Set the block that transforms a copy of the incoming ZnRequest to the outgoing ZnRequest.	Two parameters are passed to block: the request and an optional server reference.	See #copyAndPrepareRequest: for how the request got changed."	proxyBlock := aBlock! !!ZnProxyServerDelegate methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!server	^ server! !!ZnProxyServerDelegate methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!server: aZnServer	"Set areference to the server we're in (optional)"	server := aZnServer! !!ZnStaticFileServerDelegate methodsFor: 'private' stamp: '8/31/2024 04:18:34' prior: 85154164!actualFilenameFor: uri	| subElements subDir entry |	(uri isEmpty and: [ self prefix isEmpty ]) ifTrue: [ ^ self indexFileIn: self directory ].	(self prefix isEmpty or: [ uri isEmpty not and: [ uri pathSegments beginsWith: self prefix ] ]) ifFalse: [ ^ nil ].	subElements := (uri pathSegments allButFirst: self prefix size) reject: [ :each | each = $/ ].	subDir := (subElements ifNotEmpty: #allButLast ifEmpty: [ #() ]) 		inject: self directory 		into: [ :parent :sub | | file |			(file := parent / sub) exists				ifTrue: [ file ]				ifFalse: [ ^ nil ] ]. 	subElements isEmpty		ifTrue: [ entry := subDir entry ]		ifFalse: [ | file |			 (file := subDir / subElements last) exists				ifTrue: [ entry := file entry ]				ifFalse: [ ^ nil ] ].	^ entry isDirectory		ifTrue: [ self indexFileIn: entry reference ]		ifFalse: [ entry reference fullName ]! !!ZnStaticFileServerDelegateTest methodsFor: 'tests' stamp: '8/31/2024 04:18:34' prior: 85165704!testBasicGetWide	self withServerDo: [ :server | | client |		(client := ZnClient new)			beOneShot;			url: server localUrl;			addPath: #('local-files' 'wide.html');			get.		self assert: client isSuccess.		self assert: client response contentType = ZnMimeType textHtml.		self assert: client contents equals: self wideHtml.		self			assert: (ZnUtils parseHttpDate: (client response headers at: 'Modification-Date'))			equals: (ZnFileSystemUtils modificationTimeFor: 'wide.html') asUTC.		self			assert: (ZnUtils parseHttpDate: (client response headers at: 'Expires')) > (DateAndTime now + 10 days).		self			assert: (client response headers at: 'Cache-Control')			equals: (server delegate maxAgeFor: ZnMimeType textHtml) ]! !"Zinc-HTTP-Examples"!!ZnChunkedStreamTest class methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!defaultTimeLimit	^15 seconds! !!ZnChunkedStreamTest methodsFor: 'testing' stamp: '8/31/2024 04:18:34' prior: 84015106!testGzipWriteRead	| data written read |	data := (String loremIpsum: 16*1024) utf8Encoded.	written := ByteArray streamContents: [ :out |		| stream chunkedStream |		stream := GZipWriteStream on: (chunkedStream := ZnChunkedWriteStream on: out).		stream nextPutAll: data.		stream finish.		chunkedStream finish ].	read := (GZipReadStream on: (ZnChunkedReadStream on: written readStream)) upToEnd.	self assert: read equals: data! !!ZnLogEventTest methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!clientId	^ 'client-1'! !!ZnLogEventTest methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!request	^ ZnRequest get: 'http://foo.com/test'! !!ZnLogEventTest methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!response	^ ZnResponse ok: (ZnEntity text: 'OK')! !!ZnLogEventTest methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!serverId	^ 'server-1'! !!ZnLogEventTest methodsFor: 'testing' stamp: '8/31/2024 04:18:34'!testClientTransactionEvent	| event |	(event := ZnClientTransactionEvent new)		clientId: self clientId;		request: self request;		response: self response;		requestDuration: self timing requestDuration;		responseDuration: self timing responseDuration.	self assert: event id isInteger.	self assert: event processId isInteger.	self assert: event timestamp <= DateAndTime now.	self assert: event clientId equals: self clientId.	self assert: event request uri equals: self request uri.	self assert: event request method equals: self request method.	self assert: event response code equals: self response code.	self assert: event duration equals: self timing requestDuration + self timing responseDuration.	self assert: event printString isString.	^ event! !!ZnLogEventTest methodsFor: 'testing' stamp: '8/31/2024 04:18:34'!testServerTransactionEvent	| event |	(event := ZnServerTransactionEvent new)		serverId: self serverId;		request: self request;		response: self response;		timing: self timing.	self assert: event id isInteger.	self assert: event processId isInteger.	self assert: event timestamp <= DateAndTime now.	self assert: event serverId equals: self serverId.	self assert: event request uri equals: self request uri.	self assert: event request method equals: self request method.	self assert: event response code equals: self response code.	self assert: event duration equals: self timing totalDuration.	self assert: event printString isString.	^ event! !!ZnLogEventTest methodsFor: 'testing' stamp: '8/31/2024 04:18:34'!testSimplifiedClientTransactionEvent	| event |	(event := ZnSimplifiedClientTransactionEvent new)		clientId: self clientId;		request: self request;		response: self response;		requestDuration: self timing requestDuration;		responseDuration: self timing responseDuration.	self assert: event id isInteger.	self assert: event processId isInteger.	self assert: event timestamp <= DateAndTime now.	self assert: event clientId equals: self clientId.	self assert: event url equals: self request uri.	self assert: event method equals: self request method.	self assert: event responseCode equals: self response code.	self assert: event size equals: self response contentLength.	self assert: event duration equals: self timing requestDuration + self timing responseDuration.	self assert: event printString isString.	^ event! !!ZnLogEventTest methodsFor: 'testing' stamp: '8/31/2024 04:18:34'!testSimplifiedServerTransactionEvent	| event |	(event := ZnSimplifiedServerTransactionEvent new)		serverId: self serverId;		request: self request;		response: self response;		timing: self timing.	self assert: event id isInteger.	self assert: event processId isInteger.	self assert: event timestamp <= DateAndTime now.	self assert: event serverId equals: self serverId.	self assert: event url equals: self request uri.	self assert: event method equals: self request method.	self assert: event responseCode equals: self response code.	self assert: event size equals: self response contentLength.	self assert: event duration equals: self timing totalDuration.	self assert: event printString isString.	^ event! !!ZnLogEventTest methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!timing	^ ZnServerTransactionTiming new			requestDuration: 1;			responseDuration: 2;			yourself! !!ZnServerTest methodsFor: 'tests' stamp: '8/31/2024 04:18:34'!testLogging	| client logEventCollection count renderedLogEvents |	logEventCollection := OrderedCollection new.	ZnLogEvent announcer		when: ZnLogEvent		do: [ :event | logEventCollection add: event ]		for: self.	self withServerDo: [ :server |		1 to: 3 do: [ :logLevel |			server				serverId: 'S' , logLevel asString;				logLevel: logLevel.			client := ZnClient new.			client				clientId: 'C' , logLevel asString;				logLevel: logLevel.			client get: (server localUrl addPathSegment: #small).			self assert: client isSuccess.			client get: (server localUrl addPathSegment: #error).			self deny: client isSuccess.			server delegate				map: #redirect				to: [ :request | ZnResponse redirect: #welcome ].			client get: (server localUrl addPathSegment: #redirect).			self assert: client isSuccess.			client close ] ].	count := ZnLogEvent announcer numberOfSubscriptions.	ZnLogEvent announcer unsubscribe: self.	self		assert: ZnLogEvent announcer numberOfSubscriptions		equals: count - 1.	self deny: logEventCollection isEmpty.	renderedLogEvents := String streamContents: [ :out |		                     logEventCollection do: [ :event |			                     out				                     print: event;				                     cr ] ].	self deny: renderedLogEvents isEmpty! !!ZnServerTest methodsFor: 'testing' stamp: '8/31/2024 04:18:34' prior: 85042184!testTooManyConcurrentConnections	self usingClassicSocketStreamsOnWindowsDo: [		self withServerDo: [ :server | | client clients |			self deny: server debugMode.			server maximumNumberOfConcurrentConnections: 4.			clients := (1 to: 4) collect: [ :each |				ZnClient new					url: server localUrl;					addPathSegment: #random;					clientId: ('client-{1}' format: { each });					enforceHttpSuccess;					get;					yourself ].			client := ZnClient new					url: server localUrl;					addPathSegment: #random;					clientId: 'client-5';					get;					yourself.			self assert: client response code equals: 503.			clients do: [ :each |				each get; close ].			client get.			self assert: client isSuccess.			client close ] ]! !!ZnClientTest class methodsFor: 'accessing' stamp: '8/31/2024 04:18:34'!defaultTimeLimit	^ 60 seconds! !!ZnClientTest methodsFor: 'testing' stamp: '8/31/2024 04:18:34' prior: 84176246!testLogging	| client logEventCollection count |	logEventCollection := OrderedCollection new.	ZnLogEvent announcer		when: ZnLogEvent		do: [ :event | logEventCollection add: event ]		for: self.	(client := ZnClient new)		clientId: #C1;		beOneShot.	client get: self smallHtmlUrl.	client close.	count := ZnLogEvent announcer numberOfSubscriptions.	ZnLogEvent announcer unsubscribe: self.	self		assert: ZnLogEvent announcer numberOfSubscriptions		equals: count - 1.	self deny: logEventCollection isEmpty.	self assert: logEventCollection anyOne clientId equals: #C1! !!ZnClientTest methodsFor: 'testing' stamp: '8/31/2024 04:18:34' prior: 84137874!testQueryGoogle	| client |		(client := ZnClient new)		http;		host: 'www.google.com';		addPath: 'search';		queryAt: 'q' put: 'Pharo Smalltalk';		retryDelay: 20;		numberOfRetries: 3;		get.		[			self 			assert: (client isSuccess or: [client response code = 429])			description: ('Response should be success or 429 code. [{1}] received' format: {				client response  statusLine}).		self 			assert: (client response contentType matches: ZnMimeType textHtml)			description: 'Response has content type html'.		client isSuccess  ifTrue: [			self 				assert: (client contents includesSubstring: 'pharo.org')				description: 'Response incudes string pharo.org' ]	] ensure: [ client close ]! !!ZnClientTest methodsFor: 'testing' stamp: '8/31/2024 04:18:34' prior: 84139360!testRedirect	| client response target |	target := 'http://zn.stfx.eu'.	client := ZnClient new url: target.	client get.	self assert: client isSuccess.	client		close;		maxNumberOfRedirects: 0;		url: target.	self should: [ client get ] raise: ZnTooManyRedirects.	client close.	response := [		ZnClient new			beOneShot;			maxNumberOfRedirects: 0;			get: target;			response ] on: ZnTooManyRedirects do: [ :exception | exception resume: #doNotRetry ].	self assert: response isRedirect! !!ZnClientTest methodsFor: 'testing' stamp: '8/31/2024 04:18:34'!testRedirectLoopAndTrail	self withServerDo: [ :server | | client count |		server onRequestRespond: [ :request |			request uri firstPathSegment = 'follow'				ifTrue: [ ZnResponse redirect: 'follow' ] ].		(client := ZnClient new)			url: server localUrl; addPath: 'follow';			maxNumberOfRedirects: 10.		self should: [ client get ] raise: ZnTooManyRedirects.		client close.		(client := ZnClient new)			url: server localUrl; addPath: 'follow';			maxNumberOfRedirects: 10.		[ client get ] on: ZnTooManyRedirects do: [ :exception |			self assert: exception isResumable.			self assert: exception trail size equals: 10.			self assert: (exception trail allSatisfy: [ :each | each = (server localUrl / 'follow') ]) ].		client close.				(client := ZnClient new)			url: server localUrl; addPath: 'follow';			maxNumberOfRedirects: 10.		count := 0.		[ client get ] on: ZnTooManyRedirects do: [ :exception |			count := count + 1.			exception trail size <= 30				ifTrue: [ exception resume ]				ifFalse: [ exception resume: #doNotRetry ] ].		self assert: count equals: 4.		client close ]! !!ZnUrlTest methodsFor: '*Zinc-Tests' stamp: '8/31/2024 04:18:34'!testFragmentWithQuestionMark	| urlString url |	urlString := 'http://www.example.com/#fragment?with?question?mark'.	url := urlString asUrl.	self assert: url segments isNil.	self deny: url hasQuery.	self assert: url asString equals: urlString! !"Zinc-Tests"!!ZnSecureServer commentStamp: '' prior: 0!I am ZnSecureServer, an implementation of an HTTPS server.I am a ZnMultiThreadedServer(ZnSecureServer on: 1443)	certificate: '/home/sven/ssl/key-cert.pem';	logToTranscript;	start;	yourself.	Disclaimer: this is an experimental proof of concept.!!ZnSecureServer methodsFor: 'accessing'!certificate	^ certificate! !!ZnSecureServer methodsFor: 'accessing'!certificate: anObject	certificate := anObject! !!ZnSecureServer methodsFor: 'accessing'!scheme	^ #https! !!ZnSecureServer methodsFor: 'private'!socketStreamOn: socket	| stream |	stream := ZdcSecureSocketStream on: socket.	stream sslSession certificateName: self certificate.	stream accept.	^ stream! !"Zinc-Zodiac-Core"!!ZnHTTPSTest class methodsFor: 'accessing' stamp: '8/31/2024 04:18:34' prior: 84444376!defaultTimeLimit	^60 seconds! !!ZnHTTPSTest methodsFor: 'testing' stamp: '8/31/2024 04:18:34' prior: 84435792!testGoogleEncrypted	| client |	self ensureSocketStreamFactory.	self isNativeSSLPluginPresent ifFalse: [ ^ self ].		client := ZnClient new.	client		retryDelay: 1;		numberOfRetries: 3;		get: 'https://encrypted.google.com/search?q=Smalltalk'.		[ 		self 			assert: (client isSuccess or: [client response code = 429])			description: ('Response should be success or 429 code. [{1}] received' format: {				client response  statusLine}).		self 			assert: (client contents includesSubstring: 'Google')			description: 'Response includes string google'.    		client isSuccess  ifTrue: [			self 				assert: (client contents includesSubstring: 'Smalltalk')				description: 'Response includes string Smalltalk ' ]	] ensure: [		client close ]! !"Zinc-Zodiac-Tests"!!BaselineOfNeoJSON commentStamp: '' prior: 0!I am BaselineOfNeoJSON, I load the code for the NeoJSON project.I am a BaselineOf.!!BaselineOfNeoJSON methodsFor: 'baselines' stamp: '3/1/2025 19:49'!baseline: spec	<baseline>	spec		for: #common		do: [ spec				package: 'Neo-JSON-Core';				package: 'Neo-JSON-Tests' with: [ spec requires: #('Neo-JSON-Core') ];				group: 'default' with: #('core' 'tests');				group: 'core' with: #('Neo-JSON-Core');				group: 'tests' with: #('Neo-JSON-Tests') ].	spec		for: #pharo		do: [ spec				package: 'Neo-JSON-Pharo-Core' with: [ spec requires: #('Neo-JSON-Core') ];				package: 'Neo-JSON-Pharo-Tests' with: [ spec requires: #('Neo-JSON-Tests') ];				package: 'Neo-JSON-Pharo-Examples' with: [ spec requires: #('Neo-JSON-Core') ];				group: 'core' with: #('Neo-JSON-Core' 'Neo-JSON-Pharo-Core');				group: 'tests' with: #('Neo-JSON-Tests' 'Neo-JSON-Pharo-Tests');				group: 'examples' with: #('Neo-JSON-Pharo-Examples') ].! !"BaselineOfNeoJSON"!!NeoJSONFloatPrinter commentStamp: '' prior: 0!I am NeoJSONFloatPrinter.I print Float numbers in a compact, human friendly format.The following (default) parameters are used: - base 10 - hardcoded (for now) - precision 5 digits - decimal point - hardcoded (for now) - exponent e - hardcoded (for now) - NaN, Inf and -Inf - hardcoded (for now) - lower 1e-4 - upper 1e6 - decimal notation for abs values inside abs [ lower, upper ] - scientific notation for abs values outside [ lower, upper ] - no padding, no trailing zeros in fraction part - only negative sign, never a positive sign - no thousands separators - no engineering notationSee my class side for configuration examples.My public interface is in the printing protocol.!!NeoJSONMapper commentStamp: '' prior: 0!I am NeoJSONMapper.I hold a mapping from schema identifiers to objects that known how to read or write instances from or to JSON.Schema identifiers are either Smalltalk classes or Symbols.I offer a builder interface to construct mappings. The standard object mapping represents a Smalltalk object as a map, mapping some or all instance variables, or a set of accessors (getter/setter methods). Furthermore, for each value an optional schema can be specified.Using a custom mapping, a reader and/or writer block can deal with special cases such as specific collection types with an optional schema for the elements, or a direct mapping of semi primitive types such as Date or DateAndTime.A mapping can be specified explicitely on a mapper, or can be resolved using the #neoJsonMapping: class method.Here are some examples:	mapper mapAllInstVarsFor: Point.	mapper for: TestObject do: [ :mapping |		mapping mapInstVars: #(id name).		(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.		(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.		(mapping mapInstVar: #bytes) valueSchema: ByteArray ].	mapper for: DateAndTime customDo: [ :mapping |		mapping decoder: [ :string | DateAndTime fromString: string ].		mapping encoder: [ :dateAndTime | dateAndTime printString ] ].	mapper for: #ArrayOfPoints customDo: [ :mapping |		mapping listOfElementSchema: Point ].  	mapper for: ByteArray customDo: [ :mapping |		mapping listOfType: ByteArray ]!!NeoJSONReader commentStamp: '' prior: 0!I am NeoJSONReader.I am a NeoJSONMapper.I parse a JSON representation from a textual stream into Smalltalk objects.Primitive types are automatically mapped to their Smalltalk counterpart: Numbers, Strings, Booleans and UndefinedObject.When parsing using #next, lists normally become Arrays and maps become Dictionaries.An alternative listClass or mapClass can be specified.When parsing using #nextAs: a schema can be specified. This schema defines a mapping to be used.Here are some examples:	NeoJSONReader fromString: ' [ 1,2,3 ] '.	NeoJSONReader fromString: ' [ 3.14159, true, false, null, "string" ] '.	NeoJSONReader fromString: ' { "x" : 1, "y" : 2 } '.		(NeoJSONReader on: ' { "x" : 1, "y" : 2 } ' readStream)		mapInstVarsFor: Point;		nextAs: Point.					(NeoJSONReader on: '[ { "x" : 1, "y" : 2 }, { "x" : 3, "y" : 4 } ]' readStream)		mapInstVarsFor: Point;		for: #ArrayOfPoints customDo: [ :mapping |			mapping listOfElementSchema: Point ];		nextAs: #ArrayOfPoints.	(NeoJSONReader on: '[ { "x" : 1, "y" : 2 }, { "x" : 3, "y" : 4 } ]' readStream)		mapInstVarsFor: Point;		nextListAs: Point.!!NeoJSONWriter commentStamp: '' prior: 0!I am NeoJSONWriter.I am a NeoJSONMapper.I write a JSON representation of Smalltalk objects to a textual stream.Objects implementing #neoJsonOn: can be encoded.A number of primitive types, like Strings, Numbers, Booleans and UndefinedObject are treated specially.Collection are encoded as lists, except for Dictionaries that are encoded as maps.All other objects need a mapping to help in doing the encoding.Here are some examples:	NeoJSONWriter toString: #(1 2 3).	NeoJSONWriter toString: { Float pi. true. false. 'string' }.	NeoJSONWriter toStringPretty: (Dictionary new at: #x put: 1; at: #y put: 2; yourself).		String streamContents: [ :stream |		(NeoJSONWriter on: stream)			prettyPrint: true;			mapInstVarsFor: Point;			nextPut: (Array with: 1@3 with: -1@3) ].	!!NeoJSONMapping commentStamp: '' prior: 0!I am NeoJSONMapping, an abstract superclass for mapping definitions.!!NeoJSONCustomMapping commentStamp: '' prior: 0!I am NeoJSONCustomMapping.I read the next JSON value and turn it into a Smalltalk object using a converter block.!!NeoJSONObjectMapping commentStamp: '' prior: 0!I am NeoJSONObjectMapping.I describe how instances of a Smalltalk class are mapped to a JSON map.I do this using set of NeoJSONPropertyMappings.I know the Smalltalk class that I am a mapping for. This class is the schema identifier and is used to instanciate new objects.A mapping can be based on any combination of instance variables or accessors (getter/setter pairs). I offer a builder interface to constuct property mappings.!!NeoJSONPropertyMapping commentStamp: '' prior: 0!I am NeoJSONPropertyMapping.I describe how a property of a Smalltalk class maps to a JSON property.A property is either an instance variable or getter/setter pair.I hold a getter and setter block to do the actual work. The property name is used in JSON.Optionally, the schema for the value of my property can be specified. This is then used recursively.!!NeoJSONStreamingWriter commentStamp: '' prior: 0!I am NeoJSONStreamingWriter.I help in writing streamed maps and lists.This is an internal class used by NeoJSONWriter to deal with interleaving elements and separators as well as pretty printing.!!NeoJSONMappingNotFound commentStamp: '' prior: 0!I am NeoJSONMappingNotFound. I am signalled when no mapping is found for a schema.Portability comment: In Pharo,  I could technically subclass from NotFound directly, avoid all my defined methods and only keep #messageText and #standardMessageText. However, NotFound exception does not exist in other dialects. To keep NeoJSON as portable as possible we duplicate some Pharo code into myself. !!NeoJSONParseError commentStamp: '' prior: 0!I am NeoJSONParseError.I am an Error.I am signalled when JSON input is not valid while parsing.!!NeoJSONArray commentStamp: '' prior: 0!I am NeoJSONArray.I am an Array.I am often used in combination with NeoJSONObject, to represent the result of parsing JSON.  I support path access for nested instances of me, using #atPath: and #atPath:put: Used in its generic way, NeoJSONParser will return Arrays and Dictionaries.Returning NeoJSONArrays and NeoJSONObjects, simple subclasses, allows to add some convenience methods.!!NeoJSONObject commentStamp: '' prior: 0!I am NeoJSONObject.I am an OrderedDictionary.I behave more like a JavaScript object. I return nil for missing keys. I allow any property to be read or set by using a normal accessor message.The following are equivalent:	self foo.	self at: #foo.As are the following	self foo: 1. 	self at: #foo put: 1.	Except that in the first case, self is returned.I can optionally be used by NeoJSONReader as mapClass (see #mapClass:).For output, I act just like my superclass (it is thus not necessary to do any conversions).Example:	NeoJSONObject fromString: '{"foo":1,"bar":-2}'.	NeoJSONObject new foo: 1; bar: -2.	{ #x -> 100. #y -> 200 } as: NeoJSONObject.	(NeoJSONObject new data: (NeoJSONObject new id: #sensor1; value: 37.5)) asString.I use JSON as my printed representation. To convert me to JSON, use #printString or #asString.Additionally, I support path access for nested instances of me, using #atPath: and #atPath:put:The first is special because it returns nil as soon as a key is missing. The second is special because it creates extra levels (instances of me) as needed to follow the path of keys.	NeoJSONObject new atPath: #(one two three) put: 42; yourself.	NeoJSONObject new atPath: #(one two three) put: 42; atPath: #(one two three).The fact that I am an OrderedDictionary means to I maintain the order of keys. This is meant as a convenience feature only as the official JSON specification clearly states "An object is an unordered set of name/value pairs".I work together with NeoJSONArray.!!NeoJSONFloatPrinter class methodsFor: 'instance creation' stamp: '3/1/2025 19:49'!lowPrecision	^ self new		precision: 2;		lower: 1e-2;		upper: 1e5;		yourself! !!NeoJSONFloatPrinter class methodsFor: 'instance creation' stamp: '3/1/2025 19:49'!scientificOnly	^ self new		lower: 0;		upper: 0;		yourself! !!NeoJSONFloatPrinter methodsFor: 'constants' stamp: '3/1/2025 19:49'!decimalPoint	^ $.! !!NeoJSONFloatPrinter methodsFor: 'constants' stamp: '3/1/2025 19:49'!exponent	^ $e! !!NeoJSONFloatPrinter methodsFor: 'constants' stamp: '3/1/2025 19:49'!infinite	^ 'Inf'! !!NeoJSONFloatPrinter methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!initialize	super initialize.	base := 10.	precision := 5.	lower := 1e-4.	upper := 1e6! !!NeoJSONFloatPrinter methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!lower: number	lower := number! !!NeoJSONFloatPrinter methodsFor: 'constants' stamp: '3/1/2025 19:49'!nan	^ 'NaN'! !!NeoJSONFloatPrinter methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!precision: numberOfDigits	self assert: (numberOfDigits between: 1 and: 20).	precision := numberOfDigits! !!NeoJSONFloatPrinter methodsFor: 'printing' stamp: '3/1/2025 19:49'!print: float	^ String new: 16 streamContents: [ :out | 			self print: float on: out ]! !!NeoJSONFloatPrinter methodsFor: 'private' stamp: '3/1/2025 19:49'!print: float decimalOn: stream	stream print: float asInteger.	stream nextPut: self decimalPoint.	self 		print: (float fractionPart * (base raisedTo: precision)) rounded 		fractionOn: stream! !!NeoJSONFloatPrinter methodsFor: 'private' stamp: '3/1/2025 19:49'!print: fractionPart fractionOn: stream	| zeros |	zeros := 0. "leading zeros are significant, trailing zeros are not printed"	precision to: 1 by: -1 do: [ :position | | digit |		digit := fractionPart digitAt: position base: base.		digit = 0			ifTrue: [ zeros := zeros +1 ]			ifFalse: [				zeros > 0 ifTrue: [ 					zeros timesRepeat: [ stream nextPut: $0 ]. 					zeros := 0 ].				stream nextPut: digit asCharacterDigit ] ]! !!NeoJSONFloatPrinter methodsFor: 'printing' stamp: '3/1/2025 19:49'!print: float on: stream	| int abs |	(float isZero or: [ float isFinite not ])		ifTrue: [ ^ self print: float specialOn: stream ].	self print: float signOn: stream.	((abs := float abs) between: lower and: upper)		ifTrue: [ 			(int := abs asInteger) = abs 				ifTrue: [ int printOn: stream ]				ifFalse: [ self print: abs decimalOn: stream ] ]		ifFalse: [ self print: abs scientificOn: stream ]! !!NeoJSONFloatPrinter methodsFor: 'private' stamp: '3/1/2025 19:49'!print: float scientificOn: stream	| exponent mantissa |	exponent := (float ln / base ln) floor.	mantissa := float / (base raisedTo: exponent).	self print: mantissa decimalOn: stream.	stream		nextPut: self exponent;		print: exponent! !!NeoJSONFloatPrinter methodsFor: 'private' stamp: '3/1/2025 19:49'!print: float signOn: stream	float sign = -1		ifTrue: [ stream nextPut: $- ]! !!NeoJSONFloatPrinter methodsFor: 'private' stamp: '3/1/2025 19:49'!print: float specialOn: stream	float isZero		ifTrue: [ 			stream nextPut: $0 ]		ifFalse: [			float isNaN 				ifTrue: [ 					stream nextPutAll: self nan ]				ifFalse: [					self print: float signOn: stream.					stream nextPutAll: self infinite ] ]! !!NeoJSONFloatPrinter methodsFor: 'printing' stamp: '3/1/2025 19:49'!printFloat: float on: stream	self print: float on: stream! !!NeoJSONFloatPrinter methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!upper: number	upper := number! !!NeoJSONMapper methodsFor: 'private' stamp: '3/1/2025 19:49'!customMappingFor: schemaName	^ self mappings		at: schemaName		ifAbsentPut: [ 			NeoJSONCustomMapping new				schemaName: schemaName;				yourself ]! !!NeoJSONMapper methodsFor: 'mapping' stamp: '3/1/2025 19:49'!for: schemaName customDo: block	"Execute the code in block to further customize the mapping for schemaName.	Create and add a new custom mapping for schemaName if necessary."		| mapping |	mapping := self customMappingFor: schemaName.	block value: mapping.	^ mapping! !!NeoJSONMapper methodsFor: 'mapping' stamp: '3/1/2025 19:49'!for: smalltalkClass do: block	"Execute the code in block to further customize the mapping for schemaName.	Create and add a new standard object mapping for schemaName if necessary."		| mapping |	mapping := self objectMappingFor: smalltalkClass.	block value: mapping.	^ mapping! !!NeoJSONMapper methodsFor: 'convencience' stamp: '3/1/2025 19:49'!mapAllInstVarsFor: smalltalkClass	"Map the instance variables of smalltalkClass and all its super classes"	| mapping |	mapping := self objectMappingFor: smalltalkClass.	mapping mapAllInstVars.	^ mapping! !!NeoJSONMapper methodsFor: 'convencience' stamp: '3/1/2025 19:49'!mapInstVarsFor: smalltalkClass	"Map the instance variables of smalltalkClass"	| mapping |	mapping := self objectMappingFor: smalltalkClass.	mapping mapInstVars.	^ mapping! !!NeoJSONMapper methodsFor: 'accessing' stamp: '3/1/2025 19:49'!mappingFor: schema	^ self 		mappingFor: schema 		ifAbsent: [ NeoJSONMappingNotFound signalFor: schema in: self ]! !!NeoJSONMapper methodsFor: 'accessing' stamp: '3/1/2025 19:49'!mappingFor: schema ifAbsent: block	(self mappings includesKey: schema)		ifFalse: [ self resolveMappingFor: schema ].	^ self mappings		at: schema		ifAbsent: block! !!NeoJSONMapper methodsFor: 'private' stamp: '3/1/2025 19:49'!mappings	^ mappings		ifNil: [ mappings := Dictionary new ]! !!NeoJSONMapper methodsFor: 'private' stamp: '3/1/2025 19:49'!objectMappingFor: smalltalkClass	^ self mappings		at: smalltalkClass		ifAbsentPut: [ 			NeoJSONObjectMapping new				subjectClass: smalltalkClass;				yourself ]! !!NeoJSONMapper methodsFor: 'private' stamp: '3/1/2025 19:49'!resolveMappingFor: class	(class respondsTo: #neoJsonMapping:)		ifTrue: [ 			class perform: #neoJsonMapping: with: self ]! !!NeoJSONReader class methodsFor: 'example' stamp: '3/1/2025 19:49'!exampleCoordinatesCustomParsing	<gtExample>	| reader |	reader := self on: self exampleCoordinatesJSON readStream.	reader mapAllInstVarsFor: Point.	reader for: #ArrayOfPoints customDo: [ :mapping |		mapping listOfElementSchema: Point ].	^ reader nextAs: #ArrayOfPoints ! !!NeoJSONReader class methodsFor: 'example' stamp: '3/1/2025 19:49'!exampleCoordinatesGenericParsing	<gtExample>	^ self fromString: self exampleCoordinatesJSON! !!NeoJSONReader class methodsFor: 'example' stamp: '3/1/2025 19:49'!exampleCoordinatesJSON	<gtExample>	^ '[{"x":0,"y":0},{"x":1,"y":2},{"x":2,"y":4},{"x":3,"y":6},{"x":4,"y":8}]'! !!NeoJSONReader class methodsFor: 'convenience' stamp: '3/1/2025 19:49'!fromString: string	^ (self on: string readStream) next! !!NeoJSONReader class methodsFor: 'convenience' stamp: '3/1/2025 19:49'!fromString: string as: schema	^ (self on: string readStream) nextAs: schema! !!NeoJSONReader class methodsFor: 'instance creation' stamp: '3/1/2025 19:49'!on: readStream	"Initialize on readStream, which should be a character stream that 	implements #next, #peek, #atEnd and (optionally) #close."	^ self new		on: readStream;		yourself! !!NeoJSONReader methodsFor: 'testing' stamp: '3/1/2025 19:49'!atEnd	^ readStream atEnd! !!NeoJSONReader methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!close	readStream ifNotNil: [		readStream close.		readStream := nil ]! !!NeoJSONReader methodsFor: 'private' stamp: '3/1/2025 19:49'!consumeWhitespace	"Strip whitespaces from the input stream."	[ readStream atEnd not and: [ readStream peek isSeparator ] ]		whileTrue: [ 			readStream next ]! !!NeoJSONReader methodsFor: 'private' stamp: '3/1/2025 19:49'!error: text	NeoJSONParseError signal: text! !!NeoJSONReader methodsFor: 'private' stamp: '3/1/2025 19:49'!expectChar: character	"Expect character and consume input and optional whitespace at the end,	 throw an error otherwise."	(self matchChar: character)		ifFalse: [ self error: character asString, ' expected' ]! !!NeoJSONReader methodsFor: 'parsing' stamp: '3/1/2025 19:49'!failIfNotAtEnd	self atEnd		ifFalse: [ self error: 'extraneous input detected' ]! !!NeoJSONReader methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!initialize 	super initialize.	propertyNamesAsSymbols := false! !!NeoJSONReader methodsFor: 'accessing' stamp: '3/1/2025 19:49'!listClass	"Return the collection type to use for JSON lists"		^ listClass ifNil: [ Array ]! !!NeoJSONReader methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!listClass: collectionClass	listClass := collectionClass! !!NeoJSONReader methodsFor: 'accessing' stamp: '3/1/2025 19:49'!mapClass	"Return the collection type to use for JSON maps"		^ mapClass ifNil: [ Dictionary ]! !!NeoJSONReader methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!mapClass: collectionClass	mapClass := collectionClass! !!NeoJSONReader methodsFor: 'private' stamp: '3/1/2025 19:49'!match: string do: block	"Try to read and consume string and execute block if successful.	Else do nothing (but do not back up)"	(string allSatisfy: [ :each | readStream peekFor: each ])		ifTrue: [ 			self consumeWhitespace.			block value ]! !!NeoJSONReader methodsFor: 'private' stamp: '3/1/2025 19:49'!matchChar: character	"Tries to match character, consume input and 	answer true if successful and consumes whitespace at the end.	When character does not match, return false and leave stream untouched."	^ (readStream peekFor: character)		ifTrue: [ 			self consumeWhitespace.			true ]		ifFalse: [ false ]! !!NeoJSONReader methodsFor: 'accessing' stamp: '3/1/2025 19:49'!next	"Primary interface to parse a JSON value.	Return either primitives, a listClass or a mapClass instance."		^ self 		consumeWhitespace; 		parseValue! !!NeoJSONReader methodsFor: 'accessing' stamp: '3/1/2025 19:49'!nextAs: schema	"Secondary interface to parse JSON.	Return an object according to schema.	If schema is nil, act like #next"		| mapping |	schema ifNil: [ ^ self next ].	self consumeWhitespace.	mapping := self mappingFor: schema.	^ mapping readFrom: self! !!NeoJSONReader methodsFor: 'accessing' stamp: '3/1/2025 19:49'!nextListAs: schema	"Secondary interface to parse JSON.	Return a list of objects, each element according to schema."		^ self listClass streamContents: [ :stream |			self parseListDo: [ 				stream nextPut: (self nextAs: schema) ] ]! !!NeoJSONReader methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!on: aReadStream	"Initialize on aReadStream, which should be a character stream that 	implements #next, #peek, #atEnd and (optionally) #close."		readStream := aReadStream! !!NeoJSONReader methodsFor: 'parsing' stamp: '3/1/2025 19:49'!parseCharacter	| char |	(char := readStream next) = $\ 		ifFalse: [ ^ char ].	('/"\' includes: (char := readStream next))		ifTrue: [ ^ char ].	('bfnrt' includes: char)		ifTrue: [ ^ self unescapeChar: char ].	char = $u		ifTrue: [ ^ self parseCharacterHex ].	char 		ifNil: [ self error: 'invalid escape, end of file' ]		ifNotNil: [ self error: 'invalid escape character \' , char asString ]! !!NeoJSONReader methodsFor: 'private' stamp: '3/1/2025 19:49'!parseCharacterHex	| value codePoint |	value := self parseCharacterHex4Value.	(value < 16rD800 or: [ value > 16rDBFF ])		ifTrue: [ codePoint := value ]		ifFalse: [ | leadSurrogate trailSurrogate |			"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"			"See https://tools.ietf.org/html/rfc7159#section-7"			leadSurrogate := value.			trailSurrogate := self parseTrailingSurrogateHexEscape.			codePoint := (leadSurrogate - 16rD800) * 16r400 + (trailSurrogate - 16rDC00).			codePoint := 16r10000 + codePoint.			codePoint > 16r10FFFF 				ifTrue: [ self error: 'Character Unicode code point outside encoder range' ] ].	^ Character codePoint: codePoint! !!NeoJSONReader methodsFor: 'private' stamp: '3/1/2025 19:49'!parseCharacterHex4Value	| value |	value := self parseCharacterHexDigit.	3 timesRepeat: [ 		value := (value << 4) + self parseCharacterHexDigit ].	^ value! !!NeoJSONReader methodsFor: 'private' stamp: '3/1/2025 19:49'!parseCharacterHexDigit	| digit |	readStream atEnd 		ifFalse: [ 			digit := readStream next asInteger.			(digit between: "$0" 48 and: "$9" 57)				ifTrue: [ ^ digit - 48 ].			(digit between: "$A" 65 and: "$F" 70)				ifTrue: [ ^ digit - 55 ].			(digit between: "$a" 97 and: "$f" 102)				ifTrue: [ ^ digit - 87 ] ].	self error: 'hex-digit expected'! !!NeoJSONReader methodsFor: 'private' stamp: '3/1/2025 19:49'!parseConstantDo: block	"Parse and consume either true|false|nil|null and execute block 	or else do nothing (but do not back up).	Hand written implementation to avoid the use of #position:"		(readStream peek = $t)		ifTrue: [			^ self match: 'true' do: [ block value: true ] ].	(readStream peek = $f)		ifTrue: [			^ self match: 'false' do: [ block value: false ] ].	(readStream peek = $n)		ifTrue: [			^ self match: 'null' do: [ block value: nil ] ]! !!NeoJSONReader methodsFor: 'parsing' stamp: '3/1/2025 19:49'!parseList	^ self listClass 		streamContents: [ :stream |			self parseListElementsDo: [ :each |				stream nextPut: each ] ]		! !!NeoJSONReader methodsFor: 'parsing' stamp: '3/1/2025 19:49'!parseListDo: block	self expectChar: $[.	(self matchChar: $]) 		ifTrue: [ ^ self ].	[ readStream atEnd ] 		whileFalse: [			block value.			(self matchChar: $]) 				ifTrue: [ ^ self ].			(self matchChar: $,)				ifFalse: [ self error: ', or ] expected' ] ].	self error: 'incomplete list'! !!NeoJSONReader methodsFor: 'parsing' stamp: '3/1/2025 19:49'!parseListElementsDo: block	self parseListDo: [ 		block value: self parseValue ]! !!NeoJSONReader methodsFor: 'parsing' stamp: '3/1/2025 19:49'!parseMap	| map |	map := self mapClass new.	self parseMapKeysAndValuesDo: [ :key :value |		map at: key put: value ].	^ map! !!NeoJSONReader methodsFor: 'parsing' stamp: '3/1/2025 19:49'!parseMapDo: block	self expectChar: ${.	(self matchChar: $})		ifTrue: [ ^ self ].	[ readStream atEnd ] whileFalse: [		block value.		(self matchChar: $}) 			ifTrue: [ ^ self ].		(self matchChar: $,)			ifFalse: [ self error: ', or } expected' ] ].	self error: 'incomplete map'! !!NeoJSONReader methodsFor: 'parsing' stamp: '3/1/2025 19:49'!parseMapKeysAndValuesDo: block	self parseMapKeysDo: [ :key |		block value: key value: self parseValue ]! !!NeoJSONReader methodsFor: 'parsing' stamp: '3/1/2025 19:49'!parseMapKeysDo: block	self parseMapDo: [ | key |		key := self parsePropertyName.		self expectChar: $:.		block value: key ]! !!NeoJSONReader methodsFor: 'parsing' stamp: '3/1/2025 19:49'!parseNumber	| negated number isFloat |	negated := readStream peekFor: $-.	number := self parseNumberInteger.	isFloat := (readStream peekFor: $.)		ifTrue: [ number := number + self parseNumberFraction. true ]		ifFalse: [ false ].	((readStream peekFor: $e) or: [ readStream peekFor: $E ])		ifTrue: [ number := number * self parseNumberExponent ].	isFloat ifTrue: [ number := number asFloat ].	negated		ifTrue: [ number := number negated ].	self consumeWhitespace.	^ number! !!NeoJSONReader methodsFor: 'parsing' stamp: '3/1/2025 19:49'!parseNumberExponent	| number negated |	number := 0.	(negated := readStream peekFor: $-)		ifFalse: [ readStream peekFor: $+ ].	(readStream atEnd or: [ readStream peek isDigit not ])		ifTrue: [ self error: 'number exponent expected' ].	[ readStream atEnd not and: [ readStream peek isDigit ] ]		whileTrue: [ number := 10 * number + readStream next digitValue ].	negated		ifTrue: [ number := number negated ].	number positive 		ifTrue: [ number > Float emax ifTrue: [ self error: 'number exponent too large' ] ]		ifFalse: [ number < Float emin ifTrue: [ self error: 'number exponent too small' ] ].	^ 10 raisedTo: number! !!NeoJSONReader methodsFor: 'parsing' stamp: '3/1/2025 19:49'!parseNumberFraction	| number power |	number := 0.	power := 1.	[ readStream atEnd not and: [ readStream peek isDigit ] ] 		whileTrue: [			number := 10 * number + readStream next digitValue.			power := power * 10 ].	^ number / power! !!NeoJSONReader methodsFor: 'parsing' stamp: '3/1/2025 19:49'!parseNumberInteger	| number |	number := nil.	[ readStream atEnd not and: [ readStream peek isDigit ] ] 		whileTrue: [ 			number := 10 * (number ifNil: [ 0 ]) + readStream next digitValue ].	number ifNil: [ self error: 'Integer digit expected' ].	^ number! !!NeoJSONReader methodsFor: 'parsing' stamp: '3/1/2025 19:49'!parsePropertyName	| name |	name := self parseValue.	^ name isString		ifTrue: [ 			propertyNamesAsSymbols 				ifTrue: [ name asSymbol ]				ifFalse: [ name ] ]		ifFalse: [ 			self error: 'property name must be a string, not ', name asString ]! !!NeoJSONReader methodsFor: 'parsing' stamp: '3/1/2025 19:49'!parseString	| result |	(readStream peekFor: $")		ifFalse: [ self error: '" expected' ].	result := self stringStreamContents: [ :stream | 		[ readStream atEnd or: [ readStream peek = $" ] ] 			whileFalse: [ stream nextPut: self parseCharacter ] ].	self expectChar: $".	^ result! !!NeoJSONReader methodsFor: 'private' stamp: '3/1/2025 19:49'!parseTrailingSurrogateHexEscape	(readStream next = $\ and: [ readStream next = $u ])		ifTrue: [ ^ self parseCharacterHex4Value ]		ifFalse: [ self error: 'trailing surrogate hex escape expected' ]! !!NeoJSONReader methodsFor: 'parsing' stamp: '3/1/2025 19:49'!parseValue	| char |	readStream atEnd ifFalse: [ 		char := readStream peek.		char = ${			ifTrue: [ ^ self parseMap ].		char = $[			ifTrue: [ ^ self parseList ].		char = $"			ifTrue: [ ^ self parseString ].		(char = $- or: [ char isDigit ])			ifTrue: [ ^ self parseNumber ].		self parseConstantDo: [ :value | ^ value ] ].	self error: 'invalid input: ', char asString! !!NeoJSONReader methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!propertyNamesAsSymbols: boolean	propertyNamesAsSymbols := boolean! !!NeoJSONReader methodsFor: 'private' stamp: '3/1/2025 19:49'!stringStreamClass	"Answer the class of the collection used for the stringStream of receiver.		NOTE: It is String, but if receiver's readStream is over 	another class of String, then this provides compatibility for that."	^ readStream collectionSpecies! !!NeoJSONReader methodsFor: 'private' stamp: '3/1/2025 19:49'!stringStreamContents: block	"Like String streamContents: block	but reusing the underlying buffer for improved efficiency"	stringStream ifNil: [ 		stringStream := (self stringStreamClass new: 32) writeStream ].	stringStream reset.	block value: stringStream.	^ stringStream contents! !!NeoJSONReader methodsFor: 'private' stamp: '3/1/2025 19:49'!unescapeChar: char	"Handle one of the named character escapes, b, f, n, r or t. Else fail."		char = $b		ifTrue: [ ^ Character backspace ].	char = $f		ifTrue: [ ^ Character newPage ].	char = $n		ifTrue: [ ^ Character lf ].	char = $r		ifTrue: [ ^ Character cr ].	char = $t		ifTrue: [ ^ Character tab ].	self error: 'Unknown escape char: ', (String with: char)! !!NeoJSONReader methodsFor: 'accessing' stamp: '3/1/2025 19:49'!upToEnd	"Parse and collect JSON values from my stream until it ends, returning the collection.	This supports Newline delimited JSON (application/x-ndjson) & JSON Lines (application/jsonl).	Warning: though each element is valid JSON, taken as a whole the result is non-valid JSON."		^ Array streamContents: [ :out |		[ self atEnd ] whileFalse: [ out nextPut: self next ] ]! !!NeoJSONWriter class methodsFor: 'example' stamp: '3/1/2025 19:49'!exampleCoordinates	<gtExample>	^ { 0@0 . 1@2. 2@4. 3@6 . 4@8}! !!NeoJSONWriter class methodsFor: 'example' stamp: '3/1/2025 19:49'!exampleCoordinatesCustomWriting	<gtExample>	^ String streamContents: [ :out |		| writer |		writer := self on: out.		writer mapAllInstVarsFor: Point.		writer nextPut: self exampleCoordinates ]! !!NeoJSONWriter class methodsFor: 'example' stamp: '3/1/2025 19:49'!exampleCoordinatesGeneric	<gtExample>	^ (0 to: 4) collect: [ :each | { 'x' -> each . 'y' -> (each * 2) } asDictionary ] ! !!NeoJSONWriter class methodsFor: 'example' stamp: '3/1/2025 19:49'!exampleCoordinatesGenericWriting	<gtExample>	^ self toString: self exampleCoordinatesGeneric! !!NeoJSONWriter class methodsFor: 'instance creation' stamp: '3/1/2025 19:49'!on: writeStream	"Initialize on writeStream, which should be a character stream that 	implements #nextPut:, #nextPutAll:, #space and (optionally) #close."	^ self new		on: writeStream;		yourself! !!NeoJSONWriter class methodsFor: 'convenience' stamp: '3/1/2025 19:49'!toString: object	^ String streamContents: [ :stream |			(self on: stream) nextPut: object ]! !!NeoJSONWriter class methodsFor: 'convenience' stamp: '3/1/2025 19:49'!toStringPretty: object	^ String streamContents: [ :stream |			(self on: stream)				prettyPrint: true; 				nextPut: object ]! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!asciiOnly: boolean	"Set whether I should escape all non ASCII characters or not"		asciiOnly := boolean! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!close	"Close the stream that I write to"		writeStream ifNotNil: [		writeStream close.		writeStream := nil ]! !!NeoJSONWriter methodsFor: 'private' stamp: '3/1/2025 19:49'!doesCodePointNeedEscaping: code	code < 32 ifTrue: [ ^ true ].	( code = 34 or: [ code = 92 ]) ifTrue: [ ^ true ].	^ asciiOnly and: [ code > 126 ]	! !!NeoJSONWriter methodsFor: 'private' stamp: '3/1/2025 19:49'!encodeChar: char	| code |	code := char codePoint.	(self doesCodePointNeedEscaping: code)		ifTrue: [ self escapeChar: code ]		ifFalse: [ writeStream nextPut: char ]! !!NeoJSONWriter methodsFor: 'private' stamp: '3/1/2025 19:49'!encodeKey: key	key isString ifFalse: [ ^ self error: 'JSON key names in objects must be strings' ].	self nextPut: key.	self prettyPrintSpace.	writeStream nextPut: $:.	self prettyPrintSpace! !!NeoJSONWriter methodsFor: 'private' stamp: '3/1/2025 19:49'!encodeKey: key value: value	self encodeKey: key.	self nextPut: value! !!NeoJSONWriter methodsFor: 'private' stamp: '3/1/2025 19:49'!encodeKey: key value: value as: valueSchema	self encodeKey: key.	self nextPut: value as: valueSchema! !!NeoJSONWriter methodsFor: 'private' stamp: '3/1/2025 19:49'!escapeChar: code	code = 34		ifTrue: [ ^ writeStream nextPutAll: '\"' ].	code = 92		ifTrue: [ ^ writeStream nextPutAll: '\\' ].	code = 47		ifTrue: [ ^ writeStream nextPutAll: '\/' ].	code = 8		ifTrue: [ ^ writeStream nextPutAll: '\b' ].	code = 12		ifTrue: [ ^ writeStream nextPutAll: '\f' ].			code = 10		ifTrue: [ ^ writeStream nextPutAll: '\n' ].			code = 13		ifTrue: [ ^ writeStream nextPutAll: '\r' ].			code = 9		ifTrue: [ ^ writeStream nextPutAll: '\t' ].			self escapeUnicode: code! !!NeoJSONWriter methodsFor: 'private' stamp: '3/1/2025 19:49'!escapeUnicode4: codePoint	writeStream nextPutAll: '\u'.	codePoint printOn: writeStream base: 16 nDigits: 4! !!NeoJSONWriter methodsFor: 'private' stamp: '3/1/2025 19:49'!escapeUnicode: codePoint	codePoint <= 16rFFFF		ifTrue: [ self escapeUnicode4: codePoint ]		ifFalse: [ 			codePoint <= 16r10FFFF				ifTrue: [ | leadSurrogate trailSurrogate shifted |					"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"					"See https://tools.ietf.org/html/rfc7159#section-7"					shifted := codePoint - 16r10000.					leadSurrogate := 16rD800 + (shifted // 16r400).					trailSurrogate := 16rDC00 + (shifted \\ 16r400).					self escapeUnicode4: leadSurrogate.					self escapeUnicode4: trailSurrogate ]				ifFalse: [ self error: 'Character Unicode code point outside encoder range' ] ]! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!floatPrinter: anObject	"Set the float print, an object that implements #printFloat:on:	By default, I am my own float printer"		floatPrinter := anObject! !!NeoJSONWriter methodsFor: 'private' stamp: '3/1/2025 19:49'!indentedDo: block	level := level + 1.	block value.	level := level - 1! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!initialize	super initialize.	self newLine: OSPlatform current lineEnding.	self prettyPrint: false.	self asciiOnly: false.	self writeNil: false.	self floatPrinter: self.	level := 0! !!NeoJSONWriter methodsFor: 'private' stamp: '3/1/2025 19:49'!listElementSeparator	writeStream nextPut: $,.	self newlineIndent! !!NeoJSONWriter methodsFor: 'private' stamp: '3/1/2025 19:49'!mapElementSeparator	writeStream nextPut: $,.	self newlineIndent! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!newLine: string	"Set the newline string that I should use when pretty printing"		newLine := string! !!NeoJSONWriter methodsFor: 'accessing' stamp: '3/1/2025 19:49'!newline	"Write a newline on the stream that I wrap.	What gets written depends on the configuration, see #newLine:"		writeStream nextPutAll: newLine! !!NeoJSONWriter methodsFor: 'private' stamp: '3/1/2025 19:49'!newlineIndent	prettyPrint		ifTrue: [ 			self newline.			level timesRepeat: [ writeStream nextPut: Character tab ] ]! !!NeoJSONWriter methodsFor: 'accessing' stamp: '3/1/2025 19:49'!nextPut: anObject	"Primary interface. Write a JSON representation of anObject to my stream."		anObject neoJsonOn: self! !!NeoJSONWriter methodsFor: 'accessing' stamp: '3/1/2025 19:49'!nextPut: anObject as: schema	"Secondary interface to write JSON.	Write objects according to schema."		| mapping |	(schema isNil or: [ anObject isNil ]) ifTrue: [ ^ self nextPut: anObject ].	mapping := self mappingFor: schema.	^ mapping writeObject: anObject on: self! !!NeoJSONWriter methodsFor: 'accessing' stamp: '3/1/2025 19:49'!nextPutAll: aCollection	"Write a separate JSON representation of all objects in aCollection to my stream.	This supports Newline delimited JSON (application/x-ndjson) & JSON Lines (application/jsonl).	Warning: though each element is valid JSON, taken as a whole the result is non-valid JSON."		aCollection do: [ :each |		self nextPut: each.		self newline ]! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!on: aWriteStream	"Initialize on aWriteStream, which should be a character stream that 	implements #nextPut:, #nextPutAll:, #space and (optionally) #close."	writeStream := aWriteStream! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!prettyPrint: boolean	"Set whether I should pretty print the JSON that I write"	prettyPrint := boolean! !!NeoJSONWriter methodsFor: 'private' stamp: '3/1/2025 19:49'!prettyPrintSpace	prettyPrint		ifTrue: [ writeStream nextPut: Character space ]! !!NeoJSONWriter methodsFor: 'printing' stamp: '3/1/2025 19:49'!printFloat: float on: stream	"See NeoJSONFloatPrinter for a custom float printer"		float printOn: stream! !!NeoJSONWriter methodsFor: 'writing' stamp: '3/1/2025 19:49'!writeBoolean: boolean	boolean printOn: writeStream! !!NeoJSONWriter methodsFor: 'writing' stamp: '3/1/2025 19:49'!writeFloat: float	floatPrinter printFloat: float on: writeStream! !!NeoJSONWriter methodsFor: 'writing' stamp: '3/1/2025 19:49'!writeInteger: integer	integer printOn: writeStream	! !!NeoJSONWriter methodsFor: 'writing' stamp: '3/1/2025 19:49'!writeList: collection	self writeListStreamingDo: [ :jsonListWriter |		collection do: [ :each |			jsonListWriter writeElement: each ] ]! !!NeoJSONWriter methodsFor: 'writing' stamp: '3/1/2025 19:49'!writeListStreamingDo: block	writeStream nextPut: $[.	self writeStreamingDo: block.	writeStream nextPut: $]! !!NeoJSONWriter methodsFor: 'writing' stamp: '3/1/2025 19:49'!writeMap: keyValueCollection	self writeMapStreamingDo: [ :jsonMapWriter |		keyValueCollection keysAndValuesDo: [ :key :value |			jsonMapWriter writeKey: key value: value ] ]! !!NeoJSONWriter methodsFor: 'writing' stamp: '3/1/2025 19:49'!writeMapStreamingDo: block	writeStream nextPut: ${.	self writeStreamingDo: block.	writeStream nextPut: $}! !!NeoJSONWriter methodsFor: 'accessing' stamp: '3/1/2025 19:49'!writeNil	"Return whether I will write nil/null properties of objects or skip them."		^ writeNil! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!writeNil: boolean	"Set whether I will write nil/null properties of objects or skip them."		writeNil := boolean! !!NeoJSONWriter methodsFor: 'writing' stamp: '3/1/2025 19:49'!writeNull	writeStream nextPutAll: 'null'! !!NeoJSONWriter methodsFor: 'writing' stamp: '3/1/2025 19:49'!writeObject: anObject	| mapping |	mapping := self mappingFor: anObject class.	mapping		writeObject: anObject		on: self! !!NeoJSONWriter methodsFor: 'writing' stamp: '3/1/2025 19:49'!writeStreamingDo: block	| mapWriter |	mapWriter := NeoJSONStreamingWriter on: self.	self indentedDo: [		block value: mapWriter ].	mapWriter wasUsed		ifTrue: [ self newlineIndent ]		ifFalse: [ self prettyPrintSpace ]! !!NeoJSONWriter methodsFor: 'writing' stamp: '3/1/2025 19:49'!writeString: string	writeStream nextPut: $".	1 to: string size do: [ :index |		self encodeChar: (string at: index) ].	writeStream nextPut: $"! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: '3/1/2025 19:49'!decoder: block	"Set a decoder block that accepts the next object representation read 	and converts it into the actual object to be returned."	self reader: [ :jsonReader | | representation |		representation := jsonReader next.		block value: representation ]! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: '3/1/2025 19:49'!encoder: block	"Set a encoder block that accepts the next object to be written 	and converts it into the actual representation to be written."	self writer: [ :jsonWriter :anObject | | representation |		representation := block value: anObject.		jsonWriter nextPut: representation ]! !!NeoJSONCustomMapping methodsFor: 'accessing' stamp: '3/1/2025 19:49'!identifier	^ schemaName ! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: '3/1/2025 19:49'!listOfElementSchema: elementSchema	"Set the reader to a block that will create an instance of the	standard listClass while reading a list of elements of type elementSchema.	Pass down the elementSchema to the elements in the writer."	self reader: [ :jsonReader |		jsonReader listClass streamContents: [ :stream |			jsonReader parseListDo: [ | element |				element := jsonReader nextAs: elementSchema.				stream nextPut: element ] ] ].	self writer: [ :jsonWriter :list | 		jsonWriter writeListStreamingDo: [ :listWriter |			list do: [ :each |				listWriter writeElement: each as: elementSchema ] ] ]! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: '3/1/2025 19:49'!listOfType: collectionClass	"Set the reader to a block that will create an instance of collectionClass 	using #streamContents: while reading a list of elements.	Set the writer to write the list's elements."	self reader: [ :jsonReader |		collectionClass streamContents: [ :stream |			jsonReader parseListDo: [ | element |				element := jsonReader next.				stream nextPut: element ] ] ].	self writer: [ :jsonWriter :list | 		jsonWriter writeListStreamingDo: [ :listWriter |			list do: [ :each |				listWriter writeElement: each ] ] ]! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: '3/1/2025 19:49'!listOfType: collectionClass andElementSchema: elementSchema	"Set the reader to a block that will create an instance of collectionClass 	using #streamContents: while reading a list of elements of type elementSchema.	Pass down the elementSchema to the elements in the writer."	self reader: [ :jsonReader |		collectionClass streamContents: [ :stream |			jsonReader parseListDo: [ | element |				element := jsonReader nextAs: elementSchema.				stream nextPut: element ] ] ].	self writer: [ :jsonWriter :list | 		jsonWriter writeListStreamingDo: [ :listWriter |			list do: [ :each | 				listWriter writeElement: each as: elementSchema ] ] ]! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: '3/1/2025 19:49'!mapWithValueSchema: valueSchema	"Set the reader to a block that will create an instance of the	standard mapClass while reading values of type valueSchema,	with standard keys"	self reader: [ :jsonReader | | map |		map := jsonReader mapClass new.		jsonReader parseMapKeysDo: [ :key | | value |				value := jsonReader nextAs: valueSchema.				map at: key put: value ].		map ].	self writer: [ :jsonWriter :map | 		jsonWriter writeMapStreamingDo: [ :mapWriter |			map keysAndValuesDo: [ :key :value | 				mapWriter writeKey: key value: value as: valueSchema ] ] ]! !!NeoJSONCustomMapping methodsFor: 'parsing' stamp: '3/1/2025 19:49'!readFrom: jsonReader	^ reader 		ifNil: [ jsonReader next ]		ifNotNil: [ reader value: jsonReader ]! !!NeoJSONCustomMapping methodsFor: 'accessing' stamp: '3/1/2025 19:49'!reader: block	"Set the reader to block, a 1 argument block that when given 	a jsonReader as argument reads the object that I represent.	When there is no reader block, the default #next will be used."		reader := block! !!NeoJSONCustomMapping methodsFor: 'accessing' stamp: '3/1/2025 19:49'!schemaName: schema	schemaName := schema! !!NeoJSONCustomMapping methodsFor: 'writing' stamp: '3/1/2025 19:49'!writeObject: anObject on: jsonWriter	writer 		ifNil: [ anObject neoJsonOn: jsonWriter ]		ifNotNil: [ writer value: jsonWriter value: anObject ]! !!NeoJSONCustomMapping methodsFor: 'accessing' stamp: '3/1/2025 19:49'!writer: block	"Set the writer to block, a 2 argument block that when given: a jsonWriter 	and the object to write will write the object that I represent.	When there is no writer block, the default #neoJsonOn: will be used."		writer := block! !!NeoJSONMapping methodsFor: 'accessing' stamp: '3/1/2025 19:49'!identifier	self subclassResponsibility ! !!NeoJSONMapping methodsFor: 'printing' stamp: '3/1/2025 19:49'!printOn: stream	super printOn: stream.	stream nextPut: $(; print: self identifier; nextPut: $)! !!NeoJSONMapping methodsFor: 'parsing' stamp: '3/1/2025 19:49'!readFrom: jsonReader	self subclassResponsibility ! !!NeoJSONMapping methodsFor: 'writing' stamp: '3/1/2025 19:49'!writeObject: anObject on: jsonWriter	self subclassResponsibility ! !!NeoJSONObjectMapping methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!allowNil	"Set that I will allow nil/null values when I read/expect an object"		allowNil := true! !!NeoJSONObjectMapping methodsFor: 'accessing' stamp: '3/1/2025 19:49'!identifier	^ subjectClass ! !!NeoJSONObjectMapping methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!initialize	super initialize.	properties := OrderedCollection new.	allowNil := false! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: '3/1/2025 19:49'!mapAccessor: accessor	^ self mapAccessor: accessor to: accessor ! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: '3/1/2025 19:49'!mapAccessor: accessor mutator: mutator to: propertyName	^ self 		mapProperty: propertyName		getter: [ :object | object perform: accessor ]		setter: [ :object :value | object perform: mutator with: value ] ! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: '3/1/2025 19:49'!mapAccessor: accessor to: propertyName	^ self 		mapProperty: propertyName		getter: [ :object | object perform: accessor ]		setter: [ :object :value | object perform: accessor asMutator with: value ] ! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: '3/1/2025 19:49'!mapAccessors: accessors	^ accessors collect: [ :each | self mapAccessor: each ]! !!NeoJSONObjectMapping methodsFor: 'convenience' stamp: '3/1/2025 19:49'!mapAllInstVars	^ self mapInstVars: subjectClass allInstVarNames! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: '3/1/2025 19:49'!mapInstVar: instVarName	^ self mapInstVar: instVarName to: instVarName ! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: '3/1/2025 19:49'!mapInstVar: instVarName to: propertyName	| index |	index := 		"For portability reasons, do not use instVarIndexFor:ifAbsent: 		(it doesn't exist in all Smalltalk dialects) but the below approach.		Also, convert to symbols for portability reasons"		(subjectClass allInstVarNames collect: [ :each | each asSymbol ]) 			indexOf: instVarName asSymbol 			ifAbsent: [ self error: 'Inst var not found: ', instVarName printString ].	^ self 		mapProperty: propertyName asString		getter: [ :object | object instVarAt: index ]		setter: [ :object :value | object instVarAt: index put: value ] 	! !!NeoJSONObjectMapping methodsFor: 'convenience' stamp: '3/1/2025 19:49'!mapInstVars	^ self mapInstVars: subjectClass instVarNames! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: '3/1/2025 19:49'!mapInstVars: instVarNames	^ instVarNames collect: [ :each | self mapInstVar: each ]! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: '3/1/2025 19:49'!mapProperty: propertyName getter: readBlock setter: writeBlock	| propertyMapping |	propertyMapping := NeoJSONPropertyMapping new.	propertyMapping 		propertyName: propertyName;		getter: readBlock;		setter: writeBlock.	properties removeAllSuchThat: [ :each | each propertyName = propertyMapping propertyName ].	properties addLast: propertyMapping.	^ propertyMapping ! !!NeoJSONObjectMapping methodsFor: 'accessing' stamp: '3/1/2025 19:49'!propertyNamed: propertyName ifAbsent: block	| symbolPropertyName |	symbolPropertyName := propertyName asSymbol.	^ properties detect: [ :each | each propertyName = symbolPropertyName ] ifNone: block! !!NeoJSONObjectMapping methodsFor: 'parsing' stamp: '3/1/2025 19:49'!readFrom: jsonReader	| anObject |	anObject := subjectClass new.	allowNil ifTrue: [ 		jsonReader parseConstantDo: [ :value | 			^ value ifNotNil: [ jsonReader error: 'Unexpected boolean constant' ] ] ].	jsonReader parseMapKeysDo: [ :key |		(self propertyNamed: key ifAbsent: [ nil ])			ifNil: [				"read, skip & ignore value"				jsonReader next ]			ifNotNil: [ :mapping |				mapping readObject: anObject from: jsonReader ] ].	^ anObject! !!NeoJSONObjectMapping methodsFor: 'accessing' stamp: '3/1/2025 19:49'!subjectClass: smalltalkClass	subjectClass := smalltalkClass! !!NeoJSONObjectMapping methodsFor: 'writing' stamp: '3/1/2025 19:49'!writeObject: anObject on: jsonWriter	jsonWriter writeMapStreamingDo: [ :jsonMapWriter |		properties do: [ :each |			each writeObject: anObject on: jsonMapWriter ] ]! !!NeoJSONPropertyMapping methodsFor: 'accessing' stamp: '3/1/2025 19:49'!getter: block	getter := block! !!NeoJSONPropertyMapping methodsFor: 'printing' stamp: '3/1/2025 19:49'!printOn: stream	super printOn: stream.	stream nextPut: $(; print: propertyName; nextPut: $)! !!NeoJSONPropertyMapping methodsFor: 'accessing' stamp: '3/1/2025 19:49'!propertyName	^ propertyName ! !!NeoJSONPropertyMapping methodsFor: 'accessing' stamp: '3/1/2025 19:49'!propertyName: symbolOrString	propertyName := symbolOrString asSymbol! !!NeoJSONPropertyMapping methodsFor: 'parsing' stamp: '3/1/2025 19:49'!readObject: anObject from: jsonReader	| value |	value := jsonReader nextAs: valueSchema.	setter value: anObject value: value! !!NeoJSONPropertyMapping methodsFor: 'accessing' stamp: '3/1/2025 19:49'!setter: block	setter := block! !!NeoJSONPropertyMapping methodsFor: 'accessing' stamp: '3/1/2025 19:49'!valueSchema: schemaName	valueSchema := schemaName! !!NeoJSONPropertyMapping methodsFor: 'writing' stamp: '3/1/2025 19:49'!writeObject: anObject on: jsonMapWriter	| value |	value := getter value: anObject.	(value notNil or: [ jsonMapWriter writeNil ])		ifTrue: [ jsonMapWriter writeKey: propertyName value: value as: valueSchema ] ! !!NeoJSONStreamingWriter class methodsFor: 'instance creation' stamp: '3/1/2025 19:49'!on: jsonWriter	^ self new		on: jsonWriter;		yourself! !!NeoJSONStreamingWriter methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!initialize	super initialize.	first := true! !!NeoJSONStreamingWriter methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!on: aJSONWriter	jsonWriter := aJSONWriter! !!NeoJSONStreamingWriter methodsFor: 'testing' stamp: '3/1/2025 19:49'!wasUsed	^ first not! !!NeoJSONStreamingWriter methodsFor: 'writing' stamp: '3/1/2025 19:49'!writeElement: value	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter listElementSeparator ].	jsonWriter nextPut: value ! !!NeoJSONStreamingWriter methodsFor: 'writing' stamp: '3/1/2025 19:49'!writeElement: value as: valueSchema	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter listElementSeparator ].	jsonWriter nextPut: value as: valueSchema! !!NeoJSONStreamingWriter methodsFor: 'writing' stamp: '3/1/2025 19:49'!writeKey: key value: value	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter mapElementSeparator ].	jsonWriter encodeKey: key value: value ! !!NeoJSONStreamingWriter methodsFor: 'writing' stamp: '3/1/2025 19:49'!writeKey: key value: value as: valueSchema	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter mapElementSeparator ].	jsonWriter encodeKey: key value: value as: valueSchema! !!NeoJSONStreamingWriter methodsFor: 'accessing' stamp: '3/1/2025 19:49'!writeNil	^ jsonWriter writeNil! !!Object methodsFor: '*neo-json-core' stamp: '3/1/2025 19:49'!neoJsonOn: neoJSONWriter	neoJSONWriter writeObject: self! !!Number methodsFor: '*neo-json-core' stamp: '3/1/2025 19:49'!neoJsonOn: neoJSONWriter	neoJSONWriter writeFloat: self asFloat! !!Dictionary methodsFor: '*neo-json-core' stamp: '3/1/2025 19:49'!neoJsonOn: neoJSONWriter	neoJSONWriter writeMap: self! !!UndefinedObject methodsFor: '*neo-json-core' stamp: '3/1/2025 19:49'!neoJsonOn: neoJSONWriter	neoJSONWriter writeNull! !!String methodsFor: '*neo-json-core' stamp: '3/1/2025 19:49'!neoJsonOn: neoJSONWriter	neoJSONWriter writeString: self! !!Boolean methodsFor: '*neo-json-core' stamp: '3/1/2025 19:49'!neoJsonOn: neoJSONWriter	neoJSONWriter writeBoolean: self! !!NeoJSONMappingNotFound class methodsFor: 'instance creation' stamp: '3/1/2025 19:49'!signalFor: anObject	"Create and signal an exception for anObject in the default receiver."		^ self new		object: anObject;		signal! !!NeoJSONMappingNotFound class methodsFor: 'instance creation' stamp: '3/1/2025 19:49'!signalFor: anObject in: aCollection	"Create and signal an exception for anObject in aCollection."	^ self new		object: anObject;		collection: aCollection;		signal! !!NeoJSONMappingNotFound methodsFor: 'accessing' stamp: '3/1/2025 19:49'!collection	"Return the collection where something is not found in"		^ collection! !!NeoJSONMappingNotFound methodsFor: 'accessing' stamp: '3/1/2025 19:49'!collection: aCollection	"Set the collection where something is not found in"		collection := aCollection! !!NeoJSONMappingNotFound methodsFor: 'accessing' stamp: '3/1/2025 19:49'!messageText	"Overwritten with standard text. To ease portability to other Smalltalk dialects we do not access the instVar 'messageText' as not all dialects have it. Not caching the value on the instVar shouldn't bring any performance hit in this case. "		^ self standardMessageText ! !!NeoJSONMappingNotFound methodsFor: 'accessing' stamp: '3/1/2025 19:49'!object	"Return the object that was not found"		^ object! !!NeoJSONMappingNotFound methodsFor: 'accessing' stamp: '3/1/2025 19:49'!object: anObject	"Set the object that was not found"		object := anObject! !!NeoJSONMappingNotFound methodsFor: 'private' stamp: '3/1/2025 19:49'!standardMessageText	^ String streamContents: [ :stream |		stream << 'No mapping found for '.		stream print: self object.		stream << ' in '.		stream print: self collection class ]! !!NeoJSONArray class methodsFor: 'example' stamp: '3/1/2025 19:49'!exampleNumbers	<gtExample>	| numbers |	numbers := self new: 128 withAll: nil.	0 to: 127 do: [ :n | 		numbers			at: n + 1			put: (NeoJSONObject new					integer: n;					decimal: (n printStringBase: 10);					octal: (n printStringBase: 8);					hexadecimal: (n printStringBase: 16);					binary: (n printStringBase: 2);					roman: n printStringRoman;					words: n asWords;					prime: n isPrime;					character: n asCharacter asString) ].	^ numbers! !!NeoJSONArray class methodsFor: 'example' stamp: '3/1/2025 19:49'!exampleSimple	<gtExample>	^ self withAll: { 0 . 1 . Float pi. 'string' . true . false. nil }! !!NeoJSONArray methodsFor: 'adding' stamp: '3/1/2025 19:49'!at: index add: object	^ index = '-'		ifTrue: [ self addLast: object ]		ifFalse: [ self insert: object before: index ]! !!NeoJSONArray methodsFor: 'accessing' stamp: '3/1/2025 19:49'!atPath: keyCollection	"Use each key in keyCollection recursively, return nil when a key is missing.	Note how keys can also be indexes to arrays."	| value |	value := self.	keyCollection do: [ :each |		value := value at: each ifAbsent: [ ^ nil ] ].	^ value! !!NeoJSONArray methodsFor: 'adding' stamp: '3/1/2025 19:49'!atPath: keyCollection add: newValue	"Use each key in keyCollection recursively, create new levels when needed.	Note how keys can also be indexes to arrays.	This variant will insert/add to arrays"	| target |	keyCollection ifEmpty: [ ^ self ].	target := self.	keyCollection allButLastDo: [ :each |		target := target 			at: each			ifAbsent: [ target at: each add: target species new ] ].	^ target at: keyCollection last add: newValue! !!NeoJSONArray methodsFor: 'accessing' stamp: '3/1/2025 19:49'!atPath: keyCollection put: newValue	"Use each key in keyCollection recursively, create new levels when needed.	Note how keys can also be indexes to arrays."	| target |	keyCollection ifEmpty: [ ^ self ].	target := self.	keyCollection allButLastDo: [ :each |		target := target 			at: each			ifAbsent: [ target at: each put: target species new ] ].	^ target at: keyCollection last put: newValue! !!NeoJSONArray methodsFor: 'accessing' stamp: '3/1/2025 19:49'!findPath: conditionBlock	"Find and return the first path to an object in the graph that I represent 	for which conditionBlock holds. Return nil when not found."	(conditionBlock value: self) ifTrue: [ ^ #(()) ].	self doWithIndex: [ :value :index |		(conditionBlock value: value) ifTrue: [ ^ { index } ].		(value isCollection and: [ value isString not ]) ifTrue: [			(value findPath: conditionBlock) ifNotNil: [ :subPath |				^ { index } , subPath ] ] ].	^ nil! !!NeoJSONArray methodsFor: 'accessing' stamp: '3/1/2025 19:49'!findPaths: conditionBlock	"Find and return all paths to objects in the graph that I represent 	for which conditionBlock holds. Return an empty collection when none are found."	| found |	found := OrderedCollection new.		self doWithIndex: [ :value :index |		(conditionBlock value: value) ifTrue: [ found add: { index } ].		(value isCollection and: [ value isString not ]) ifTrue: [			(value findPaths: conditionBlock) do: [ :subPath |				found add: { index } , subPath ] ] ].	^ found! !!NeoJSONArray methodsFor: 'print' stamp: '3/1/2025 19:49'!printOn: stream	"I use my JSON representation when printing myself"	[ (NeoJSONWriter on: stream) nextPut: self ]		on: Error		do: [ :exception |			stream				nextPutAll: ' Error printing JSON: ';				print: exception ]! !!NeoJSONArray methodsFor: 'removing' stamp: '3/1/2025 19:49'!removeKey: index	"Polymorphic with NeoJSONObject: remove the element at index"	^ self removeAt: index! !!Integer methodsFor: '*neo-json-core' stamp: '3/1/2025 19:49'!neoJsonOn: neoJSONWriter	neoJSONWriter writeInteger: self! !!NeoJSONObject class methodsFor: 'example' stamp: '3/1/2025 19:49'!exampleCoordinates	<gtExample>	^ (0 to: 4) 		collect: [ :each | self new x: each; y: each * 2 ]		as: NeoJSONArray! !!NeoJSONObject class methodsFor: 'example' stamp: '3/1/2025 19:49'!exampleCoordinatesParsing	<gtExample>	| result |	result := self fromString: NeoJSONReader exampleCoordinatesJSON.	self assert: result equals: self exampleCoordinates.	^ result! !!NeoJSONObject class methodsFor: 'example' stamp: '3/1/2025 19:49'!exampleCoordinatesWriting	<gtExample>	^ self exampleCoordinates printString! !!NeoJSONObject class methodsFor: 'example' stamp: '3/1/2025 19:49'!exampleMagnitudeClassHierarchy	<gtExample>	| builder |	builder := [ :aClass | 		NeoJSONObject new			name: aClass name;			superclass: aClass superclass name;			instanceVariables: aClass instVarNames;			category: aClass category;			totalInstanceVariablesCount: aClass allInstVarNames size;			methodCount: aClass methods size;			totalMethodCount: aClass allMethods size;			subclasses: (aClass subclasses 								collect: [ :aSubclass | builder value: aSubclass ] 								as: NeoJSONArray) ].	^ builder value: Magnitude! !!NeoJSONObject class methodsFor: 'example' stamp: '3/1/2025 19:49'!exampleNested	<gtExample>	^ self exampleSimple array: NeoJSONArray exampleSimple! !!NeoJSONObject class methodsFor: 'example' stamp: '3/1/2025 19:49'!exampleNestedRoundtrip	<gtExample>	| json result|	json := self exampleNested printString.	result := self fromString: json.	self assert: result equals: self exampleNested.	^ result! !!NeoJSONObject class methodsFor: 'example' stamp: '3/1/2025 19:49'!exampleSimple	<gtExample>	^ self new		foo: 100;		bar: 200! !!NeoJSONObject class methodsFor: 'example' stamp: '3/1/2025 19:49'!exampleSimpleJSON	<gtExample>	^ '{"foo":100,"bar":200}'! !!NeoJSONObject class methodsFor: 'example' stamp: '3/1/2025 19:49'!exampleSimpleParsing	<gtExample>	| result |	result := self fromString: self exampleSimpleJSON.	self assert: result equals: self exampleSimple.	^ result! !!NeoJSONObject class methodsFor: 'example' stamp: '3/1/2025 19:49'!exampleSimpleUsage	<gtExample>	| simple |	simple := NeoJSONObject exampleSimple.	self assert: simple foo equals: (simple at: #foo).	self assert: (simple foo: -1) equals: (simple at: #foo put: -1; yourself).	self assert: (simple includesKey: #baz) not.	self assert: simple baz equals: nil.	^ simple! !!NeoJSONObject class methodsFor: 'example' stamp: '3/1/2025 19:49'!exampleSimpleWriting	<gtExample>	| result |	result := self exampleSimple printString.	self assert: result equals: self exampleSimpleJSON.	^ result! !!NeoJSONObject class methodsFor: 'convenience' stamp: '3/1/2025 19:49'!fromStream: readStream	"Parse stream as JSON, so that maps become instances of me and lists instances of NeoJSONArray"	^ (NeoJSONReader on: readStream readStream)			mapClass: self;			listClass: NeoJSONArray;			propertyNamesAsSymbols: true;			next! !!NeoJSONObject class methodsFor: 'convenience' stamp: '3/1/2025 19:49'!fromString: string	"Parse string as JSON, so that maps become instances of me and lists instances of NeoJSONArray"	^ self fromStream: string readStream! !!NeoJSONObject class methodsFor: 'convenience' stamp: '3/1/2025 19:49'!readFrom: readStream	"Parse stream as JSON, so that maps become instances of me and lists instances of NeoJSONArray"	^ self fromStream: readStream! !!NeoJSONObject methodsFor: 'accessing' stamp: '3/1/2025 19:49'!at: key	"I return nil for missing keys.	My superclass would signal a KeyNotFound."	^ self at: key ifAbsent: [ nil ]! !!NeoJSONObject methodsFor: 'add' stamp: '3/1/2025 19:49'!at: key add: object	^ self at: key put: object! !!NeoJSONObject methodsFor: 'nested dictionaries' stamp: '3/1/2025 19:49'!at: firstKey at: secondKey	"I return nil for missing keys.	My superclass would signal a KeyNotFound."	^ self atPath: { firstKey. secondKey }! !!NeoJSONObject methodsFor: 'nested dictionaries' stamp: '3/1/2025 19:49'!at: firstKey at: secondKey put: value	"Store value under secondKey in nested object under firstKey, create new level when needed"	^ self atPath: { firstKey. secondKey } put: value! !!NeoJSONObject methodsFor: 'accessing' stamp: '3/1/2025 19:49'!at: key ifPresent: aPresentBlock ifAbsentPut: anAbsentBlock	"Lookup the given key in the receiver. If it is present, answer the	value of evaluating the first block optionally with the value associated with the key.	Otherwise store and return the result of evaluating the second block as the new value of the key."	"Overwritten to patch a bug in the superclass implementation in Pharo 7 and 8.	This problem was fixed in Pharo 9 where this overwrite is no longer necessary but harmless."	^ self		at: key		ifPresent: aPresentBlock		ifAbsent: [ self at: key put: anAbsentBlock value ]! !!NeoJSONObject methodsFor: 'accessing' stamp: '3/1/2025 19:49'!atPath: keyCollection	"Use each key in keyCollection recursively, return nil when a key is missing.	Note how keys can also be indexes to arrays."	| value |	value := self.	keyCollection do: [ :each |		value := value at: each ifAbsent: [ ^ nil ] ].	^ value! !!NeoJSONObject methodsFor: 'accessing' stamp: '3/1/2025 19:49'!atPath: keyCollection add: newValue	"Use each key in keyCollection recursively, create new levels when needed.	Note how keys can also be indexes to arrays.	This variant will insert/add to arrays."	| target |	keyCollection ifEmpty: [ ^ self ].	target := self.	keyCollection allButLastDo: [ :each |		target := target 			at: each			ifAbsent: [ target at: each add: target species new ] ].	^ target at: keyCollection last add: newValue! !!NeoJSONObject methodsFor: 'accessing' stamp: '3/1/2025 19:49'!atPath: keyCollection put: newValue	"Use each key in keyCollection recursively, create new levels when needed.	Note how keys can also be indexes to arrays."	| target |	keyCollection ifEmpty: [ ^ self ].	target := self.	keyCollection allButLastDo: [ :each |		target := target 			at: each			ifAbsent: [ target at: each put: target species new ] ].	^ target at: keyCollection last put: newValue! !!NeoJSONObject methodsFor: 'reflective operations' stamp: '3/1/2025 19:49'!doesNotUnderstand: message	"Overwritten so that 'self foo' becomes 'self at: #foo'	and 'self foo: 1' becomes 'self at: #foo put: 1' except that self is returned"	| key |	key := message selector.	key isUnary		ifTrue: [ ^ self at: key ].	^ (key isKeyword and: [ key numArgs = 1 ])		ifTrue: [ self at: key allButLast asSymbol put: message arguments first; yourself ]		ifFalse: [ super doesNotUnderstand: message ]! !!NeoJSONObject methodsFor: 'accessing' stamp: '3/1/2025 19:49'!findPath: conditionBlock	"Find and return the first path to an object in the graph that I represent 	for which conditionBlock holds. Return nil when not found."	(conditionBlock value: self) ifTrue: [ ^ #(()) ].	self keysAndValuesDo: [ :key :value |		(conditionBlock value: value) ifTrue: [ ^ { key } ].		(value isCollection and: [ value isString not ]) ifTrue: [			(value findPath: conditionBlock) ifNotNil: [ :subPath |				^ { key } , subPath ] ] ].	^ nil! !!NeoJSONObject methodsFor: 'accessing' stamp: '3/1/2025 19:49'!findPaths: conditionBlock	"Find and return all paths to objects in the graph that I represent 	for which conditionBlock holds. Return an empty collection when none are found."	| found |	found := OrderedCollection new.	self keysAndValuesDo: [ :key :value |		(conditionBlock value: value) ifTrue: [ found add: { key } ].		(value isCollection and: [ value isString not ]) ifTrue: [			(value findPaths: conditionBlock) do: [ :subPath |				found add: { key } , subPath ] ] ].	^ found! !!NeoJSONObject methodsFor: 'accessing' stamp: '3/1/2025 19:49'!name	"Overwritten to make this accessor available as key"	^ self at: #name! !!NeoJSONObject methodsFor: 'printing' stamp: '3/1/2025 19:49'!printOn: stream	"I use my JSON representation when printing myself"	[ (NeoJSONWriter on: stream) nextPut: self ]		on: Error		do: [ :exception |			stream				nextPutAll: ' Error printing JSON: ';				print: exception ]! !!NeoJSONObject methodsFor: 'accessing' stamp: '3/1/2025 19:49'!removeAtPath: keyCollection	"Use each key in keyCollection recursively and remove the final key.	Note how keys can also be indexes to arrays."	| target |	keyCollection ifEmpty: [ ^ self ].	target := self.	keyCollection allButLastDo: [ :each |		target := target at: each ifAbsent: [ ^ self ] ].	^ target removeKey: keyCollection last! !!NeoJSONObject methodsFor: 'evaluating' stamp: '3/1/2025 19:49'!value	"Overwritten to make this accessor available as key"	^ self at: #value! !!Collection methodsFor: '*neo-json-core' stamp: '3/1/2025 19:49'!neoJsonOn: neoJSONWriter	neoJSONWriter writeList: self! !"Neo-JSON-Core"!!NeoJSONBenchmarkTests commentStamp: '' prior: 0!I am NeoJSONBenchmarkTests.This test is obviously dependent on hardware, but the margin is quite high.!!NeoJSONExamplesTests commentStamp: '' prior: 0!NeoJSONExamplesTests runs a couple of examples as tests!!NeoJSONFloatPrinterTests commentStamp: '' prior: 0!I am NeoJSONFloatPrinterTests, the collection of unit tests for NeoJSONFloatPrinter.!!NeoJSONMappingTests commentStamp: '' prior: 0!I am NeoJSONMappingTests, testing more exotic kinds of mapping constructs.!!NeoJSONObjectTests commentStamp: '' prior: 0!I am NeoJSONObjectTests, I hold unit tests for NeoJSONObject.!!NeoJSONReaderTests commentStamp: '' prior: 0!I am NeoJSONReaderTests, a test suite for NeoJSONReader.!!NeoJSONWriteReadTests commentStamp: '' prior: 0!I am NeoJSONWriteReadTests.!!NeoJSONWriteReadAsciiOnlyTests commentStamp: '' prior: 0!I am NeoJSONWriteReadAsciiOnlyTests.!!NeoJSONWriteReadMockStreamTests commentStamp: '' prior: 0!I am NeoJSONWriteReadMockStreamTests.!!NeoJSONWriteReadPrettyPrintedTests commentStamp: '' prior: 0!I am NeoJSONWriteReadPrettyPrintedTests.!!NeoJSONWriterTests commentStamp: '' prior: 0!I am NeoJSONWriterTests, a test suite for NeoJSONWriter.!!NeoJSONBenchmark commentStamp: '' prior: 0!I am NeoJSONBenchmark.I hold 1000 objects of the form Dictionary('color'->'green' 'enabled'->false 'id'->1 'name'->'Name-1' 'value'->0.002 ) in an Array.I hold the JSON serialization of that as a String of the form '[{"value":0.002,"enabled":false,"name":"Name-1","color":"green","id":1}, ...| benchmark |benchmark := NeoJSONBenchmark new.[benchmark read] bench.| benchmark |benchmark := NeoJSONBenchmark new.[benchmark write] bench.| benchmark |benchmark := NeoJSONBenchmark new.[benchmark read] timeToRun.| benchmark |benchmark := NeoJSONBenchmark new.[benchmark write] timeToRun.!!NeoJSONMockStream commentStamp: '' prior: 0!I am NeoJSONMockStream.I wrap another stream to validate the limited API used.!!NeoJSONTestObject1 commentStamp: '' prior: 0!I am NeoJSONTestObject1.I repesent a domain model object.I have the following properties:- id <Integer>- name <String>- timestamp <DateAndTime>- points <Array of: Point>- bytes <ByteArray>My JSON representation is like this:- id <Number>- name <String>- created-at <ISO8601 String>- points <Array of: <Map x,y>- bytes <Array of: Number>!!NeoJSONTestObject2 commentStamp: '' prior: 0!I am NeoJSONTestObject2.Instance Variables	data:		<String>	height:		<Integer>	id:			<Integer>	width:		<Integer>Used for benchmarking and other tests.!!NeoJSONTestObject3 commentStamp: '' prior: 0!I am NeoJSONTestObject3, a subclass of NeoJSONTestObject2.Instance Variables	color:			<String>	transparent :	<Boolean>I am used for inheritance testing.!!NeoJSONValidation commentStamp: '' prior: 0!I am NeoJSONValidation, a set of tests to validate NeoJSON against some external rules.Both positive & negative tests are includes.Some of these are implementation choices.http://seriot.ch/parsing_json.phphttps://github.com/nst/JSONTestSuitehttps://github.com/nst/JSONTestSuite.git  test_parsing  test_transformhttps://github.com/miloyip/nativejson-benchmarkhttps://github.com/miloyip/nativejson-benchmark.git  data/jsonchecker  data/roundtripThis can only be run with the correct setup (checkout/config).  NeoJSONValidation new runNativeJsonBenchmarkRoundTrip.  NeoJSONValidation new runNativeJsonBenchmarkJsonCheckerPasses.  NeoJSONValidation new runNativeJsonBenchmarkJsonCheckerFailures.  NeoJSONValidation new runJsonTestSuiteTestParsingPasses.  NeoJSONValidation new runJsonTestSuiteTestParsingFailures.  NeoJSONValidation new runJsonTestSuiteTestParsingInfo.Logging goes to a file, neo-json-validation.log!!NeoJSONBenchmarkTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testObject2	| json |	json := NeoJSONWriter toString: NeoJSONTestObject2 new.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject2)		equals: NeoJSONTestObject2 new! !!NeoJSONBenchmarkTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testPrettyPrinted	| benchmark |	benchmark := NeoJSONBenchmark new.	self		assert: benchmark writePrettyPrintedRead		equals: benchmark read! !!NeoJSONBenchmarkTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testRead	| benchmark |	benchmark := NeoJSONBenchmark new.	benchmark read! !!NeoJSONBenchmarkTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testWrite	| benchmark |	benchmark := NeoJSONBenchmark new.	benchmark write! !!NeoJSONExamplesTests methodsFor: 'tests' stamp: '3/1/2025 19:49'!testMultiInstances	"Newline delimited JSON (application/x-ndjson) - https://github.com/ndjson/ndjson-spec"	"JSON Lines (application/jsonl) - https://jsonlines.org"	| data json |		data := (1 to: 10) collect: [ :each |		{ #number -> each } asDictionary ].		json := String streamContents: [ :out |		(NeoJSONWriter on: out) nextPutAll: data ].		self assert: (NeoJSONReader on: json readStream) upToEnd equals: data.		self assert: (NeoJSONReader on: json readStream) next equals: data first.	self deny: ((NeoJSONReader on: json readStream) next; atEnd)! !!NeoJSONExamplesTests methodsFor: 'tests' stamp: '3/1/2025 19:49'!testPoints	| points json result |		points := Array with: 1@2 with: 3@4 with: 5@6.		json := String streamContents: [ :out |		(NeoJSONWriter on: out)			prettyPrint: true;			mapInstVarsFor: Point;			nextPut: points ].			result := (NeoJSONReader on: json readStream)		mapInstVarsFor: Point;		for: #ListOfPoints customDo: [ :mapping |			mapping listOfElementSchema: Point ];		nextAs: #ListOfPoints.		self assert: result equals: points.				result := (NeoJSONReader on: json readStream)		mapInstVarsFor: Point;		nextListAs: Point.		self assert: result equals: points.			result := (NeoJSONReader on: json readStream)		mapInstVarsFor: Point;		for: #OrderedCollectionOfPoints customDo: [ :mapping |			mapping listOfType: OrderedCollection andElementSchema: Point ];		nextAs: #OrderedCollectionOfPoints.		self assert: result equals: points asOrderedCollection.! !!NeoJSONExamplesTests methodsFor: 'tests' stamp: '3/1/2025 19:49'!testRectanglePoints	| rectangle rectangleJson result |	rectangle := Rectangle origin: 3 @ 4 extent: 5 @ 6.	rectangleJson := String streamContents: [ :stream | 		(NeoJSONWriter on: stream)			prettyPrint: true;			mapInstVarsFor: Point;			mapInstVarsFor: Rectangle;			nextPut: rectangle ].	result := (NeoJSONReader on: rectangleJson readStream)		mapInstVarsFor: Point;		for: Rectangle do: [ :mapping | 			(mapping mapInstVar: #origin) valueSchema: Point.			(mapping mapInstVar: #corner) valueSchema: Point ];		nextAs: Rectangle.	self assert: result equals: rectangle.	result := (NeoJSONReader on: rectangleJson readStream)		mapInstVarsFor: Point;		for: Rectangle do: [ :mapping | 			mapping mapInstVars do: [ :each | each valueSchema: Point ] ];		nextAs: Rectangle.			self assert: result equals: rectangle ! !!NeoJSONExamplesTests methodsFor: 'tests' stamp: '3/1/2025 19:49'!testRectanglePointsWithNils	self		assert: 			(String streamContents: [ :stream | 				(NeoJSONWriter on: stream)					for: Point do: [ :mapping | mapping mapAllInstVars ];					for: Rectangle do: [ :mapping | 						(mapping mapInstVar: #origin) valueSchema: Point.						(mapping mapInstVar: #corner) valueSchema: Point ];					nextPut: Rectangle new ])		equals: '{}'.	self		assert:			(String streamContents: [ :stream | 				(NeoJSONWriter on: stream)					for: Point do: [ :mapping | mapping mapAllInstVars ];					for: Rectangle	do: [ :mapping | 						(mapping mapInstVar: #origin) valueSchema: Point.						(mapping mapInstVar: #corner) valueSchema: Point ];					writeNil: true;					nextPut: Rectangle new ])		equals: '{"origin":null,"corner":null}'.! !!NeoJSONFloatPrinterTests methodsFor: 'running' stamp: '3/1/2025 19:49'!setUp	super setUp.	printer := NeoJSONFloatPrinter new! !!NeoJSONFloatPrinterTests methodsFor: 'tests' stamp: '3/1/2025 19:49'!testDecimalNotation	self assert: (printer print: 1.5) equals: '1.5'.	self assert: (printer print: -1.5) equals: '-1.5'.	self assert: (printer print: 0.5) equals: '0.5'.	self assert: (printer print: -0.5) equals: '-0.5'.	self assert: (printer print: (1/3) asFloat) equals: '0.33333'.	self assert: (printer print: (-1/3) asFloat) equals: '-0.33333'.	self assert: (printer print: 0.00123) equals: '0.00123'.	self assert: (printer print: -0.00123) equals: '-0.00123'.	self assert: (printer print: 0.00012) equals: '0.00012'.	self assert: (printer print: -0.00012) equals: '-0.00012'.	self assert: (printer print: 123456.12345) equals: '123456.12345'.	self assert: (printer print: -123456.12345) equals: '-123456.12345'.! !!NeoJSONFloatPrinterTests methodsFor: 'tests' stamp: '3/1/2025 19:49'!testInteger	self assert: (printer print: 1.0) equals: '1'.	self assert: (printer print: 0.0) equals: '0'.	self assert: (printer print: -1.0) equals: '-1'.	self assert: (printer print: 123.0) equals: '123'.	self assert: (printer print: 123456.0) equals: '123456'.	! !!NeoJSONFloatPrinterTests methodsFor: 'tests' stamp: '3/1/2025 19:49'!testLowPrecision	printer := NeoJSONFloatPrinter lowPrecision.	self assert: (printer print: (4/3) asFloat) equals: '1.33'.	self assert: (printer print: 12345.66) equals: '12345.66'.	self assert: (printer print: -123456.77) equals: '-1.23e5'.	self assert: (printer print: Float pi) equals: '3.14'.	self assert: (printer print: Float e negated) equals: '-2.72'.	"the earth's mass in kg"	self assert: (printer print: 5.9724e24) equals: '5.97e24'.	"mass of electron in kg"	self assert: (printer print: 9.10938356e-31) equals: '9.11e-31'.! !!NeoJSONFloatPrinterTests methodsFor: 'tests' stamp: '3/1/2025 19:49'!testScientificNotation	self assert: (printer print: 1234567.5) equals: '1.23457e6'. "note the rounding"	self assert: (printer print: -1234567.5) equals: '-1.23457e6'. "note the rounding"	self assert: (printer print: 0.0000123) equals: '1.23e-5'.	self assert: (printer print: -0.0000123) equals: '-1.23e-5'.! !!NeoJSONFloatPrinterTests methodsFor: 'tests' stamp: '3/1/2025 19:49'!testScientificOnly	printer := NeoJSONFloatPrinter scientificOnly.	self assert: (printer print: (4/3) asFloat) equals: '1.33333e0'.	self assert: (printer print: 12345.66) equals: '1.23457e4'.	self assert: (printer print: Float pi) equals: '3.14159e0'.	self assert: (printer print: Float e negated) equals: '-2.71828e0'.	"the earth's mass in kg"	self assert: (printer print: 5.9724e24) equals: '5.9724e24'.	"mass of electron in kg"	self assert: (printer print: 9.10938356e-31) equals: '9.10938e-31'.! !!NeoJSONFloatPrinterTests methodsFor: 'tests' stamp: '3/1/2025 19:49'!testSpecialValues	self assert: (printer print: Float zero) equals: '0'.	self assert: (printer print: Float nan) equals: 'NaN'.	self assert: (printer print: Float infinity) equals: 'Inf'.	self assert: (printer print: Float infinity negated) equals: '-Inf'.! !!NeoJSONFloatPrinterTests methodsFor: 'tests' stamp: '3/1/2025 19:49'!testWellKnownConstants	self assert: (printer print: Float pi) equals: '3.14159'.	self assert: (printer print: Float e) equals: '2.71828'.	"the earth's mass in kg"	self assert: (printer print: 5.9724e24) equals: '5.9724e24'.	"mass of electron in kg"	self assert: (printer print: 9.10938356e-31) equals: '9.10938e-31'.	"planck's constant in Js"	self assert: (printer print: 1.05457e-34) equals: '1.05457e-34'.	"speed of light in m/s"	self assert: (printer print: 2.99792e8) equals: '2.99792e8'.	"charge of electron in C"	self assert: (printer print: -1.60218e-19) equals: '-1.60218e-19'.	"boltzmann's constant in J/K"	self assert: (printer print: 1.38065e-23) equals: '1.38065e-23'.! !!NeoJSONMappingTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testDynamicTyping	| data customMapping json result |	data := Array with: 'foo'->1 with: #('foo' 2).	"The idea is to map a key value combination as either a classic association or a simple pair, 	using key & value properties as well as a type property to distinguish between the two"	customMapping := [ :mapper |		mapper 			for: #AssocOrPair customDo: [ :mapping |				mapping					encoder: [ :x | 						x isArray 							ifTrue: [ Dictionary new at: 'type' put: 'pair'; at: 'key' put: x first; at: 'value' put: x second; yourself ] 							ifFalse: [ Dictionary new at: 'type' put: 'assoc'; at: 'key' put: x key; at: 'value' put: x value; yourself ] ];					decoder: [ :x |						(x at: 'type') = 'pair'							ifTrue: [ Array with: (x at: 'key') with: (x at: 'value') ]							ifFalse: [ (x at: 'key') -> (x at: 'value')] ] ];			for: #ArrayOfAssocOrPair customDo: [ :mapping |				mapping listOfType: Array andElementSchema: #AssocOrPair ];			yourself ].	json := String streamContents: [ :out |		(customMapping value: (NeoJSONWriter on: out)) nextPut: data as: #ArrayOfAssocOrPair ].	result := (customMapping value: (NeoJSONReader on: json readStream)) nextAs: #ArrayOfAssocOrPair.	self assert: result equals: data! !!NeoJSONMappingTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testSymbolOrStringInstVarMapping	| data out1 out2 result1 result2 |	data := Array with: 1@2 with: 3@4.	out1 := String streamContents: [ :out |		(NeoJSONWriter on: out)			for: Point do: [ :mapping | mapping mapInstVars: #(x y) ];			nextPut: data ].	result1 := (NeoJSONReader on: out1 readStream)		for: Point do: [ :mapping | mapping mapInstVars: #(x y) ];		nextListAs: Point.	self assert: result1 equals: data.	out2 := String streamContents: [ :out |		(NeoJSONWriter on: out)			for: Point do: [ :mapping | mapping mapInstVars: #('x' 'y') ];			nextPut: data ].	result2 := (NeoJSONReader on: out1 readStream)		for: Point do: [ :mapping | mapping mapInstVars: #('x' 'y') ];		nextListAs: Point.	self assert: result2 equals: data! !!NeoJSONMappingTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testVirtualTransferObject	| data customMapping extraJson json result |	data := NeoJSONObject new data: (Array with: 1@1 with: 2@2).	extraJson := '{"foo":1,"data":[{"x":1,"y":1},{"x":2,"y":2,"z":-1}]}'.	"The idea here is that we are not interested in the top level object just in its data property, 	which should be of a specific type, hence we create a virtual transfer object"	customMapping := [ :mapper |		mapper			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			for: #ArrayOfPoints customDo: [ :mapping |				mapping listOfElementSchema: Point ];			for: #TransferObject do: [ :mapping |				mapping subjectClass: NeoJSONObject.				(mapping mapAccessor: #data) valueSchema: #ArrayOfPoints ];			yourself ].	"By using NeoJSONObject accessors (#data & #data:) are translated to generic #at:[put:] messages.	A longer alternative is 	(mapping mapProperty: #data getter: [ :obj | obj at: #data ] setter: [ :obj :x | obj at: #data put: x]) valueSchema: #ArrayOfPoints	where the blocks give you the flexibility to use a plain Dictionary for example"	result := (customMapping value: (NeoJSONReader on: extraJson readStream)) nextAs: #TransferObject.	self assert: result equals: data.	json := String streamContents: [ :out |		(customMapping value: (NeoJSONWriter on: out)) nextPut: data as: #TransferObject ].	result := (customMapping value: (NeoJSONReader on: json readStream)) nextAs: #TransferObject.	self assert: result equals: data! !!NeoJSONObjectTests methodsFor: 'accessing' stamp: '3/1/2025 19:49'!exampleJSONSchema	^ NeoJSONObject fromString: '{  "$id" : "https://example.com/schemas/address",  "type" : "object",  "properties" : {    "street_address" : { "$anchor" : "street_address", "type" : "string" },    "city" : { "type" : "string" },    "state" : { "type" : "string" }  },   "required" : ["street_address", "city", "state"],  "$defs" : {    "country" : { "type" : "object", "$anchor" : "country", "enum" : ["us","canada","gb"] }  }}'! !!NeoJSONObjectTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testArray	| jsonArray array |	jsonArray := '[1,2,3]'.	array := NeoJSONObject fromString: jsonArray.	self assert: array asString equals: jsonArray.	self assertCollection: array hasSameElements: #(1 2 3).	array at: 1 add: 0.	array at: #- add: 4.	self assertCollection: array hasSameElements: #(0 1 2 3 4).	array removeKey: 5.	array removeKey: 1.	self assertCollection: array hasSameElements: #(1 2 3)! !!NeoJSONObjectTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testAtAt	| object |	object := NeoJSONObject new.	self assert: (object at: #foo) isNil.	self assert: (object at: #foo at: #bar) isNil.	object at: #foo at: #bar put: 123.	self assert: (object at: #foo) notNil.	self assert: (object at: #foo at: #bar) equals: 123.	self assert: object foo bar equals: 123.	object at: #foo at: #bar put: -1.	self assert: (object at: #foo at: #bar) equals: -1.	self assert: (object at: #foo at: #foo) isNil! !!NeoJSONObjectTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testAtPath	| object |	object := NeoJSONObject newFrom:  (Array with:  #one -> ( NeoJSONObject newFrom:  (Array with:  #two -> ( NeoJSONObject newFrom: (Array with:  #three -> 42) ) ) )).	self assert: (object atPath: #(one two three)) equals: 42.	self assert: (object atPath: #(one two three)) equals: object one two three.		self assert: (object atPath: #(missing)) equals: nil.	self assert: (object atPath: #(one missing)) equals: nil.	self assert: (object atPath: #(one two missing)) equals: nil.	self assert: (object atPath: #(one two missing)) equals: object one two missing.		object := NeoJSONObject newFrom:  (Array with: #foo -> 42).	self assert: (object atPath: #(foo)) equals: 42.	self assert: (object atPath: #(foo)) equals: object foo.	self assert: (object atPath: #(foo)) equals: (object at: #foo).	self assert: (object atPath: #()) equals: object.	! !!NeoJSONObjectTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testAtPathPut	| object |	object := NeoJSONObject new.	object atPath: #(one test) put: 42.	self assert: (object atPath: #(one test)) equals: 42.	self assert: object one test equals: 42.	object atPath: #(one two three) put: #foo.	self assert: (object atPath: #(one two three)) equals: #foo.	self assert: object one two three equals: #foo.	object atPath: #(one two threeBis) put: #bar.	self assert: (object atPath: #(one two threeBis)) equals: #bar.	self assert: object one two threeBis equals: #bar.		self assert: object foo isNil.	self assert: (object atPath: #() put: 1) equals: object.	self assert: (object atPath: #(foo) put: 1) equals: 1.	self assert: (object atPath: #(foo)) equals: 1.	self assert: object foo equals: 1	 ! !!NeoJSONObjectTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testCRUD	| object |	object := NeoJSONObject new.	self assert: object isEmpty.	self assert: object foo equals: nil.	object foo: 123.	self assert: object foo equals: 123.	self assert: object printString equals: '{"foo":123}'.	object name: 'test'.	object value: Float pi.	self assert: object name equals: 'test'.	self assert: (object value closeTo: Float pi).	self assert: object keys asSet equals: #(foo name value) asSet.	object removeKey: #foo.	self assert: object foo equals: nil.	object removeAll.	self assert: object isEmpty! !!NeoJSONObjectTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testFindPath	| json path |	json := self exampleJSONSchema.		path := json findPath: [ :object | object isDictionary and: [ (object at: '$anchor') = 'street_address' ] ].	self deny: path isNil.	self assert: path equals: #(properties street_address).	self assert: ((json atPath: path) at: '$anchor') equals: 'street_address'.			path := json findPath: [ :object | object isDictionary and: [ (object at: 'foo') = 'bar' ] ].	self assert: path isNil.		path := json findPath: [ :object | object isDictionary and: [ (object at: '$anchor') = 'country' ] ].	self deny: path isNil.	self assert: path equals: #('$defs' country).	self assert: ((json atPath: path) at: '$anchor') equals: 'country'.		json := NeoJSONObject new at: '$anchor' put: 'top'; yourself.	self 		assert: (json findPath: [ :object | object isDictionary and: [ (object at: '$anchor') = 'top' ] ])		equals: #(())! !!NeoJSONObjectTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testFindPaths	| json paths |	json := self exampleJSONSchema.		paths := json findPaths: [ :object | object isDictionary and: [ object includesKey: '$anchor' ] ].	self deny: paths isEmpty.	self assert: paths asArray equals: #((properties street_address) ('$defs' country)).	self assert: ((json atPath: paths first) at: '$anchor') equals: 'street_address'.	self assert: ((json atPath: paths second) at: '$anchor') equals: 'country'.				paths := json findPaths: [ :object | object isDictionary and: [ (object at: 'foo') = 'bar' ] ].	self assert: paths isEmpty.		paths := json findPaths: [ :object | object isDictionary and: [ object includesKey: #type ] ].	self deny: paths isEmpty.	paths do: [ :path |		self assert: (#(string object) includes: ((json atPath: path) at: #type)) ].			paths := json findPaths: [ :_ | true ].	paths do: [ :each | 		self assert: (json atPath: each) notNil ]! !!NeoJSONObjectTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testJSON	| data  json object |	data := NeoJSONObject newFrom: (Array with: #foo->1 with: #bar->2 with: #str->'Str!!' with: #bool->true with: #flt->1.5).	json := NeoJSONWriter toString: data .	object := NeoJSONObject fromString: json.	self assert: object class equals: NeoJSONObject.	self assert: object equals: data.	json := (NeoJSONWriter toString: object).	self assert: (NeoJSONObject fromString: json) equals: object! !!NeoJSONObjectTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testPathAccess	| data |	data := NeoJSONObject fromString: '{"foo":1,"bar":2,"array":[{"a":1},{"b":2}]}'.	self assert: (data atPath: #(array 1 a)) equals: 1.	self assert: (data atPath: #(array 2 b)) equals: 2.	self assert: (data atPath: #(missing 1)) equals: nil.	data atPath: #(missing) put: 7.	self assert: (data atPath: #(missing)) equals: 7.	self assert: (data atPath: #(array 3)) equals: nil.	data := NeoJSONObject fromString: '[{"c":1},{"c":2},{"c":3}]'.	self assert: (data atPath: #(2 c)) equals: 2.	self assert: (data atPath: #(10 c)) equals: nil.	self assert: (data atPath: #(3 missing)) equals: nil.	data atPath: #(3 missing) put: #found.	self assert: (data atPath: #(3 missing)) equals: #found.	(data at: 3) removeKey: #missing.	self assert: (data atPath: #(3 missing)) equals: nil.	data atPath: #(3 missing x) put: #found.	self assert: (data atPath: #(3 missing x)) equals: #found.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testAllowNil	self 		should: [ 			(NeoJSONReader on: 'null' readStream)				mapInstVarsFor: Point;				nextAs: Point ] 		raise: NeoJSONParseError.	self		assert: ((NeoJSONReader on: 'null' readStream)						mapInstVarsFor: Point;						for: Point do: [ :mapping | mapping allowNil ];						nextAs: Point)		equals: nil.	self		assert: ((NeoJSONReader on: '[ { "x" : 1, "y" : 2 }, null, { "x" : 3, "y" : -1 } ]' readStream)						mapInstVarsFor: Point;						for: Point do: [ :mapping | mapping allowNil ];						for: #ArrayOfPoints customDo: [ :mapping | mapping listOfElementSchema: Point ];						nextAs: #ArrayOfPoints)		equals: (Array with: 1 @ 2 with: nil with: 3 @ -1).! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testArrayOfPoints	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			for: #ArrayOfPoints customDo: [ :mapping |				mapping listOfElementSchema: Point ];			nextAs: #ArrayOfPoints ].	self assert: (reader value: '[ { "x":1, "y":2 }, { "x":-1, "y":-2 } ]') equals: (Array with: 1@2 with: -1@ -2) . 	self assert: (reader value: '[ ]') equals: #().	self assert: (reader value: '[ { } ]') equals: (Array with: Point new)! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testArrayOfPointsUsingNextListAs	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			mapInstVarsFor: Point;			nextListAs: Point ].	self assert: (reader value: '[ { "x":1, "y":2 }, { "y":-2, "x":-1 } ]') equals: (Array with: 1@2 with: -1@ -2) . 	self assert: (reader value: '[ ]') equals: #().	self assert: (reader value: '[ { } ]') equals: (Array with: Point new) ! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testAssociation	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Association do: [ :mapping |				mapping mapAccessors: #(key value) ]; 			nextAs: Association ].	self assert: (reader value: '{"key":"foo","value":42}') equals: 'foo' -> 42. 	self assert: (reader value: '{}') equals: Association new! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testBooleans	self assert: (NeoJSONReader on: 'true' readStream) next equals: true.	self assert: (NeoJSONReader on: 'false' readStream) next equals: false.	self should: [ (NeoJSONReader on: 'tru' readStream) next ] raise: NeoJSONParseError.	self should: [ (NeoJSONReader on: 'falsE' readStream) next ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testByteArray	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: ByteArray customDo: [ :mapping |				mapping listOfType: ByteArray ];			nextAs: ByteArray ].	self assert: (reader value: '[ 1, 2, 3 ]') equals: #[1 2 3].	self assert: (reader value: '[ ]') equals: ByteArray new! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testDate	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: Date customDo: [ :mapping |				mapping decoder: [ :string | Date fromString: string ] ];			nextAs: Date ].	self assert: (reader value: ' "2012-06-08" ') equals: (Date fromString: '2012-06-08') ! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testDateAndTime 	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: DateAndTime customDo: [ :mapping |				mapping decoder: [ :string | DateAndTime fromString: string ] ];			nextAs: DateAndTime ].	self 		assert: (reader value: ' "2012-02-14T16:40:18+01:00" ') 		equals: (DateAndTime year: 2012 month: 2 day: 14 hour: 16 minute: 40 second: 18 offset: 1 hour)! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testFloats	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: ((reader value: '123.0') closeTo: 123.0).	self assert: ((reader value: '-123.0') closeTo: -123.0).	self assert: ((reader value: '123.0e0') closeTo: 123.0).	self assert: ((reader value: '123e6') closeTo: 123e6).	self assert: ((reader value: '123e+6') closeTo: 123e6).	self assert: ((reader value: '123e-6') closeTo: 123e-6).	self assert: ((reader value: '123E6') closeTo: 123e6).	self assert: ((reader value: '123E+6') closeTo: 123e6).	self assert: ((reader value: '123E-6') closeTo: 123e-6).	self assert: ((reader value: '-123e6') closeTo: -123e6).	self assert: ((reader value: '-123e-6') closeTo: -123e-6).	self assert: ((reader value: '-123E6') closeTo: -123e6).	self assert: ((reader value: '-123E-6') closeTo: -123e-6).	self assert: ((reader value: '3.14159') closeTo: Float pi).	self assert: ((reader value: '0.123e6') closeTo: 0.123e6).	self assert: ((reader value: '0.123e-6') closeTo: 0.123e-6).	self assert: ((reader value: '-0.123E6') closeTo: -0.123e6).	self assert: ((reader value: '-0.123E-6') closeTo: -0.123e-6).! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testIntegers	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '123') equals: 123.	self assert: (reader value: '00123') equals: 123.	self assert: (reader value: '-123') equals: -123.	self assert: (reader value: '-0123') equals: -123.	self assert: (reader value: '0') equals: 0.	self assert: (reader value: '-0') equals: 0.	self assert: (reader value: '00') equals: 0.	self assert: (reader value: ' 123	') equals: 123.	self should: [ reader value: '+1' ] raise: NeoJSONParseError.	self should: [ reader value: ' - ' ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testLists	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '[1,2,3]') equals: #(1 2 3).	self assert: (reader value: '[]') equals: #().	self assert: (reader value: ' [ 1 , 2 , 3 ] ') equals: #(1 2 3).	self assert: (reader value: ' [ ] ') equals: #().	self should: [ reader value: '[1,]' ] raise: NeoJSONParseError. 	self should: [ reader value: '[' ] raise: NeoJSONParseError.	self should: [ reader value: ']' ] raise: NeoJSONParseError.	self should: [ reader value: '[}' ] raise: NeoJSONParseError! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testMaps	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '{"x":1,"y":2}') equals: (Dictionary newFromPairs: #( 'x' 1 'y' 2)).	self assert: (reader value: '{}') equals: Dictionary new.	self assert: (reader value: ' { "x" : 1 , "y" : 2 } ' ) equals: (Dictionary newFromPairs: #( 'x' 1 'y' 2)).	self assert: (reader value: ' { } ') equals: Dictionary new.	self should: [ reader value: '{"foo":}' ] raise: NeoJSONParseError. 	self should: [ reader value: '{"foo":9,}' ] raise: NeoJSONParseError. 	self should: [ reader value: '{9:true,}' ] raise: NeoJSONParseError. 	self should: [ reader value: '{' ] raise: NeoJSONParseError.	self should: [ reader value: '}' ] raise: NeoJSONParseError.	self should: [ reader value: '{]' ] raise: NeoJSONParseError! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testNextStringAsHex	| string |	string := (NeoJSONReader on: '"466F6F2062617221"' readStream)		for: #StringAsHex			customDo: [ :mapping | 					mapping						encoder: [ :x | x asByteArray hex asUppercase ];						decoder: [ :x | (ByteArray readHexFrom: x) asString ] ];		nextAs: #StringAsHex.	self assert: string equals: 'Foo bar!!'! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testNonBMPCharacterDecoding	"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"	| string object |	string := 16r1D11E asCharacter asString. "MUSICAL SYMBOL G CLEF"	object := (NeoJSONReader fromString: '"\uD834\uDD1E"').	self assert: object equals: string.		"UTF-16 surrogate pairs might be invalid, make sure an error is raised"	self should: [ NeoJSONReader fromString: '"\udbff\ue000"' ] raise: NeoJSONParseError! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testNull	self assert: (NeoJSONReader on: 'null' readStream) next equals: nil.	self assert: (NeoJSONReader on: '	null ' readStream) next equals: nil.	self should: [ (NeoJSONReader on: '	nil ' readStream) next ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testOrderedCollection	| json list |	json := '[ 1, 2, 3 ]'.	list := (NeoJSONReader on: json readStream) 		listClass: OrderedCollection;		next.	self 		assert: list 		equals: (OrderedCollection with: 1 with: 2 with: 3).	self 		assert: list class 		equals: OrderedCollection! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testOrderedCollectionOfPoints	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			for: #OrderedCollectionOfPoints customDo: [ :mapping |				mapping listOfType: OrderedCollection andElementSchema: Point ];			nextAs: #OrderedCollectionOfPoints ].	self assert: (reader value: '[ { "x":1, "y":2 }, { "x":-1, "y":-2 } ]') equals: (Array with: 1@2 with: -1@ -2) asOrderedCollection. 	self assert: (reader value: '[ ]') equals: OrderedCollection new.	self assert: (reader value: '[ { } ]') equals: (OrderedCollection with: Point new)! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testParseErrors	self should: [ NeoJSONReader fromString: 'zero' ] raise: NeoJSONParseError.	self should: [ NeoJSONReader fromString: '#' ] raise: NeoJSONParseError.	self should: [ NeoJSONReader fromString: '@' ] raise: NeoJSONParseError.		self should: [ (NeoJSONReader on: '[1,2,3]true' readStream) next; failIfNotAtEnd ] raise: NeoJSONParseError.	self should: [ (NeoJSONReader on: '{"foo":1}"extra"' readStream) next; failIfNotAtEnd ] raise: NeoJSONParseError.	self should: [ (NeoJSONReader on: '[]"extra"' readStream) next; failIfNotAtEnd ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testPoint	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) nextAs: Point ].	self should: [ reader value: '{"x":1,"y":2}' ] raise: NeoJSONMappingNotFound! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testPoint1	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapProperty: 'x' getter: [ :point | point x ] setter: [ :point :value | point setX: value setY: point y ].				mapping mapProperty: 'y' getter: [ :point | point y ] setter: [ :point :value | point setX: point x setY: value ]. ];			nextAs: Point ].	self assert: (reader value: '{"x":1,"y":2}') equals: 1@2. 	self assert: (reader value: '{}') equals: Point new! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testPoint2	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			mapAllInstVarsFor: Point;			nextAs: Point ].	self assert: (reader value: '{"x":1,"y":2}') equals: 1@2. 	self assert: (reader value: '{}') equals: Point new! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testPoint3	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			nextAs: Point ].	self assert: (reader value: '{"x":1,"y":2}') equals: 1@2. 	self assert: (reader value: '{}') equals: Point new! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testPointUsingAsString	| point |	point := (NeoJSONReader on: '{"x":"1","y":"2"}' readStream)		for: Point			do: [ :mapping | 					(mapping 						mapProperty: #x 						getter: [ :object | object x ] 						setter: [ :object :value | object setX: value setY: object y ])						valueSchema: #AsString.					(mapping						mapProperty: #y						getter: [ :object | object y ]						setter: [ :object :value | object setX: object x setY: value ]) 						valueSchema: #AsString ];		for: #AsString			customDo: [ :mapping | 					mapping						encoder: [ :x | x asString ];						decoder: [ :x | x asNumber ] ];		nextAs: Point.	self assert: point equals: 1 @ 2! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testPropertyNamesAsSymbols	| json map |	json := '{ "x" : true, "y" : false, "key-1" : 1 }'.	map := (NeoJSONReader on: json readStream) 		propertyNamesAsSymbols: true; 		next.	self 		assert: map 		equals: (Dictionary new at: #x put: true; at: #y put: false; at: #'key-1' put: 1; yourself).	self assert: (map keys allSatisfy: [ :each | each isSymbol ])! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testSmallDictionary	| json map smallDictionaryClass |	json := '{ "x" : true, "y" : false, "key-1" : 1 }'.	smallDictionaryClass := Smalltalk at: #SmallDictionary ifAbsent: [ Dictionary ].	map := (NeoJSONReader on: json readStream) 		mapClass: smallDictionaryClass;		next.	self 		assert: map 		equals: (smallDictionaryClass new at: 'x' put: true; at: 'y' put: false; at: 'key-1' put: 1; yourself).	self 		assert: map class 		equals: smallDictionaryClass! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testStrings	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '"foo"') equals: 'foo'.	self assert: (reader value: '""') equals: ''.	self assert: (reader value: '"Foo BAR"') equals: 'Foo BAR'.	self assert: (reader value: '" foo "') equals: ' foo '.	self assert: (reader value: '"\u00E9l\u00E8ve en Fran\u00E7ais"') equals: 'lve en Franais'.	self 		assert: (reader value: '"\"\\\/\t\r\n\f\b"') 		equals: (String withAll: ( OrderedCollection new 			add: $";			add: $\; 			add: $/;			add: Character tab;			add: Character cr;			add: Character lf;			add: Character newPage; 			add: Character backspace;			yourself )).	self should: [ reader value: '"open' ] raise: NeoJSONParseError.	self should: [ reader value: '"\uAA"' ] raise: NeoJSONParseError.	self should: [ reader value: '"\uZZ"' ] raise: NeoJSONParseError.	self should: [ reader value: '"\x"' ] raise: NeoJSONParseError.	self should: [ reader value: ' " ' ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testSymbol	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: Symbol customDo: [ :mapping |				mapping decoder: [ :string | string asSymbol ] ];			nextAs: Symbol ].	self assert: (reader value: ' "foo" ') equals: #foo.	self assert: (reader value: ' "FOO-1" ') equals: #'FOO-1'! !!NeoJSONReaderTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testTime	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: Time customDo: [ :mapping |				mapping decoder: [ :string | Time fromString: string ] ];			nextAs: Time ].	self assert: (reader value: ' "14:30:08" ') equals: (Time hour: 14 minute: 30 second: 8)! !!NeoJSONWriteReadAsciiOnlyTests methodsFor: 'private' stamp: '3/1/2025 19:49'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) asciiOnly: true; nextPut: object ].	^ (NeoJSONReader on: json readStream) next ! !!NeoJSONWriteReadMockStreamTests methodsFor: 'private' stamp: '3/1/2025 19:49'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: (NeoJSONMockStream on: stream))			prettyPrint: true;			nextPut: object ].	^ (NeoJSONReader on: (NeoJSONMockStream on: json readStream)) next ! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testDictionaryOfObject2	| data json reader |	data := Dictionary new.	data 		at: 'one' put: NeoJSONTestObject2 example1;		at: 'two' put: NeoJSONTestObject2 example1.	json := NeoJSONWriter toStringPretty: data.	reader := NeoJSONReader on: json readStream.	reader for: #DictionaryOfObject2 customDo: [ :mapping |		mapping mapWithValueSchema: NeoJSONTestObject2 ].  	self 		assert: (reader nextAs: #DictionaryOfObject2)		equals: data! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testObject1	| json |	json := NeoJSONWriter toStringPretty: NeoJSONTestObject1 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject1)		equals: NeoJSONTestObject1 example1! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testObject2	| json |	json := NeoJSONWriter toStringPretty: NeoJSONTestObject2 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject2)		equals: NeoJSONTestObject2 example1! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testObject3	| json |	json := NeoJSONWriter toStringPretty: NeoJSONTestObject3 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject3)		equals: NeoJSONTestObject3 example1! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'private' stamp: '3/1/2025 19:49'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) 			prettyPrint: true;			nextPut: object ].	^ (NeoJSONReader on: json readStream) next ! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testDictionaryOfObject2	| data json reader |	data := Dictionary new.	data 		at: 'one' put: NeoJSONTestObject2 example1;		at: 'two' put: NeoJSONTestObject2 example1.	json := NeoJSONWriter toString: data.	reader := NeoJSONReader on: json readStream.	reader for: #DictionaryOfObject2 customDo: [ :mapping |		mapping mapWithValueSchema: NeoJSONTestObject2 ].  	self 		assert: (reader nextAs: #DictionaryOfObject2)		equals: data! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testFloats	| objects |	objects := OrderedCollection new add: Float pi; add: 1.0; add: -1.0; add: 0.0; add: 1.5e6; add: -1.5e6; add: 1.5e-6; add: -1.5e-6; yourself.	(self writeRead: objects) 		with: objects 		do: [ :first :second | self assert: (first closeTo: second) ]! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testIntegers	| objects |	objects := Array with: 1 with: -1 with: 0 with: 123467890 with: -1234567890.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testLists	| objects |	objects := Array with: #(1 2 3) with: #() with: #( 'foo' 'bar').	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testMaps	| objects |	objects := Array 		with: Dictionary new		with: (Dictionary with: 'x' -> 1)		with: (Dictionary newFromPairs: #( 'foo' true 'bar' false 'zero' 0 'null' nil 'string' 'Hello World!!' )).	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testObject1	| json |	json := NeoJSONWriter toString: NeoJSONTestObject1 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject1)		equals: NeoJSONTestObject1 example1! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testObject2	| json |	json := NeoJSONWriter toString: NeoJSONTestObject2 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject2)		equals: NeoJSONTestObject2 example1! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testObject3	| json |	json := NeoJSONWriter toString: NeoJSONTestObject3 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject3)		equals: NeoJSONTestObject3 example1! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testSpecials	| objects |	objects := Array with: true with: false with: nil.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testStrings	| objects |	objects := OrderedCollection new		add: 'foo'; add: 'Foo BAR'; add: ''; add: '	\\'''; 		add: 'lve en Franais';		add: (Character codePoint: 12354) asString; "HIRAGANA LETTER A" 		yourself;		asArray.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'private' stamp: '3/1/2025 19:49'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) nextPut: object ].	^ (NeoJSONReader on: json readStream) next ! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testAsciiOnlyStrings	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				asciiOnly: true;				nextPut: object ] ].	self assert: (writer value: 'lve franais') equals: '"\u00E9l\u00E8ve fran\u00E7ais"'.	self assert: (writer value: 'foo') equals: '"foo"'.	self assert: (writer value: 'Foo BAR') equals: '"Foo BAR"'.	self assert: (writer value: '') equals: '""'.	self		assert: (writer value: (String withAll: ( OrderedCollection new 			add: $";			add: $\; 			add: $/;			add: Character tab;			add: Character cr;			add: Character lf;			add: Character newPage; 			add: Character backspace;			yourself )))		equals: '"\"\\/\t\r\n\f\b"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testAssociation	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Association do: [ :mapping |					mapping mapAccessors: #(key value) ]; 				nextPut: object ] ].	self assert: (writer value: 'foo' -> 42) equals: '{"key":"foo","value":42}'.	self assert: (writer value: Association new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testBooleans	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: true) equals: 'true'.	self assert: (writer value: false) equals: 'false'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testByteArray	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: #[1 2 3]) equals: '[1,2,3]'.	self assert: (writer value: #[]) equals: '[]'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testDate	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Date customDo: [ :mapping |					mapping encoder: [ :date | date yyyymmdd ] ];				nextPut: object ] ].	self assert: (writer value: (Date fromString: '2012-06-08')) equals: '"2012-06-08"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testDateAndTime 	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: DateAndTime customDo: [ :mapping |					mapping encoder: [ :dateAndTime | dateAndTime printString ] ];				nextPut: object ] ].	self 		assert: (writer value: (DateAndTime year: 2012 month: 2 day: 14 hour: 16 minute: 40 second: 18 offset: 1 hour)) 		equals: '"2012-02-14T16:40:18+01:00"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testFloatPrinter	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				floatPrinter: NeoJSONFloatPrinter new;				nextPut: object ] ].	self assert: (writer value: 123.0) equals: '123'.	self assert: (writer value: -123.0) equals: '-123'.	self assert: (writer value: 0.0) equals: '0'.	self assert: (writer value: 1.50) equals: '1.5'.	self assert: (writer value: -1.25) equals: '-1.25'.	self assert: (writer value: Float pi) equals: '3.14159'.	self assert: (writer value: 9.10938356e-31) equals: '9.10938e-31'.	self assert: (writer value: 5.9724e24) equals: '5.9724e24'.	self assert: (writer value: 1234567890.1234567890) equals: '1.23457e9'.	self assert: (writer value: (1/3) asFloat) equals: '0.33333'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testFloats	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: 123.0) equals: '123.0'.	self assert: (writer value: -123.0) equals: '-123.0'.	self assert: (writer value: 0.0) equals: '0.0'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testIntegers	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: 123) equals: '123'.	self assert: (writer value: -123) equals: '-123'.	self assert: (writer value: 0) equals: '0'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testLists	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: #(1 2 3)) equals: '[1,2,3]'.	self assert: (writer value: #()) equals: '[]'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testListsExtra	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	#( OrderedCollection LinkedList ByteArray IntegerArray SortedCollection ) do: [ :each |		Smalltalk at: each ifPresent: [ :collectionClass |			self assert: (writer value: (collectionClass withAll: #(1 2 3))) equals: '[1,2,3]'.			self assert: (writer value: collectionClass new) equals: '[]' ] ]! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testMapKeysMustBeStrings	self should: [ NeoJSONWriter toString: { 1->#a } asDictionary ] raise: Error.	self should: [ NeoJSONWriter toString: { true->#a } asDictionary ] raise: Error.	self should: [ NeoJSONWriter toString: { nil->#a } asDictionary ] raise: Error.	self should: [ NeoJSONWriter toString: { #()->#a } asDictionary ] raise: Error.	self should: [ NeoJSONWriter toString: { Dictionary new->#a } asDictionary ] raise: Error.	self should: [ NeoJSONWriter toString: { Float pi->#a } asDictionary ] raise: Error.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testMaps	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: ((writer value: (Dictionary newFromPairs: #( 'x' 1 'y' 2))) includesSubstring: '"x":1').	self assert: ((writer value: (Dictionary newFromPairs: #( 'x' 1 'y' 2))) includesSubstring: '"y":2').	self assert: (writer value: Dictionary new) equals: '{}'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testMapsExtra	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: (IdentityDictionary newFromPairs: #( 'x' 1))) equals: '{"x":1}'.	self assert: (writer value: IdentityDictionary new) equals: '{}'.	#( SmallDictionary OrderedDictionary OrderedIdentityDictionary ) do: [ :each |		| dictionaryClass |		dictionaryClass := Smalltalk at: each ifAbsent: [ nil ].		dictionaryClass ifNotNil: [				self assert: (writer value: (dictionaryClass new at: 'x' put: 1; at: 'y' put: 2; yourself)) equals: '{"x":1,"y":2}'.			self assert: (writer value: dictionaryClass new) equals: '{}'] ]! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testNextPutStringAsHex	| output |	output := String		streamContents: [ :out | 			(NeoJSONWriter on: out)				for: #StringAsHex					customDo: [ :mapping | 							mapping								encoder: [ :x | x asByteArray hex asUppercase ];								decoder: [ :x | (ByteArray readHexFrom: x) asString ] ];				nextPut: 'Foo bar!!' as: #StringAsHex ].	self assert: output equals: '"466F6F2062617221"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testNonBMPCharacterEncoding	"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"	| string json |	string := 16r1D11E asCharacter asString. "MUSICAL SYMBOL G CLEF"	json := String streamContents: [ :out |		(NeoJSONWriter on: out) asciiOnly: true; nextPut: string ].	self assert: json equals: '"\uD834\uDD1E"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testNull	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: nil) equals: 'null'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testPoint	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self should: [ writer value: 1@2 ] raise: NeoJSONMappingNotFound! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testPoint1	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Point do: [ :mapping |					mapping mapProperty: 'x' getter: [ :point | point x ] setter: [ :point :value | point x: value ].					mapping mapProperty: 'y' getter: [ :point | point y ] setter: [ :point :value | point y: value ]. ];				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testPoint2	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				mapAllInstVarsFor: Point;				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testPoint3	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Point do: [ :mapping |					mapping mapInstVars: #(x y) ];				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testPointUsingAsString	| output |	output := String		streamContents: [ :out | 			(NeoJSONWriter on: out)				for: Point					do: [ :mapping | 							(mapping 								mapProperty: #x 								getter: [ :object | object x ] 								setter: [ :object :value | object setX: value setY: object y ])								valueSchema: #AsString.							(mapping								mapProperty: #y								getter: [ :object | object y ]								setter: [ :object :value | object setX: object x setY: value ]) 								valueSchema: #AsString ];				for: #AsString					customDo: [ :mapping | 							mapping								encoder: [ :x | x asString ];								decoder: [ :x | x asNumber ] ];				nextPut: 1 @ 2 ].	self assert: output equals: '{"x":"1","y":"2"}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testPointWriteNil	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				writeNil: true;				mapAllInstVarsFor: Point;				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{"x":null,"y":null}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testPreservePropertyOrder	| writer testObject |	(testObject := NeoJSONTestObject2 new)		id: 123;		width: 100;		height: 50;		data: 'test'.	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: NeoJSONTestObject2 do: [ :mapping | mapping mapInstVars: #(id width height data) ];				nextPut: object ] ].	self assert: (writer value: testObject) equals: '{"id":123,"width":100,"height":50,"data":"test"}'.	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: NeoJSONTestObject2 do: [ :mapping | mapping mapInstVars: #(width height data id) ];				nextPut: object ] ].	self assert: (writer value: testObject) equals: '{"width":100,"height":50,"data":"test","id":123}'.	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: NeoJSONTestObject2 do: [ :mapping | mapping mapInstVars: #(data id height width) ];				nextPut: object ] ].	self assert: (writer value: testObject) equals: '{"data":"test","id":123,"height":50,"width":100}'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testStrings	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: 'foo') equals: '"foo"'.	self assert: (writer value: 'Foo BAR') equals: '"Foo BAR"'.	self assert: (writer value: '') equals: '""'.	self		assert: (writer value: (String withAll: ( OrderedCollection new 			add: $";			add: $\; 			add: $/;			add: Character tab;			add: Character cr;			add: Character lf;			add: Character newPage; 			add: Character backspace;			yourself )))		equals: '"\"\\/\t\r\n\f\b"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testSymbol	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: #foo) equals: '"foo"'.	self assert: (writer value: #'FOO-1') equals: '"FOO-1"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: '3/1/2025 19:49'!testTime	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Time customDo: [ :mapping |					mapping encoder: [ :time | time printString ] ];				nextPut: object ] ].	self assert: ((writer value: (Time fromSeconds: 52208)) includesSubstring: '2:30:08')! !!NeoJSONBenchmark methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!initialize	super initialize.	objects := Array new: 1000.	1 to: 1000 do: [ :each |		| map |		(map := Dictionary new)			at: 'id' put: each;			at: 'name' put: 'Name-', each asString;			at: 'enabled' put: (#( true false) at: (each \\ 2) + 1);			at: 'color' put: (#( 'red' 'green' 'blue' ) at: (each \\ 3) + 1);			at: 'value' put: each + each / 1000.0.		objects at: each put: map ].	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) nextPut: objects ]		! !!NeoJSONBenchmark methodsFor: 'public' stamp: '3/1/2025 19:49'!read	^ (NeoJSONReader on: json readStream) next! !!NeoJSONBenchmark methodsFor: 'public' stamp: '3/1/2025 19:49'!write	^ String streamContents: [ :stream |		(NeoJSONWriter on: stream) nextPut: objects ]! !!NeoJSONBenchmark methodsFor: 'public' stamp: '3/1/2025 19:49'!writePrettyPrintedRead	| output |	output := String streamContents: [ :stream |		(NeoJSONWriter on: stream) 			prettyPrint: true;			nextPut: objects ].	^ (NeoJSONReader on: output readStream) 		next! !!NeoJSONMockStream class methodsFor: 'instance creation' stamp: '3/1/2025 19:49'!on: stream	^ self new		stream: stream;		yourself! !!NeoJSONMockStream methodsFor: 'testing' stamp: '3/1/2025 19:49'!atEnd	^ stream atEnd! !!NeoJSONMockStream methodsFor: 'accessing' stamp: '3/1/2025 19:49'!close	^ stream close! !!NeoJSONMockStream methodsFor: 'accessing' stamp: '3/1/2025 19:49'!collectionSpecies	^ stream collectionSpecies! !!NeoJSONMockStream methodsFor: 'accessing' stamp: '3/1/2025 19:49'!next	^ stream next! !!NeoJSONMockStream methodsFor: 'accessing' stamp: '3/1/2025 19:49'!nextPut: character	^ stream nextPut: character! !!NeoJSONMockStream methodsFor: 'accessing' stamp: '3/1/2025 19:49'!nextPutAll: string	^ stream nextPutAll: string! !!NeoJSONMockStream methodsFor: 'accessing' stamp: '3/1/2025 19:49'!peek	^ stream peek! !!NeoJSONMockStream methodsFor: 'accessing' stamp: '3/1/2025 19:49'!peekFor: char	^ stream peekFor: char! !!NeoJSONMockStream methodsFor: 'accessing' stamp: '3/1/2025 19:49'!space	^ stream space! !!NeoJSONMockStream methodsFor: 'initialize-release' stamp: '3/1/2025 19:49'!stream: anObject	stream := anObject! !!NeoJSONTestObject1 class methodsFor: 'instance creation' stamp: '3/1/2025 19:49'!example1	^ self new		id: 123;		name: 'Example1';		timestamp: (DateAndTime year: 2012 month: 06 day: 08 hour: 14 minute: 30 second: 15 offset: 1 hour);		points: (Array with: 1@2 with: 3@4);		bytes: #[ 2 4 6 8 ];		yourself! !!NeoJSONTestObject1 class methodsFor: 'accessing' stamp: '3/1/2025 19:49'!neoJsonMapping: mapper	mapper for: self do: [ :mapping |		mapping mapInstVars: #(id name).		(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.		(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.		(mapping mapInstVar: #bytes) valueSchema: ByteArray ].	mapper for: DateAndTime customDo: [ :mapping |		mapping decoder: [ :string | DateAndTime fromString: string ].		mapping encoder: [ :dateAndTime | dateAndTime printString ] ].	mapper for: #ArrayOfPoints customDo: [ :mapping |		mapping listOfElementSchema: Point ].  	mapper mapAllInstVarsFor: Point.	mapper for: ByteArray customDo: [ :mapping |		mapping listOfType: ByteArray ]! !!NeoJSONTestObject1 methodsFor: 'comparing' stamp: '3/1/2025 19:49'!= anObject	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ id = anObject id		and: [			name = anObject name				and: [					timestamp = anObject timestamp						and: [							points = anObject points								and: [ bytes = anObject bytes ] ] ] ]! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: '3/1/2025 19:49'!bytes	^ bytes! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: '3/1/2025 19:49'!bytes: byteArray	bytes := byteArray! !!NeoJSONTestObject1 methodsFor: 'comparing' stamp: '3/1/2025 19:49'!hash	^ id hash bitXor: (name hash bitXor: (timestamp hash bitXor: (points hash bitXor: bytes hash)))! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: '3/1/2025 19:49'!id	^ id! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: '3/1/2025 19:49'!id: integer	id := integer! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: '3/1/2025 19:49'!name	^ name! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: '3/1/2025 19:49'!name: string	name := string! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: '3/1/2025 19:49'!points	^ points! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: '3/1/2025 19:49'!points: arrayOfPoints	points := arrayOfPoints ! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: '3/1/2025 19:49'!timestamp	^ timestamp! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: '3/1/2025 19:49'!timestamp: dateAndTime 	timestamp := dateAndTime ! !!NeoJSONTestObject2 class methodsFor: 'testing' stamp: '3/1/2025 19:49'!benchmark10k	"self benchmark10k"		self benchmark: 10000! !!NeoJSONTestObject2 class methodsFor: 'testing' stamp: '3/1/2025 19:49'!benchmark10kAsDictionary	"self benchmark10kAsDictionary"		self benchmarkAsDictionary: 10000! !!NeoJSONTestObject2 class methodsFor: 'testing' stamp: '3/1/2025 19:49'!benchmark200k	"self benchmark200k"		self benchmark: 200000! !!NeoJSONTestObject2 class methodsFor: 'testing' stamp: '3/1/2025 19:49'!benchmark: count	"self benchmark: 1000"		| collection json size |	collection := Array new: count withAll: self example1.	size := 2 + (count * (NeoJSONWriter toString: self example1) size) + count - 1.	Transcript 		cr;		<< ('Serializing {1} objects took ms ' format: (Array with: count) );		show: [ json := String new: size streamContents: [ :stream |								(NeoJSONWriter on: stream) nextPut: collection ] ] timeToRun.	Transcript 		cr;		<< ('Deserializing {1} objects took ms ' format: (Array with: count) );		show: [ NeoJSONReader fromString: json ] timeToRun.! !!NeoJSONTestObject2 class methodsFor: 'testing' stamp: '3/1/2025 19:49'!benchmarkAsDictionary: count	"self benchmarkAsDictionary: 1000"		| collection json size |	collection := Array new: count withAll: self example1 asDictionary.	size := 2 + (count * (NeoJSONWriter toString: self example1 asDictionary) size) + count - 1.	Transcript 		cr;		<< ('Serializing {1} objects took ms ' format: (Array with: count) );		show: [ json := String new: size streamContents: [ :stream |								(NeoJSONWriter on: stream) nextPut: collection ] ] timeToRun.	Transcript 		cr;		<< ('Deserializing {1} objects took ms ' format: (Array with: count) );		show: [ NeoJSONReader fromString: json ] timeToRun.! !!NeoJSONTestObject2 class methodsFor: 'instance creation' stamp: '3/1/2025 19:49'!example1	^ self new		id: 13;		width: 250;		height: 110;		data: (String new: 512 withAll: $a);		yourself! !!NeoJSONTestObject2 class methodsFor: 'accessing' stamp: '3/1/2025 19:49'!neoJsonMapping: mapper	"For inheritance mapping to work, the schema/classname must be self,	but the instance variables have to be enumerated manually per class"	mapper for: self do: [ :mapping |		mapping mapInstVars: #(id width height data) ] ! !!NeoJSONTestObject2 methodsFor: 'comparing' stamp: '3/1/2025 19:49'!= anObject	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ id = anObject id		and: [			height = anObject height				and: [					width = anObject width						and: [							data = anObject data ] ] ]! !!NeoJSONTestObject2 methodsFor: 'converting' stamp: '3/1/2025 19:49'!asDictionary	^ Dictionary new		at: #id put: id;		at: #height put: height;		at: #width put: width;		at: #data put: data;		yourself! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: '3/1/2025 19:49'!data	^ data! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: '3/1/2025 19:49'!data: anObject	data := anObject! !!NeoJSONTestObject2 methodsFor: 'comparing' stamp: '3/1/2025 19:49'!hash	^ id hash bitXor: (width hash bitXor: (height hash bitXor: data hash))! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: '3/1/2025 19:49'!height	^ height! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: '3/1/2025 19:49'!height: anObject	height := anObject! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: '3/1/2025 19:49'!id	^ id! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: '3/1/2025 19:49'!id: anObject	id := anObject! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: '3/1/2025 19:49'!width	^ width! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: '3/1/2025 19:49'!width: anObject	width := anObject! !!NeoJSONTestObject3 class methodsFor: 'instance creation' stamp: '3/1/2025 19:49'!example1	^ super example1		data: (String new: 8 withAll: $a);		color: 'red';		transparent: true;		yourself! !!NeoJSONTestObject3 class methodsFor: 'accessing' stamp: '3/1/2025 19:49'!neoJsonMapping: mapper	"For inheritance mapping to work, the schema/classname must be self,	but the instance variables have to be enumerated manually per class"		super neoJsonMapping: mapper.	mapper for: self do: [ :mapping |		mapping mapInstVars: #(color transparent) ]! !!NeoJSONTestObject3 methodsFor: 'comparing' stamp: '3/1/2025 19:49'!= anObject	^ super = anObject 		and: [ color = anObject color			and: [ transparent = anObject transparent ] ]! !!NeoJSONTestObject3 methodsFor: 'converting' stamp: '3/1/2025 19:49'!asDictionary	^ super asDictionary		at: #color put: color;		at: #transparent put: transparent;		yourself! !!NeoJSONTestObject3 methodsFor: 'accessing' stamp: '3/1/2025 19:49'!color	^ color! !!NeoJSONTestObject3 methodsFor: 'accessing' stamp: '3/1/2025 19:49'!color: anObject	color := anObject! !!NeoJSONTestObject3 methodsFor: 'accessing' stamp: '3/1/2025 19:49'!transparent	^ transparent! !!NeoJSONTestObject3 methodsFor: 'accessing' stamp: '3/1/2025 19:49'!transparent: anObject	transparent := anObject! !!NeoJSONValidation methodsFor: 'private' stamp: '3/1/2025 19:49'!closeLog	logStream ifNotNil: [ 		logStream close.		logStream := nil ].	^ self logFile exists		ifTrue: [ self logFile contents ] 		ifFalse: [ 'log file is empty' ]! !!NeoJSONValidation methodsFor: 'private' stamp: '3/1/2025 19:49'!ensureLog	logStream ifNil: [ 		logStream := self logFile ensureDelete; writeStream. 		logStream setToEnd ]	! !!NeoJSONValidation methodsFor: 'accessing' stamp: '3/1/2025 19:49'!gitDirectory	^ gitDirectory ifNil: [ gitDirectory := FileLocator home / #Develop / #git ]! !!NeoJSONValidation methodsFor: 'accessing' stamp: '3/1/2025 19:49'!gitDirectory: fileReference	gitDirectory := fileReference! !!NeoJSONValidation methodsFor: 'accessing' stamp: '3/1/2025 19:49'!jsonTestSuiteDirectory	^ self gitDirectory / #JSONTestSuite! !!NeoJSONValidation methodsFor: 'accessing' stamp: '3/1/2025 19:49'!jsonTestSuiteTestParsingDirectory	^ self jsonTestSuiteDirectory / 'test_parsing'! !!NeoJSONValidation methodsFor: 'accessing' stamp: '3/1/2025 19:49'!jsonTestSuiteTestParsingFailFiles	^ self jsonTestSuiteTestParsingDirectory childrenMatching: 'n_*.json'! !!NeoJSONValidation methodsFor: 'accessing' stamp: '3/1/2025 19:49'!jsonTestSuiteTestParsingInfoFiles	^ self jsonTestSuiteTestParsingDirectory childrenMatching: 'i_*.json'! !!NeoJSONValidation methodsFor: 'accessing' stamp: '3/1/2025 19:49'!jsonTestSuiteTestParsingPassFiles	^ self jsonTestSuiteTestParsingDirectory childrenMatching: 'y_*.json'! !!NeoJSONValidation methodsFor: 'accessing' stamp: '3/1/2025 19:49'!jsonTestSuiteTestTransformDirectory	^ self jsonTestSuiteDirectory / 'test_transform'! !!NeoJSONValidation methodsFor: 'private' stamp: '3/1/2025 19:49'!log: message	self ensureLog.	logStream nextPutAll: message; lf; flush! !!NeoJSONValidation methodsFor: 'private' stamp: '3/1/2025 19:49'!logFile	^ 'neo-json-validation.log' asFileReference! !!NeoJSONValidation methodsFor: 'accessing' stamp: '3/1/2025 19:49'!nativeJsonBenchmarkDataDirectory	^ self nativeJsonBenchmarkDirectory / #data! !!NeoJSONValidation methodsFor: 'accessing' stamp: '3/1/2025 19:49'!nativeJsonBenchmarkDirectory	^ self gitDirectory / 'nativejson-benchmark'! !!NeoJSONValidation methodsFor: 'accessing' stamp: '3/1/2025 19:49'!nativeJsonBenchmarkJsonCheckerDirectory	^ self nativeJsonBenchmarkDataDirectory / #jsonchecker! !!NeoJSONValidation methodsFor: 'accessing' stamp: '3/1/2025 19:49'!nativeJsonBenchmarkJsonCheckerFailFiles	^ self nativeJsonBenchmarkJsonCheckerDirectory childrenMatching: 'fail*.json'! !!NeoJSONValidation methodsFor: 'accessing' stamp: '3/1/2025 19:49'!nativeJsonBenchmarkJsonCheckerPassFiles	^ self nativeJsonBenchmarkJsonCheckerDirectory childrenMatching: 'pass*.json'! !!NeoJSONValidation methodsFor: 'accessing' stamp: '3/1/2025 19:49'!nativeJsonBenchmarkRoundTripDirectory	^ self nativeJsonBenchmarkDataDirectory / #roundtrip! !!NeoJSONValidation methodsFor: 'accessing' stamp: '3/1/2025 19:49'!nativeJsonBenchmarkRoundTripFiles	^ self nativeJsonBenchmarkRoundTripDirectory children! !!NeoJSONValidation methodsFor: 'running' stamp: '3/1/2025 19:49'!runJsonTestSuiteTestParsingFailures	^ self		validateFiles: self jsonTestSuiteTestParsingFailFiles 		usingTest: [ :file | 			| data success |			success := false.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next; failIfNotAtEnd ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := true ].			success ]! !!NeoJSONValidation methodsFor: 'running' stamp: '3/1/2025 19:49'!runJsonTestSuiteTestParsingInfo	^ self		validateFiles: self jsonTestSuiteTestParsingInfoFiles 		usingTest: [ :file | 			| data success |			success := true.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := false ].			success ]! !!NeoJSONValidation methodsFor: 'running' stamp: '3/1/2025 19:49'!runJsonTestSuiteTestParsingPasses	^ self		validateFiles: self jsonTestSuiteTestParsingPassFiles 		usingTest: [ :file | 			| data success |			success := true.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := false ].			success ]! !!NeoJSONValidation methodsFor: 'running' stamp: '3/1/2025 19:49'!runNativeJsonBenchmarkJsonCheckerFailures	^ self		validateFiles: self nativeJsonBenchmarkJsonCheckerFailFiles		usingTest: [ :file | 			| data success |			success := false.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next; failIfNotAtEnd ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := true ].			success ]! !!NeoJSONValidation methodsFor: 'running' stamp: '3/1/2025 19:49'!runNativeJsonBenchmarkJsonCheckerPasses	^ self		validateFiles: self nativeJsonBenchmarkJsonCheckerPassFiles		usingTest: [ :file | 			| data success |			success := true.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := false ].			success ]! !!NeoJSONValidation methodsFor: 'running' stamp: '3/1/2025 19:49'!runNativeJsonBenchmarkRoundTrip	^ self 		validateFiles: self nativeJsonBenchmarkRoundTripFiles		usingTest: [ :file |			| data json |			data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ].			json := NeoJSONWriter toString: data.			json = file contents ]! !!NeoJSONValidation methodsFor: 'private' stamp: '3/1/2025 19:49'!validateFiles: files usingTest: block	| total succeeded failed |	total := succeeded := failed := 0.	files do: [ :file | 		| success |		self log: 'Running ' , file pathString.		self log: ([ file contents contractTo: 64 ] on: Error do: [ :exception | exception printString ]).		success := [ block value: file ]			on: Error			do: [ :exception | self log: '  Errored. ' , exception printString. false ].		total := total + 1.		success			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed := failed + 1 ].		self log: (success ifTrue: [ '  Succeeded' ] ifFalse: [ '  Failed' ]); log: '' ].	self log: ('{1} total = {2} succeeded + {3} failed' format: (Array with: total with: succeeded with: failed) ).	^ self closeLog! !"Neo-JSON-Tests"!!OrderedDictionary methodsFor: '*neo-json-pharo-core' stamp: '3/1/2025 19:49'!neoJsonOn: neoJSONWriter	neoJSONWriter writeMap: self! !!SmallDictionary methodsFor: '*neo-json-pharo-core' stamp: '3/1/2025 19:49'!neoJsonOn: neoJSONWriter	neoJSONWriter writeMap: self! !"Neo-JSON-Pharo-Core"!Object subclass: #GuildAPI    instanceVariableNames: ''    classVariableNames: ''    poolDictionaries: ''    category: 'Guild-Backend'.!!GuildAPI methodsFor: 'nil' stamp: '3/1/2025 21:17'!handleRequest: aRequest    | path method json response |    path := aRequest path.    method := aRequest method.    "Dispatch based on the request path and method"    method = 'GET'        ifTrue: [ response := self handleGET: path ]        ifFalse: [ response := self handlePOST: path aRequest: aRequest ].    json := NeoJSONWriter toString: response.    ^ZnResponse ok        contentType: 'application/json';        contents: json.! !!GuildAPI methodsFor: 'nil' stamp: '3/1/2025 21:20'!handleGET: aPath	 ^Dictionary new    at: 'message' put: 'GET request handled for ', aPath;    yourself.! !!GuildAPI methodsFor: 'as yet unclassified' stamp: '3/1/2025 21:20' prior: 831681!handleGET: aPath	 ^Dictionary new    at: 'message' put: 'GET request handled for ', aPath;    yourself.! !!GuildAPI methodsFor: 'nil' stamp: '3/1/2025 21:21'!handlePOST: aPath aRequest: aRequest	^Dictionary new    at: 'message' put: 'POST request handled for ', aPath;    yourself.! !!GuildAPI methodsFor: 'as yet unclassified' stamp: '3/1/2025 21:21' prior: 832393!handlePOST: aPath 	aRequest: aRequest	^Dictionary new    at: 'message' put: 'POST request handled for ', aPath;    yourself.! !!GuildAPI methodsFor: 'as yet unclassified' stamp: '3/1/2025 21:21' prior: 832819!handlePOST: aPath aRequest: aRequest	^Dictionary new    at: 'message' put: 'POST request handled for ', aPath;    yourself.! !!GuildAPI methodsFor: 'public' stamp: '3/1/2025 21:21' prior: 830677!handleRequest: aRequest    | path method json response |    path := aRequest path.    method := aRequest method.    "Dispatch based on the request path and method"    method = 'GET'        ifTrue: [ response := self handleGET: path ]        ifFalse: [ response := self handlePOST: path aRequest: aRequest ].    json := NeoJSONWriter toString: response.    ^ZnResponse new    	status: 200;    	contentType: 'application/json';    	contents: json.! !!ManifestGuildBackend commentStamp: '<historical>' prior: 0!Please describe the package using the class comment of the included manifest class. The manifest class also includes other additional metadata for the package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!ManifestGuildBackend class methodsFor: 'code-critics' stamp: '3/1/2025 21:33'!ruleAssignmentInIfTrueRuleV1FalsePositive	<ignoreForCoverage>	^ #()! !!ManifestGuildBackend class methodsFor: 'code-critics' stamp: '3/1/2025 21:33' prior: 835379!ruleAssignmentInIfTrueRuleV1FalsePositive	<ignoreForCoverage>	^ #(#(#(#RGMethodDefinition #(#GuildAPI #handleRequest: #false)) #'2025-03-01T21:33:48.354563-05:00') )! !!GuildAPI methodsFor: 'nil' stamp: '3/1/2025 21:43'!handleNotFound: aPath	 ^Dictionary new    at: 'message' put: 'NotFound request handled for ', aPath;    yourself.! !!GuildAPI methodsFor: 'public' stamp: '3/1/2025 21:45' prior: 833649!handleRequest: aRequest    | path method response |    path := aRequest path.    method := aRequest method.    "Dispatch based on the request path and method"    (method = 'GET' and: [path = '/getResources'])        ifTrue: [ response := self handleGET: path ]        ifFalse: [            (method = 'POST' and: [path = '/postResources'])                ifTrue: [ response := self handlePOST: path aRequest: aRequest ]                ifFalse: [ response := self handleNotFound: path ]        ].    ^response! !!GuildAPI methodsFor: 'as yet unclassified' stamp: '3/1/2025 21:53' prior: 832067!handleGET: aPath    | responseDict jsonResponse |    "Create a dictionary with the response message"    responseDict := Dictionary new.    responseDict at: 'message' put: 'GET request handled for ', aPath.    "Convert the dictionary to a JSON string"    jsonResponse := NeoJSONWriter toString: responseDict.    "Create and return the HTTP response"    ^ZnResponse new        status: 200; "HTTP 200 OK"        contentType: 'application/json';        contents: jsonResponse.! !Object << #MyRequestHandler	layout: FixedLayout;	traits: {};	slots: {};	sharedVariables: {};	sharedPools: {};	tag: '' ;	package: 'Guild-Backend'!GuildAPI removeSelector: #handleRequest:!!MyRequestHandler methodsFor: 'nil' stamp: '3/1/2025 21:59'!handleRequest: aRequest    | path method response |    path := aRequest path.    method := aRequest method.    "Dispatch based on the request path and method"    (method = 'GET' and: [path = '/getResources'])        ifTrue: [ response := self handleGET: path ]        ifFalse: [            (method = 'POST' and: [path = '/postResources'])                ifTrue: [ response := self handlePOST: path aRequest: aRequest ]                ifFalse: [ response := self handleNotFound: path ]        ].    ^response! !Smalltalk globals removeClassNamed: #AnObsoleteMyRequestHandler!!GuildAPI methodsFor: 'nil' stamp: '3/1/2025 21:59'!handleRequest: aRequest    | path method response |    path := aRequest path.    method := aRequest method.    "Dispatch based on the request path and method"    (method = 'GET' and: [path = '/getResources'])        ifTrue: [ response := self handleGET: path ]        ifFalse: [            (method = 'POST' and: [path = '/postResources'])                ifTrue: [ response := self handlePOST: path aRequest: aRequest ]                ifFalse: [ response := self handleNotFound: path ]        ].    ^response! !!GuildAPI methodsFor: 'public' stamp: '3/1/2025 22:00' prior: 840531!handleRequest: aRequest    | path method response |    path := aRequest path.    method := aRequest method.    "Dispatch based on the request path and method"    (method = 'GET' and: [path = '/getResources'])        ifTrue: [ response := self handleGET: path ]        ifFalse: [            (method = 'POST' and: [path = '/postResources'])                ifTrue: [ response := self handlePOST: path aRequest: aRequest ]                ifFalse: [ response := self handleNotFound: path ]        ].    ^response! !!GuildAPI methodsFor: 'as yet unclassified' stamp: '3/1/2025 22:03'!handleGET    | dbContents jsonResponse |    dbContents := self retrieveDatabaseContents. "Implement this method to fetch data"    jsonResponse := NeoJSONWriter toString: dbContents.    ^ZnResponse new        status: 200;        contentType: 'application/json';        contents: jsonResponse.! !GuildAPI removeSelector: #handleGET:!!GuildAPI methodsFor: 'public' stamp: '3/1/2025 22:04' prior: 841717!handleRequest: aRequest    | path method response |    path := aRequest path.    method := aRequest method.    "Dispatch based on the request path and method"    (method = 'GET' and: [path = '/getResources'])        ifTrue: [ response := self handleGET. ]        ifFalse: [            (method = 'POST' and: [path = '/postResources'])                ifTrue: [ response := self handlePOST: path aRequest: aRequest ]                ifFalse: [ response := self handleNotFound: path ]        ].    ^response! !!GuildAPI methodsFor: 'as yet unclassified' stamp: '3/1/2025 22:04'!handlePOST: aRequest    | jsonRequest |    jsonRequest := NeoJSONReader fromString: aRequest contents. "Parse incoming JSON"    self updateDatabaseWith: jsonRequest. "Implement this method to update data"    ^ZnResponse new        status: 200;        contentType: 'application/json';        contents: '{"status": "success"}'.! !GuildAPI removeSelector: #handlePOST:aRequest:!!GuildAPI methodsFor: 'public' stamp: '3/1/2025 22:05' prior: 843723!handleRequest: aRequest    | path method response |    path := aRequest path.    method := aRequest method.    "Dispatch based on the request path and method"    (method = 'GET' and: [path = '/getResources'])        ifTrue: [ response := self handleGET. ]        ifFalse: [            (method = 'POST' and: [path = '/postResources'])                ifTrue: [ response := self handlePOST: aRequest ]                ifFalse: [ response := self handleNotFound: path ]        ].    ^response! !!GuildAPI methodsFor: 'as yet unclassified' stamp: '3/1/2025 22:05'!handleNotFound    ^ZnResponse new        status: 404;        contentType: 'application/json';        contents: '{"error": "Not Found"}'.! !GuildAPI removeSelector: #handleNotFound:!!GuildAPI methodsFor: 'public' stamp: '3/1/2025 22:05' prior: 845807!handleRequest: aRequest    | path method response |    path := aRequest path.    method := aRequest method.    "Dispatch based on the request path and method"    (method = 'GET' and: [path = '/getResources'])        ifTrue: [ response := self handleGET. ]        ifFalse: [            (method = 'POST' and: [path = '/postResources'])                ifTrue: [ response := self handlePOST: aRequest ]                ifFalse: [ response := self handleNotFound. ]        ].    ^response! !!GuildAPI methodsFor: 'public' stamp: '3/1/2025 22:05' prior: 847467!handleRequest: aRequest    | path method response |    path := aRequest path.    method := aRequest method.    "Dispatch based on the request path and method"    (method = 'GET' and: [path = '/getResources'])        ifTrue: [ response := self handleGET ]        ifFalse: [            (method = 'POST' and: [path = '/postResources'])                ifTrue: [ response := self handlePOST: aRequest ]                ifFalse: [ response := self handleNotFound ]        ].    ^response! !!GuildAPI methodsFor: 'nil' stamp: '3/1/2025 22:10'!retrieveDatabaseContents    | connection dbFile query result |    dbFile := ( Smalltalk imageDirectory / 'guilds.db') fullName.    connection := SQLite3Connection on: dbFile.    connection open.    query := 'SELECT * FROM resources;'.    result := connection execute: query.    connection close.    ^result! !!GuildAPI methodsFor: 'as yet unclassified' stamp: '3/1/2025 22:12' prior: 842901!handleGET    | dbContents jsonResponse |    dbContents := self retrieveDatabaseContents.    jsonResponse := NeoJSONWriter toString: dbContents.    ^ZnResponse new        status: 200;        contentType: 'application/json';        contents: jsonResponse.! !!GuildAPI methodsFor: 'as yet unclassified' stamp: '3/1/2025 22:12' prior: 844897!handlePOST: aRequest    | jsonRequest |    jsonRequest := NeoJSONReader fromString: aRequest contents.    self updateDatabaseWith: jsonRequest.    ^ZnResponse new        status: 200;        contentType: 'application/json';        contents: '{"status": "success"}'.! !!GuildAPI methodsFor: 'as yet unclassified' stamp: '3/1/2025 22:19' prior: 851199!handlePOST: aRequest    | connection dbFile jsonRequest |    dbFile := (Smalltalk imageDirectory / 'guilds.db') fullName.    connection := SQLite3Connection on: dbFile.    connection open.    jsonRequest := NeoJSONReader fromString: aRequest contents.    jsonRequest do: [ :each |        | name amount changePerDay |        name := each at: 'name'.        amount := each at: 'amount'.        changePerDay := each at: 'changePerDay'.        connection execute: 'UPDATE resources SET amount = ?, changePerDay = ? WHERE name = ?'            value: amount            value: changePerDay            value: name.    ].    connection commit.    connection close.    ^ZnResponse new        status: 200;        contentType: 'application/json';        contents: '{"status": "success"}'.! !!GuildAPI methodsFor: 'nil' stamp: '3/1/2025 22:20'!updateDatabaseWith: jsonRequest    | connection dbFile jsonRequest |    dbFile := (Smalltalk imageDirectory / 'guilds.db') fullName.    connection := SQLite3Connection on: dbFile.    connection open.    jsonRequest := NeoJSONReader fromString: jsonRequest contents.    jsonRequest do: [ :each |        | name amount changePerDay |        name := each at: 'name'.        amount := each at: 'amount'.        changePerDay := each at: 'changePerDay'.        connection execute: 'UPDATE resources SET amount = ?, changePerDay = ? WHERE name = ?'            value: amount            value: changePerDay            value: name.    ].    connection commit.    connection close.    ^ZnResponse new        status: 200;        contentType: 'application/json';        contents: '{"status": "success"}'.! !GuildAPI removeSelector: #updateDatabaseWith:!!GuildAPI methodsFor: 'public' stamp: '3/1/2025 22:30' prior: 848603!handleRequest: aRequest    | path method response |    path := aRequest uri path.    method := aRequest method.    "Dispatch based on the request path and method"    (method = 'GET' and: [path = '/getResources'])        ifTrue: [ response := self handleGET ].    (method = 'POST' and: [path = '/postResources'])        ifTrue: [ response := self handlePOST: aRequest ].    response ifNil: [ response := self handleNotFound ].    ^response! !!GuildAPI methodsFor: 'as yet unclassified' stamp: '3/1/2025 22:32' prior: 850505!handleGET    | dbContents jsonResponse response |    dbContents := self retrieveDatabaseContents.    jsonResponse := NeoJSONWriter toString: dbContents.    response := ZnResponse new.    response statusCode: 200 message: 'OK'.    response contentType: 'application/json'.    response contents: jsonResponse.    ^response.! !Object << #Handler	layout: FixedLayout;	traits: {};	slots: {};	sharedVariables: {};	sharedPools: {};	tag: '' ;	package: 'Guilds'!!BaselineOfSton commentStamp: 'SvenVanCaekenberghe 10/8/2018 15:45' prior: 0!I am BaselineOfSton, I load STON (Smalltalk Object Notation).I am a BaselineOf.!!BaselineOfSton methodsFor: 'baselines' stamp: '4/18/2024 03:56:23'!baseline: spec	<baseline>	spec		for: #common		do: [ spec blessing: #baseline.			spec				package: 'STON-Core';				package: 'STON-Extensions';				package: 'STON-Tests';				package: 'STON-Text support';				group: 'Core' with: #('STON-Core');				group: 'default' with: #('STON-Core' 'STON-Extensions' 'STON-Text support' 'STON-Tests') ]! !"BaselineOfSton"!!STONWriter methodsFor: 'private' stamp: '4/18/2024 03:56:23' prior: 58750780!encodeCharacter: char	| code encoding |	"STONCharacters contains for the lower 127 characters (codes 0 to 126) either nil (unknown),	#pass (output as is, clean ASCII characters) or a full escape string"	((code := char codePoint) < 127 and: [ (encoding := self stonCharacters at: code + 1) notNil ])		ifTrue: [			(encoding = #pass or: [ jsonMode and: [ char = $' ] ])				ifTrue: [ writeStream nextPut: char ]				ifFalse: [ writeStream nextPutAll: encoding ] ]		ifFalse: [			"always escape Latin1 C1 controls, or when asciiOnly is true"			(code > 16r9F and: [ asciiOnly not ])				ifTrue: [ writeStream nextPut: char ]				ifFalse: [ self escapeUnicode: code ] ]! !!STONWriter methodsFor: 'private' stamp: '4/18/2024 03:56:23' prior: 58765260!with: object do: block	| index |	referencePolicy = #ignore		ifTrue: [ ^ block value ].	(index := objects at: object ifAbsent: [ nil ]) notNil		ifTrue: [			referencePolicy = #error				ifTrue: [ ^ self error: 'shared reference detected' ].			self writeReference: index ]		ifFalse: [			index := objects size + 1.			objects at: object put: index.			block value ]! !!Object methodsFor: '*STON-Core' stamp: '4/18/2024 03:56:23'!stonEncoded	"Encode me into an STON textual representation"	^ STON toStringPretty: self! !!Date class methodsFor: '*STON-Core' stamp: '4/18/2024 03:56:23' prior: 12996424!fromSton: stonReader	"Read a ISO YYYY-MM-DD format.	Since my current implementation is time zone offset sensitive, the offset has to be taken into account.	A missing offset results in the local timezone offset to be used"	| readStream date |	readStream := stonReader parseListSingleton readStream.	date := self readFrom: readStream.	readStream atEnd		ifFalse: [ | offset |			offset := DateAndTime readTimezoneOffsetFrom: readStream.			offset = date offset				ifFalse: [ date start: (date start translateTo: offset) ] ].	^ date! !!String methodsFor: '*STON-Core' stamp: '4/18/2024 03:56:23'!stonDecoded	"Decode me as an STON textual representation"		^ STON fromString: self! !"STON-Core"!!STONWriteReadTest methodsFor: 'tests' stamp: '4/18/2024 03:56:23' prior: 58701782!testUUIDs	| uuids |	uuids := STON listClass withAll: {		UUID new.		UUID new.		UUID nilUUID }.	self serializeAndMaterialize: uuids! !!STONReaderTest methodsFor: 'tests' stamp: '4/18/2024 03:56:23' prior: 58623038!testFloat	self assert: ((self materialize: '1.5') closeTo: 1.5).	self assert: ((self materialize: '-1.5') closeTo: -1.5).	self assert: (self materialize: '0.0') isZero.	self assert: (Float pi closeTo: (self materialize: '3.14159') precision: 0.00001).	self assert: (1/3 closeTo: (self materialize: '0.333333')).	self assert: (self materialize: '1.0e100') equals: 1.0e100.	self assert: (self materialize: '1.0e-100') equals: 1.0e-100.	self assert: (self materialize: '-1.0e-100') equals: -1.0e-100.	self assert: (self materialize: 'Float[#nan]') isNaN.	self assert: (self materialize: 'Float[#infinity]') equals: Float infinity.	self assert: (self materialize: 'Float[#negativeInfinity]') equals: Float negativeInfinity.	self assert: (Float pi closeTo: (self materialize: 'Float[3.14159]') precision: 0.00001)! !STONAlternativeRepresentationTestObject removeSelector: #initialize!"STON-Tests"!Object << #RESTServer	layout: FixedLayout;	traits: {};	slots: {};	sharedVariables: {};	sharedPools: {};	tag: '' ;	package: 'Guild-Backend'!Smalltalk globals removeClassNamed: #AnObsoleteRESTServer!Object << #TeaPot	layout: FixedLayout;	traits: {};	slots: {};	sharedVariables: {};	sharedPools: {};	tag: '' ;	package: 'Guild-Backend'!----SNAPSHOT----2025-03-01T22:59:59.853343-05:00 Pharo 12.0 - 64bit (stable).1.image priorSource: 202577!----SNAPSHOT----2025-03-01T22:59:59.857101-05:00 Pharo 12.0 - 64bit (stable).1.image priorSource: 433064!!BaselineOfTeapot methodsFor: 'baselines' stamp: '3/1/2025 23:01'!baseline: spec	<baseline>	spec for: #common do: [		self setUpDependencies: spec.		spec			package: 'Teapot-Core' with: [ spec requires: #( 'NeoJSON' ) ];			package: 'Teapot-Tools' with: [ spec requires: 'Teapot-Core' ].		spec			for: #( #'pharo7.x' #'pharo8.x' #'pharo9.x' )			do: [ spec package: 'Teapot-Tests' with: [ spec requires: 'Teapot-Core' ] ].		spec			for: #( #'pharo10.x' #'pharo11.x' #'pharo12.x' )			do: [ spec package: 'Teapot-Tests' with: [ spec requires: #( 'Teapot-Core' 'Zinc-Zodiac' ) ] ].		spec			group: 'Tests' with: #( 'Teapot-Tests' );			group: 'Tools' with: #( 'Teapot-Tools' );			group: 'Deployment' with: #( 'Teapot-Core' );			group: 'Development' with: #( 'Tests' 'Tools' );			group: 'default' with: 'Development'		]! !!BaselineOfTeapot methodsFor: 'baselines' stamp: '3/1/2025 23:01'!setUpDependencies: spec	spec		baseline: 'NeoJSON' with: [			spec				repository: 'github://svenvc/NeoJSON';				loads: #( 'core' )			];		baseline: 'ZincHTTPComponents' with: [ spec repository: 'github://svenvc/zinc' ];		project: 'Zinc-Zodiac' copyFrom: 'ZincHTTPComponents' with: [ spec loads: 'Zinc-Zodiac-Core' ]! !"BaselineOfTeapot"!!TeaNoSuchParam commentStamp: '' prior: 0!This exception indicates that the given parameter was not found in the TeaRequest.!!TeaAbort commentStamp: '' prior: 0!I'm an exception that immediately stops a request within a filter or route.!!IsObject commentStamp: '' prior: 0!I'm the base class of the type constraints. I match to any object. My subclasses can restict the type of placeholders.Example:Teapot on	GET: '/user/<id:IsInteger>' -> [:req | users findById: (req at: #id)];	start.This route matches to the '/users/12' but does not match to '/users/foobar'. In case of matching, the the path paramter "id" will be converted to an integer.You can extend the built in type constraints with your own constraints, by implementing the "placeholder type constraint" protocol. Then you can use the class name in the URL.!!IsInteger commentStamp: '' prior: 0!I'm a type constraint that matches to positive or negative integers.!!IsNumber commentStamp: '' prior: 0!I'm a type constraint that matches to positive or negative floats or integers.!!IsUUID commentStamp: '' prior: 0!I'm a type constraint that matches to an UUID.!!Send commentStamp: '' prior: 0!I can send messages to objects on a http requests. The selector of the message can take maximum 2 arguments ( TeaRequest and TeaResponse).Example:Teapot on	GET: '/hi' -> (Send message: #greet to: controller);	start.	!!TeaErrorHandler commentStamp: '' prior: 0!An error handler handles Exceptions signaled by the Routes or before actions.!!TeaFilter commentStamp: '' prior: 0!After and Before filters!!TeaAfterFilter commentStamp: '' prior: 0!An after filter is evaluated after each (matching) request. This filter has access to the response object generated by the matching route. The response can be modified from the filter, e.g. addition headers can be added.!!TeaBeforeFilter commentStamp: '' prior: 0!A before filter is evaluated before (matching) each request. This filter has access to the request object. For example, a before filter can be used to validate session attributes for authentication.!!TeaGlobUrlSegment commentStamp: '' prior: 0!My subclasses form the elements of TeaGlobUrlPatterns!!TeaLiteral commentStamp: '' prior: 0!A literal url pattern segment that matches to a string.!!TeaLiteralStop commentStamp: '' prior: 0!I'm a placeholder at the last position.!!TeaPlaceholder commentStamp: '' prior: 0!I'm a placeholder with a key. My content is substituted with a value.!!TeaPlaceholderStop commentStamp: '' prior: 0!I'm a placeholder at the last position.!!TeaWildcard commentStamp: '' prior: 0!A wildcard url pattern segment that matches to anything.!!TeaWildcardStop commentStamp: '' prior: 0!I'm a Wildcard at the last position.!!TeaMethodMatcher commentStamp: '' prior: 0!I can be matched against an HTTP method. I will return either true or false.!!TeaNotFoundHandler commentStamp: '' prior: 0!I decides what response to return when there were not matching routes (and no static path) for the incoming request. By default I just return 404.!!Tea405AwareNotFoundHandler commentStamp: '' prior: 0!I'm a smarter not found handler that returns 405 instead of 404 when the url part of some routes matched but the HTTP method didn't.!!TeaOutput commentStamp: '' prior: 0!I have various response transformer methods on my class side, that can be used as follows:Teapot on	GET: '/books' -> books; output: #json;	start.	Some of the transformers require optional dependencies, like Neo-JSON, STON, or Mustache.!!TeaPadding commentStamp: '' prior: 0!An url is padded by me, if its size is to short. I don't match to any literal URL, so it's like I'm not there.!!TeaRequest commentStamp: '' prior: 0!I extend the ZnRequest with addition methods for convenience.!!TeaRequestMatcher commentStamp: '' prior: 0!I can be matched against a ZnRequest. I check the http method and url of the request. !!TeaResponse commentStamp: '' prior: 0!A TeaResponse represents an HTTP response returned by a Route. The ZnResponse is generated from the TeaResponse by the given response transformer.!!TeaRoute commentStamp: '' prior: 0!A route handles http requests if it matches to the route. I have four major parts.- A handler that can be a block, a value or a message send.- An url pattern that can be matched against actual urls.- An http method that can be matched against the actual http method.- A response transformer for creating ZnResponse from the object returned by the handler.!!TeaRouter commentStamp: '' prior: 0!A zn delegate baseclass!!TeaCompositeRouter commentStamp: '' prior: 0!I'm a composite zn delegate, built from other zn delegates. I forward the request to the first delegate that returns other than 404 as response. Errors are handled with the help of the registered error handlers.!!TeaDynamicRouter commentStamp: '' prior: 0!I'm a ZnDelegate. I serve dynamically generated contents. The request is handled by the first route object, that returns other than 404 as response.!!TeaStaticRouter commentStamp: '' prior: 0!I'm a ZnDelegate based on ZnStaticFileServerDelegate. I serve static content from a file system directory.!!TeaUrlPattern commentStamp: '' prior: 0!An URL pattern can be matched agains actual urls. The pattern may collect named parameters from the URL in case of match.!!TeaGlobUrlPattern commentStamp: '' prior: 0!An UrlPattern is made from segments. I can be matched against an actual URL. '*' and <named-parameters> can be used inside the pattern.I can parse the pattern from a string by saying:	self parseString: '/foo/*/<id>/bar'Which will create a pattern that matches to an URL like this: 	/foo/xyz/12/bar!!TeaRxUrlPattern commentStamp: '' prior: 0!I'm an URL pattern that uses a regular expression internally. I collect subexpressions in case of matching.!!TeaUrlPatternSet commentStamp: '' prior: 0!I match to the given url if any of my elements match.E.g.Teapot on	GET: {'/a'. '/b'} -> 'ab';	start.		Both ZnEasy get: '/a' and ZnEasy get: '/b' returns 'ab'!!Teapot commentStamp: '' prior: 0!I'm the Teapot server on top of ZnServer. I can handle URL routing as follows:Teapot on      GET: '/hi' -> 'Hello World!!';      GET: '/a/*/b' -> (Send message: #ab: to: controller);      GET: '/users' -> [ users ]; output: #json	      GET: '/user/<id>' -> [ :req | (req at: #id) ]; output: #ston;      PUT: '/books/<id>' -> [ :req | | book |	  book := Book author: (req at: #author) title: (req at: #title).        books at: (req at: #id) put: book ]; 	  output: #ston;      start.For more configuration option see the Teapot class>>configure method.!!ZnResponse methodsFor: '*Teapot-Core' stamp: '3/1/2025 23:01'!teaTransform: aResponseTransformer request: aTeaRequest	^ self! !!RxMatcher methodsFor: '*Teapot-Core' stamp: '3/1/2025 23:01'!asTeaUrlPattern	^ TeaRxUrlPattern fromRxMatcher: self! !!String methodsFor: '*Teapot-Core' stamp: '3/1/2025 23:01'!asTeaUrlPattern	^ TeaGlobUrlPattern parseString: self! !!TeaNoSuchParam class methodsFor: 'signaling' stamp: '3/1/2025 23:01'!signalWithParam: aSymbol	(self new setParam: aSymbol) signal: 'Param ', aSymbol printString, ' not found'! !!TeaNoSuchParam methodsFor: 'accessing' stamp: '3/1/2025 23:01'!param	^ param! !!TeaNoSuchParam methodsFor: 'initialization' stamp: '3/1/2025 23:01'!setParam: aSymbol	param := aSymbol.	^ self! !!TeaAbort class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!response: aZnResponse	^ self new setResponse: aZnResponse! !!TeaAbort methodsFor: 'converting' stamp: '3/1/2025 23:01'!response	^ response! !!TeaAbort methodsFor: 'initialization' stamp: '3/1/2025 23:01'!setResponse: aZnResponse	response := aZnResponse.	^ self! !!BlockClosure methodsFor: '*Teapot-Core' stamp: '3/1/2025 23:01'!teaEvalActionOnException: anException request: aTeaRequest	^ self cull: anException cull: aTeaRequest! !!BlockClosure methodsFor: '*Teapot-Core' stamp: '3/1/2025 23:01'!teaEvalActionOnRequest: aTeaRequest	^ self cull: aTeaRequest! !!BlockClosure methodsFor: '*Teapot-Core' stamp: '3/1/2025 23:01'!teaEvalActionOnRequest: aTeaRequest response: aZnResponse	^ self cull: aTeaRequest cull: aZnResponse! !!IsInteger class methodsFor: 'type constraint' stamp: '3/1/2025 23:01'!matchesTo: aString	^ '-?\d+' asRegex matches: aString! !!IsInteger class methodsFor: 'type constraint' stamp: '3/1/2025 23:01'!parseString: aString	^ aString asInteger! !!IsNumber class methodsFor: 'type constraint' stamp: '3/1/2025 23:01'!matchesTo: aString	Number readFrom: aString ifFail: [ ^false ].	^ true! !!IsNumber class methodsFor: 'type constraint' stamp: '3/1/2025 23:01'!parseString: aString	^ aString asNumber! !!IsObject class methodsFor: 'type constraint' stamp: '3/1/2025 23:01'!matchesTo: aString	^ true! !!IsObject class methodsFor: 'type constraint' stamp: '3/1/2025 23:01'!parseString: aString	^ aString! !!IsUUID class methodsFor: 'type constraint' stamp: '3/1/2025 23:01'!matchesTo: aString	^ '[0-9a-f]{8}\-[0-9a-f]{4}\-[0-9a-f]{4}\-[0-9a-f]{4}\-[0-9a-f]{12}' asRegex matches: aString! !!IsUUID class methodsFor: 'type constraint' stamp: '3/1/2025 23:01'!parseString: aString	^ UUID fromString: aString! !!Object methodsFor: '*Teapot-Core' stamp: '3/1/2025 23:01'!teaEvalActionOnException: anException request: aTeaRequest	^ self! !!Object methodsFor: '*Teapot-Core' stamp: '3/1/2025 23:01'!teaEvalActionOnRequest: aTeaRequest	^ self! !!Object methodsFor: '*Teapot-Core' stamp: '3/1/2025 23:01'!teaTransform: aResponseTransformer request: aTeaRequest	^ aResponseTransformer cull: (TeaResponse ok body: self) cull: aTeaRequest! !!Send class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!message: aSymbol to: anObject	^ self new 		setSelector: aSymbol 		receiver: anObject! !!Send methodsFor: 'printing' stamp: '3/1/2025 23:01'!printOn: aStream	aStream 		nextPutAll: '(Send message: ';		nextPutAll: selector printString;		nextPutAll: ' to: '.	receiver printOn: aStream.	aStream nextPut: $)! !!Send methodsFor: 'initialization' stamp: '3/1/2025 23:01'!setSelector: aSymbol receiver: anObject	selector := aSymbol.	receiver := anObject.	^ self	! !!Send methodsFor: 'tea action' stamp: '3/1/2025 23:01'!teaEvalActionOnException: anException request: aTeaRequest	^ receiver 		perform: selector 		withEnoughArguments: { anException. aTeaRequest }	! !!Send methodsFor: 'tea action' stamp: '3/1/2025 23:01'!teaEvalActionOnRequest: aTeaRequest	^ receiver 		perform: selector 		withEnoughArguments: { aTeaRequest }	! !!Send methodsFor: 'tea action' stamp: '3/1/2025 23:01'!teaEvalActionOnRequest: aTeaRequest response: aZnResponse	^ receiver 		perform: selector 		withEnoughArguments: { aTeaRequest. aZnResponse }	! !!TeaErrorHandler class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!for: anExceptionSet action: aTeaAction responseTransformer: aResponseTransformer	^ self new 		setExceptions: anExceptionSet 		action: aTeaAction 		responseTransformer: aResponseTransformer! !!TeaErrorHandler methodsFor: 'error handler' stamp: '3/1/2025 23:01'!canHandleError: anException	^ exceptions handles: anException! !!TeaErrorHandler methodsFor: 'error handler' stamp: '3/1/2025 23:01'!handleError: anException request: aTeaRequest	| result |	^ (self canHandleError: anException)		ifTrue:			[ result := action teaEvalActionOnException: anException request: aTeaRequest.			result teaTransform: responseTransformer request: aTeaRequest ]		ifFalse: 			[ self error: 'Cannot handle ', anException printString ]! !!TeaErrorHandler methodsFor: 'error handler' stamp: '3/1/2025 23:01'!responseTransformer: aResponseTransformer 	responseTransformer := aResponseTransformer! !!TeaErrorHandler methodsFor: 'initialization' stamp: '3/1/2025 23:01'!setExceptions: anExceptionSet action: aTeaAction responseTransformer: aResponseTransformer	exceptions := anExceptionSet.	action := aTeaAction.	responseTransformer := aResponseTransformer.	^ self! !!TeaAfterFilter methodsFor: 'response handling' stamp: '3/1/2025 23:01'!handleRequest: aZnRequest response: aZnResponse	requestMatcher		matchRequest: aZnRequest		ifMatch: [ :aTeaRequest | action teaEvalActionOnRequest: aTeaRequest response: aZnResponse ]		ifNoMatch: [ ]! !!TeaBeforeFilter methodsFor: 'request handling' stamp: '3/1/2025 23:01'!handleRequest: aZnRequest	requestMatcher		matchRequest: aZnRequest		ifMatch: [ :aTeaRequest | action teaEvalActionOnRequest: aTeaRequest ]		ifNoMatch: [ ]! !!TeaFilter class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!urlPattern: anUrlPattern action: aTeaAction	^ self new 		setMatcher: (TeaRequestMatcher method: TeaMethodMatcher any url: anUrlPattern)		action: aTeaAction! !!TeaFilter methodsFor: 'acccessing' stamp: '3/1/2025 23:01'!action	^action! !!TeaFilter methodsFor: 'acccessing' stamp: '3/1/2025 23:01'!requestMatcher	^requestMatcher! !!TeaFilter methodsFor: 'initialization' stamp: '3/1/2025 23:01'!setMatcher: aTeaRequestMatcher action: aTeaAction	requestMatcher := aTeaRequestMatcher.	action := aTeaAction.	^ self! !!TeaFilter methodsFor: 'acccessing' stamp: '3/1/2025 23:01'!whenClause: aBlockClosure 	requestMatcher whenClause: aBlockClosure ! !!TeaGlobUrlSegment methodsFor: 'url pattern segment' stamp: '3/1/2025 23:01'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	self subclassResponsibility! !!TeaLiteral class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!fromString: aString atLast: aBoolean	| class |	class := aBoolean ifTrue: [ TeaLiteralStop ] ifFalse: [ TeaLiteral ].	^ class new setLiteral: aString! !!TeaLiteral methodsFor: 'url pattern segment' stamp: '3/1/2025 23:01'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	^ literal = urlSegments first and: 		[ adjacentPatterns first 			matches: urlSegments allButFirst 			rest: adjacentPatterns allButFirst 			placeholders: aDictionary ]! !!TeaLiteral methodsFor: 'printing' stamp: '3/1/2025 23:01'!printOn: aStream	aStream nextPutAll: literal.	! !!TeaLiteral methodsFor: 'initialization' stamp: '3/1/2025 23:01'!setLiteral: aString	literal := aString.	^ self! !!TeaLiteralStop methodsFor: 'url pattern segment' stamp: '3/1/2025 23:01'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	^ urlSegments size = 1 and: [ literal = urlSegments first ]! !!TeaPlaceholder class methodsFor: 'private' stamp: '3/1/2025 23:01'!createPlaceholderName: key typeConstraint: aTypeConstraint atLast: aBoolean	| class |	class := aBoolean		ifTrue: [ TeaPlaceholderStop ]		ifFalse: [ TeaPlaceholder ].	^ class new 		setPlaceholderName: key 		typeConstraint: aTypeConstraint! !!TeaPlaceholder class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!fromString: aString atLast: aBoolean	| spec typeConstraint key |	self mustBeValidPlaceholder: aString.	spec := aString allButFirst allButLast findTokens: ':'.	key := spec first.	typeConstraint := spec at: 2 ifAbsent: #IsObject.	^ self 		createPlaceholderName: key 		typeConstraint: (Smalltalk at: typeConstraint asSymbol)		atLast: aBoolean! !!TeaPlaceholder class methodsFor: 'private' stamp: '3/1/2025 23:01'!mustBeValidPlaceholder: aString	((aString beginsWith: '<') and: [ aString endsWith: '>' ])		ifFalse: [ self error: 'Invalid placeholder name: ', aString ]! !!TeaPlaceholder methodsFor: 'url pattern segment' stamp: '3/1/2025 23:01'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	(urlSegments first = TeaPadding or: [ (typeConstraint matchesTo: urlSegments first) not]) 		ifTrue: [ ^ false ].			aDictionary 		at: placeholderName 		put: (typeConstraint parseString: urlSegments first).					^ adjacentPatterns first 		matches: urlSegments allButFirst 		rest: adjacentPatterns allButFirst 		placeholders: aDictionary! !!TeaPlaceholder methodsFor: 'printing' stamp: '3/1/2025 23:01'!printOn: aStream	aStream 		nextPut: $<;		nextPutAll: placeholderName;		nextPut: $>! !!TeaPlaceholder methodsFor: 'initialization' stamp: '3/1/2025 23:01'!setPlaceholderName: aString typeConstraint: aTypeConstraint	placeholderName := aString asSymbol.	typeConstraint := aTypeConstraint.	^ self! !!TeaPlaceholderStop methodsFor: 'url pattern segment' stamp: '3/1/2025 23:01'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	| match |	match := urlSegments size = 1 		and: [ urlSegments first ~= TeaPadding 		and: [ (typeConstraint matchesTo: urlSegments first) ] ].	match ifTrue:		 [ aDictionary			at: placeholderName 			put: (typeConstraint parseString: urlSegments first) ].	^ match! !!TeaWildcard class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!atLast: aBoolean	^ aBoolean		ifTrue: [ TeaWildcardStop new ]		ifFalse: [ TeaWildcard new ]! !!TeaWildcard methodsFor: 'url pattern segment' stamp: '3/1/2025 23:01'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	^ adjacentPatterns first 		matches: urlSegments allButFirst 		rest: adjacentPatterns allButFirst 		placeholders: aDictionary! !!TeaWildcard methodsFor: 'printing' stamp: '3/1/2025 23:01'!printOn: aStream	aStream nextPut: $*! !!TeaWildcardStop methodsFor: 'url pattern segment' stamp: '3/1/2025 23:01'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	^ true! !!TeaMethodMatcher class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!any	^ self new 		setMatcherBlock: [ :anyMethod | true ] 		name: 'ANY'! !!TeaMethodMatcher class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!exactly: aSymbol	^ self new 		setMatcherBlock: [ :actual | actual = aSymbol ] 		name: aSymbol asString! !!TeaMethodMatcher methodsFor: 'converting' stamp: '3/1/2025 23:01'!asString	^ name! !!TeaMethodMatcher methodsFor: 'http method matcher' stamp: '3/1/2025 23:01'!matchesHttpMethod: aSymbol	^ matcherBlock value: aSymbol! !!TeaMethodMatcher methodsFor: 'printing' stamp: '3/1/2025 23:01'!printOn: aStream	aStream 		nextPutAll: name;		nextPut: $:! !!TeaMethodMatcher methodsFor: 'initialization' stamp: '3/1/2025 23:01'!setMatcherBlock: aBlockClosure name: aString	matcherBlock := aBlockClosure.	name := aString.	^ self! !!Tea405AwareNotFoundHandler methodsFor: 'private' stamp: '3/1/2025 23:01'!populateAllowedHeaderOf: response withAllowedRoutes: allowedRoutes	allowedRoutes do: [ :route | 		response headers 			at: 'Allow' 			put: route methodMatcher asString			ifPresentMerge: [ :old :new | old, ', ', new ] ].	^ response! !!Tea405AwareNotFoundHandler methodsFor: 'not found handler' stamp: '3/1/2025 23:01'!requestNotFound: aZnRequest	| allowedRoutes |	allowedRoutes := routes		select: [ :each | each canHandleUrl: aZnRequest url ].	^ allowedRoutes		ifEmpty: [ ZnResponse notFound: aZnRequest url ]		ifNotEmpty: [			self				populateAllowedHeaderOf: (ZnResponse methodNotAllowed: aZnRequest)				withAllowedRoutes: allowedRoutes ]! !!TeaNotFoundHandler methodsFor: 'initialization' stamp: '3/1/2025 23:01'!initialize	super initialize.	routes := OrderedCollection new.! !!TeaNotFoundHandler methodsFor: 'initialization' stamp: '3/1/2025 23:01'!initializeRoutes: aTeaRouteCollection	routes := aTeaRouteCollection.	^ self! !!TeaNotFoundHandler methodsFor: 'not found handler' stamp: '3/1/2025 23:01'!requestNotFound: aZnRequest	^ ZnResponse notFound: aZnRequest url! !!TeaOutput class methodsFor: 'response transformers' stamp: '3/1/2025 23:01'!html	^ self stringWithContentType: ZnMimeType textHtml! !!TeaOutput class methodsFor: 'response transformers' stamp: '3/1/2025 23:01'!json	^ [ :aTeaResponse | | entity |		entity := ZnStringEntity 			with: ((self optionalClass: #NeoJSONWriter) toString: aTeaResponse body) 			type: (ZnMimeType applicationJson charSet: aTeaResponse charSet; yourself).		self 			znEntity: entity			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers' stamp: '3/1/2025 23:01'!mustache: templateStringOrStream contentType: contentType	^ [ :aTeaResponse | | model object entity |		object := aTeaResponse body.		model := (object respondsTo: #asDictionary) ifTrue: [ object asDictionary ] ifFalse: [ object ].				entity := (ZnStringEntity 			with: (((self optionalClass: #MustacheTemplate) on: templateStringOrStream) value: model) 			type: contentType).		self 			znEntity: entity			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers' stamp: '3/1/2025 23:01'!mustacheHtml: templateString 	^ self mustache: templateString contentType: ZnMimeType textHtml.! !!TeaOutput class methodsFor: 'private' stamp: '3/1/2025 23:01'!optionalClass: aSymbol	[ ^ Smalltalk at: aSymbol ]		on: KeyNotFound		do: [ self error: 'An optional dependency ', aSymbol, ' was not found. Please load it first.' ]! !!TeaOutput class methodsFor: 'response transformers' stamp: '3/1/2025 23:01'!ston	^ [ :aTeaResponse | | entity |		entity := ZnStringEntity 			with: ((self optionalClass: #STON) toString: aTeaResponse body) 			type: (ZnMimeType textPlain charSet: aTeaResponse charSet; yourself).		self 			znEntity: entity			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers' stamp: '3/1/2025 23:01'!stream	^ self stream: ZnMimeType applicationOctetStream ! !!TeaOutput class methodsFor: 'response transformers' stamp: '3/1/2025 23:01'!stream: aZnMimeType	^ [ :aTeaResponse | | entity |		entity := ZnStreamingEntity 			readFrom: aTeaResponse body			usingType: aZnMimeType			andLength: aTeaResponse body size.		self 			znEntity: entity			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers' stamp: '3/1/2025 23:01'!stringWithContentType: aZnMimeType 	^ [ :aTeaResponse | | entity |		entity := ZnStringEntity new			contentType: (aZnMimeType charSet: aTeaResponse charSet; yourself);			string: aTeaResponse body asString;			yourself.		self 			znEntity: entity 			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers' stamp: '3/1/2025 23:01'!text	^ self stringWithContentType: ZnMimeType textPlain! !!TeaOutput class methodsFor: 'private' stamp: '3/1/2025 23:01'!znEntity: aZnEntity code: anInteger headers: aDictionary	| headers |	headers := ZnHeaders defaultResponseHeaders.	headers addAll: aDictionary.	^ ZnResponse new		statusLine: (ZnStatusLine code: anInteger);		headers: headers;		entity: aZnEntity;		yourself! !!TeaRequest class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!fromZnRequest: aZnRequest	^ self fromZnRequest: aZnRequest pathParams: Dictionary new! !!TeaRequest class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!fromZnRequest: aZnRequest pathParams: aDictionary	^ self new setZnRequest: aZnRequest pathParams: aDictionary! !!TeaRequest methodsFor: 'aborting' stamp: '3/1/2025 23:01'!abort: response	(TeaAbort response: response) signal! !!TeaRequest methodsFor: 'acccessing - params' stamp: '3/1/2025 23:01'!at: aSymbol	^ self 		at: aSymbol 		ifAbsent: [ TeaNoSuchParam signalWithParam: aSymbol ]! !!TeaRequest methodsFor: 'acccessing - params' stamp: '3/1/2025 23:01'!at: aSymbol ifAbsent: aBlock	"Gets the value of a path parameter, query parameter for form parameter.		E.g. /foo/<path-param>/bar		E.g. /foo?queryParam=value"	^ pathParams at: aSymbol ifAbsent: [ self queryOrFormParam: aSymbol ifAbsent: aBlock	"XXX do something better" ]! !!TeaRequest methodsFor: 'reflective operations' stamp: '3/1/2025 23:01'!doesNotUnderstand: aMessage	^ aMessage sendTo: znRequest! !!TeaRequest methodsFor: 'private' stamp: '3/1/2025 23:01'!formParam: aSymbol ifAbsent: aBlock	^ (znRequest entity isKindOf: ZnApplicationFormUrlEncodedEntity) "XXX do something better" 		ifTrue: [ znRequest entity at: aSymbol ifAbsent: aBlock ]		ifFalse: aBlock! !!TeaRequest methodsFor: 'private' stamp: '3/1/2025 23:01'!queryOrFormParam: aSymbol ifAbsent: aBlock	^ znRequest uri 		queryAt: aSymbol 		ifAbsent: [ self formParam: aSymbol ifAbsent: aBlock ]! !!TeaRequest methodsFor: 'initialization' stamp: '3/1/2025 23:01'!setZnRequest: aZnRequest pathParams: aDictionary	znRequest := aZnRequest.	pathParams := aDictionary.	^ self! !!TeaRequestMatcher class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!method: aMethodMatcher url: anUrlPattern	^ self new setPattern: anUrlPattern method: aMethodMatcher! !!TeaRequestMatcher methodsFor: 'request matcher' stamp: '3/1/2025 23:01'!matchRequest: aZnRequest ifMatch: matchBlock ifNoMatch: noMatchBlock	| placeholders matches |	(methodMatcher matchesHttpMethod: aZnRequest method) ifFalse: [ ^ noMatchBlock value ].	placeholders := Dictionary new.	matches := (urlPattern matchesUrl: aZnRequest url placeholders: placeholders) 		and: [ whenClause cull: (TeaRequest fromZnRequest: aZnRequest pathParams: placeholders) ].	^ matches 		ifTrue: [ matchBlock value: (TeaRequest fromZnRequest: aZnRequest pathParams: placeholders) ]		ifFalse: noMatchBlock! !!TeaRequestMatcher methodsFor: 'request matcher' stamp: '3/1/2025 23:01'!matchesUrl: aZnUrl	^ urlPattern matchesUrl: aZnUrl placeholders: Dictionary new! !!TeaRequestMatcher methodsFor: 'accessing' stamp: '3/1/2025 23:01'!methodMatcher	^ methodMatcher! !!TeaRequestMatcher methodsFor: 'printing' stamp: '3/1/2025 23:01'!printOn: aStream	methodMatcher printOn: aStream.	aStream space.	urlPattern printOn: aStream.! !!TeaRequestMatcher methodsFor: 'initialization' stamp: '3/1/2025 23:01'!setPattern: anUrlPattern method: aMethodMatcher	urlPattern := anUrlPattern.	methodMatcher := aMethodMatcher.	whenClause := [ :anyRequest | true ].	^ self! !!TeaRequestMatcher methodsFor: 'accessing' stamp: '3/1/2025 23:01'!whenClause: aBlockClosure 	whenClause := aBlockClosure! !!TeaResponse class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!badRequest	^ self code: ZnStatusLine badRequest code! !!TeaResponse class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!code: anInteger	^ self new code: anInteger! !!TeaResponse class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!created	^ self code: ZnStatusLine created code! !!TeaResponse class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!methodNotAllowed	^ self code: ZnStatusLine methodNotAllowed code ! !!TeaResponse class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!notFound	^ self code: ZnStatusLine notFound code ! !!TeaResponse class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!notModified	^ self code: ZnStatusLine notModified code! !!TeaResponse class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!ok	^ self code: ZnStatusLine ok code! !!TeaResponse class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!redirect	^ self code: ZnStatusLine redirect code! !!TeaResponse class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!serverError	^ self code: ZnStatusLine internalServerError code! !!TeaResponse class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!unauthorized	^ self code: ZnStatusLine unauthorized code! !!TeaResponse methodsFor: 'accessing' stamp: '3/1/2025 23:01'!body	^ body! !!TeaResponse methodsFor: 'accessing' stamp: '3/1/2025 23:01'!body: anObject	body := anObject.	^ self! !!TeaResponse methodsFor: 'accessing' stamp: '3/1/2025 23:01'!charSet	^ charSet! !!TeaResponse methodsFor: 'accessing' stamp: '3/1/2025 23:01'!charSet: aString	charSet := aString.	^ self! !!TeaResponse methodsFor: 'accessing' stamp: '3/1/2025 23:01'!code	^ code! !!TeaResponse methodsFor: 'accessing' stamp: '3/1/2025 23:01'!code: anInteger	code := anInteger.	^ self! !!TeaResponse methodsFor: 'accessing' stamp: '3/1/2025 23:01'!headerName: nameString value: valueString	headers at: nameString put: valueString.	^ self! !!TeaResponse methodsFor: 'accessing' stamp: '3/1/2025 23:01'!headers	^ headers! !!TeaResponse methodsFor: 'accessing' stamp: '3/1/2025 23:01'!headers: aDictionary	headers := aDictionary asDictionary.	^ self! !!TeaResponse methodsFor: 'initialization' stamp: '3/1/2025 23:01'!initialize	super initialize.	headers := Dictionary new.	body := String crlf.	code := ZnStatusLine ok code.	charSet := 'utf-8'.! !!TeaResponse methodsFor: 'accessing' stamp: '3/1/2025 23:01'!location: url	self headerName: 'Location' value: url asString.	^ self! !!TeaResponse methodsFor: 'response transforming' stamp: '3/1/2025 23:01'!teaTransform: aResponseTransformer request: aTeaRequest	^ aResponseTransformer cull: self cull: aTeaRequest! !!TeaRoute class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!matcher: aTeaRequestMatcher action: aTeaAction transformer: aResponseTransformer port: portNumber	^ self new 		setMatcher: aTeaRequestMatcher		action: aTeaAction		transformer: aResponseTransformer		port: portNumber "XXX only used by teapsoon inspector"! !!TeaRoute methodsFor: 'request handling' stamp: '3/1/2025 23:01'!canHandleUrl: aZnUrl	"only check the URL not without checking HTTP Method or when clause"	^ requestMatcher matchesUrl: aZnUrl! !!TeaRoute methodsFor: 'request handling' stamp: '3/1/2025 23:01'!handleRequest: aZnRequest ifUnhandled: aBlock	^ requestMatcher		matchRequest: aZnRequest		ifMatch: [ :aTeaRequest |			(action teaEvalActionOnRequest: aTeaRequest)				teaTransform: responseTransformer				request: aTeaRequest ]		ifNoMatch: aBlock! !!TeaRoute methodsFor: 'accessing' stamp: '3/1/2025 23:01'!methodMatcher 	^ requestMatcher methodMatcher ! !!TeaRoute methodsFor: 'printing' stamp: '3/1/2025 23:01'!printOn: aStream	requestMatcher printOn: aStream.	aStream nextPutAll: ' -> '.	action printOn: aStream.! !!TeaRoute methodsFor: 'accessing' stamp: '3/1/2025 23:01'!responseTransformer: aBlock	responseTransformer := aBlock! !!TeaRoute methodsFor: 'initialization' stamp: '3/1/2025 23:01'!setMatcher: aTeaRequestMatcher action: aTeaAction transformer: aResponseTransformer port: portNumber	requestMatcher := aTeaRequestMatcher.	action := aTeaAction.	responseTransformer := aResponseTransformer.	port := portNumber.	^ self! !!TeaRoute methodsFor: 'accessing' stamp: '3/1/2025 23:01'!whenClause: aBlockClosure 	requestMatcher whenClause: aBlockClosure! !!TeaCompositeRouter class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!routers: teaRouterCollection	^ self new setRouters: teaRouterCollection! !!TeaCompositeRouter methodsFor: 'filters' stamp: '3/1/2025 23:01'!addAfterFilter: aTeaFilter	^ afterFilters add: aTeaFilter! !!TeaCompositeRouter methodsFor: 'filters' stamp: '3/1/2025 23:01'!addBeforeFilter: aTeaFilter	^ beforeFilters add: aTeaFilter! !!TeaCompositeRouter methodsFor: 'error handing' stamp: '3/1/2025 23:01'!addErrorHandler: aTeaErrorHandler	^ errorhandlers add: aTeaErrorHandler! !!TeaCompositeRouter methodsFor: 'accessing' stamp: '3/1/2025 23:01'!afterFilters	^afterFilters ! !!TeaCompositeRouter methodsFor: 'accessing' stamp: '3/1/2025 23:01'!beforeFilters	^beforeFilters ! !!TeaCompositeRouter methodsFor: 'private' stamp: '3/1/2025 23:01'!evaluateAfterFilters: aZnRequest response: aZnResponse	afterFilters do: [ :each | each handleRequest: aZnRequest response: aZnResponse ]! !!TeaCompositeRouter methodsFor: 'private' stamp: '3/1/2025 23:01'!evaluateBeforeFilters: aZnRequest	beforeFilters do: [ :each | each handleRequest: aZnRequest ]! !!TeaCompositeRouter methodsFor: 'private' stamp: '3/1/2025 23:01'!evaluateRouters: aZnRequest ifUnhandled: aBlock	routers do: [ :each | | response |		response := each handleRequest: aZnRequest ifUnhandled: nil.		response ifNotNil: [ ^ response ] ].	^ aBlock value! !!TeaCompositeRouter methodsFor: 'private' stamp: '3/1/2025 23:01'!exceptionOccurred: anException request: aZnRequest	| handler |	handler := errorhandlers 		detect: [ :each | each canHandleError: anException ]		ifNone: [ anException pass ].			^ handler handleError: anException request: (TeaRequest fromZnRequest: aZnRequest).	! !!TeaCompositeRouter methodsFor: 'zn delegate' stamp: '3/1/2025 23:01'!handleRequest: aZnRequest	^ self 		handleRequest: aZnRequest 		ifUnhandled: [ notFoundHandler requestNotFound: aZnRequest ] ! !!TeaCompositeRouter methodsFor: 'zn delegate' stamp: '3/1/2025 23:01'!handleRequest: aZnRequest ifUnhandled: aBlock	| response |	^ [ self evaluateBeforeFilters: aZnRequest.	     response := self evaluateRouters: aZnRequest ifUnhandled: aBlock.	     self evaluateAfterFilters: aZnRequest response: response.	     response		   ] on: Exception 	     do: [ :ex | self exceptionOccurred: ex request: aZnRequest ]! !!TeaCompositeRouter methodsFor: 'initialization' stamp: '3/1/2025 23:01'!initialize	super initialize.	errorhandlers := OrderedCollection new.	beforeFilters := OrderedCollection new.	afterFilters := OrderedCollection new.	notFoundHandler := TeaNotFoundHandler new.! !!TeaCompositeRouter methodsFor: 'error handing' stamp: '3/1/2025 23:01'!notFoundHandler: aTeaNotFoundHandler	notFoundHandler := aTeaNotFoundHandler! !!TeaCompositeRouter methodsFor: 'initialization' stamp: '3/1/2025 23:01'!setRouters: teaRouterCollection	routers := teaRouterCollection asArray.	^ self! !!TeaDynamicRouter methodsFor: 'route dispatcher' stamp: '3/1/2025 23:01'!addRoute: aRoute	^ routes add: aRoute! !!TeaDynamicRouter methodsFor: 'zn delegate' stamp: '3/1/2025 23:01'!handleRequest: aZnRequest ifUnhandled: aBlock	routes do: [ :each | | response |		response := each handleRequest: aZnRequest ifUnhandled: nil.		response ifNotNil: [ ^ response ] ].	^ aBlock value! !!TeaDynamicRouter methodsFor: 'initialization' stamp: '3/1/2025 23:01'!initialize	super initialize.	routes := OrderedCollection new.! !!TeaDynamicRouter methodsFor: 'accessing' stamp: '3/1/2025 23:01'!routes	^routes! !!TeaRouter methodsFor: 'router' stamp: '3/1/2025 23:01'!handleRequest: aZnRequest ifUnhandled: aBlock	self subclassResponsibility ! !!TeaStaticRouter methodsFor: 'zn delegate' stamp: '3/1/2025 23:01'!handleRequest: aZnRequest ifUnhandled: aBlock	| response |	delegate ifNil: [ ^ aBlock value ].	response := delegate handleRequest: aZnRequest.	^ response isNotFound ifTrue: aBlock ifFalse: [ response ]! !!TeaStaticRouter methodsFor: 'acccessing' stamp: '3/1/2025 23:01'!urlPrefix: urlPrefixString path: pathString	delegate ifNil: [ delegate := ZnStaticFileServerDelegate new ].	delegate		prefixFromString: urlPrefixString;		directory: pathString asFileReference.! !!TeaGlobUrlPattern class methodsFor: 'private' stamp: '3/1/2025 23:01'!createSegment: aString atLast: aBoolean	aString = '*' 		ifTrue: [ ^ TeaWildcard atLast: aBoolean ].	(aString beginsWith: '<')		ifTrue: [ ^ TeaPlaceholder fromString: aString atLast: aBoolean ].	^ TeaLiteral fromString: aString atLast: aBoolean! !!TeaGlobUrlPattern class methodsFor: 'private' stamp: '3/1/2025 23:01'!parseSegments: aString	| tokens |	tokens := aString findTokens: '/'.	^ tokens collectWithIndex: [ :each :idx | 		self createSegment: each atLast: idx = tokens size ]! !!TeaGlobUrlPattern class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!parseString: aString	^ self new setSegments: (self parseSegments: aString)! !!TeaGlobUrlPattern methodsFor: 'url matcher' stamp: '3/1/2025 23:01'!matchesUrl: anUrl placeholders: aDictionary	| urlSegments |	urlSegments := self padUrlSegments: anUrl with: TeaPadding size: segments size.	segments isEmpty		ifTrue: [ ^ urlSegments isEmpty ].	^ segments first 		matches: urlSegments 		rest: segments allButFirst 		placeholders: aDictionary! !!TeaGlobUrlPattern methodsFor: 'private' stamp: '3/1/2025 23:01'!padUrlSegments: anUrl with: padding size: anInteger	| urlSegments |	urlSegments := anUrl segments isEmptyOrNil 		ifTrue: [ OrderedCollection new ]		ifFalse: [ self trimTrailingSlash: anUrl segments ].	urlSegments size < segments size		ifTrue: [ urlSegments := urlSegments forceTo: anInteger paddingWith: padding ].	^ urlSegments! !!TeaGlobUrlPattern methodsFor: 'printing' stamp: '3/1/2025 23:01'!printOn: aStream	aStream nextPut: $'.	segments 		do: [ :each | each printOn: aStream ]		separatedBy: [ aStream nextPut: $/ ].	aStream nextPut: $'.! !!TeaGlobUrlPattern methodsFor: 'initialization' stamp: '3/1/2025 23:01'!setSegments: anArray	segments := anArray.	^ self! !!TeaGlobUrlPattern methodsFor: 'private' stamp: '3/1/2025 23:01'!trimTrailingSlash: urlSegments 	^ (urlSegments isNotEmpty and: [ urlSegments last asString = '/' ])		ifTrue: [ urlSegments allButLast ]		ifFalse: [ urlSegments ]! !!TeaRxUrlPattern class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!fromRxMatcher: aRxMatcher 	^ self new initializeRxMatcher: aRxMatcher ! !!TeaRxUrlPattern methodsFor: 'private' stamp: '3/1/2025 23:01'!hasMatched: aZnUrl	"XXX RxMatcher has state. Consider something better"	^ lock critical: [ (regexp matches: aZnUrl path) or: [ regexp matches: '/', aZnUrl path ] ]! !!TeaRxUrlPattern methodsFor: 'initialization' stamp: '3/1/2025 23:01'!initializeRxMatcher: aRxMatcher 	regexp := aRxMatcher.	lock := Mutex new.	^ self! !!TeaRxUrlPattern methodsFor: 'url matcher' stamp: '3/1/2025 23:01'!matchesUrl: aZnUrl placeholders: aDictionary 	| match |	match := self hasMatched: aZnUrl.	match ifTrue:		[ 2 to: regexp subexpressionCount do: [ :i | 			aDictionary at: i - 1put: (regexp subexpression: i) ] ].	^ match! !!TeaRxUrlPattern methodsFor: 'printing' stamp: '3/1/2025 23:01'!printOn: aStream	aStream nextPutAll: '<regexp>'.! !!TeaUrlPattern methodsFor: 'url matcher' stamp: '3/1/2025 23:01'!matchesUrl: anUrl placeholders: aDictionary	self subclassResponsibility ! !!TeaUrlPatternSet class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!fromCollection: aCollection 	^ self new setPatterns: (aCollection collect: #asTeaUrlPattern)! !!TeaUrlPatternSet methodsFor: 'url matcher' stamp: '3/1/2025 23:01'!matchesUrl: anUrl placeholders: aDictionary	^ patterns anySatisfy: [ :each | each matchesUrl: anUrl placeholders: aDictionary ]! !!TeaUrlPatternSet methodsFor: 'printing' stamp: '3/1/2025 23:01'!printOn: aStream	aStream nextPut: ${.	patterns 		do: [ :each | each printOn: aStream ]		separatedBy: [ aStream nextPut: $. ].	aStream nextPut: $}.! !!TeaUrlPatternSet methodsFor: 'initialization' stamp: '3/1/2025 23:01'!setPatterns: aCollection 	patterns := aCollection.	^ self! !!Teapot class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!configure: optionsAssociations	"Create a new Teapot instance with optional properties. 	 - Teapot properties: #defaultOutput, #znServer	 - ZnServer properties: See options protocol of ZnServer for specific usages.		Example: Teapot configure: { 		#defaultOutput -> #json. 		#bindAddress -> #[192 168 0 3].		#port -> 8080. 		#debugMode -> true.		#notFoundHandlerClass -> Tea405AwareNotFoundHandler.	}."		^ self new initializeOptions: optionsAssociations asDictionary! !!Teapot class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!on	"Create Teapot with default properties."		^ self configure: { }! !!Teapot class methodsFor: 'controlling' stamp: '3/1/2025 23:01'!stopAll	self allInstancesDo: #stop! !!Teapot methodsFor: 'url mapping' stamp: '3/1/2025 23:01'!CONNECT: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #CONNECT)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: '3/1/2025 23:01'!DELETE: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #DELETE)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: '3/1/2025 23:01'!GET: patternActionAssoc	self 		addRouteMethod: (TeaMethodMatcher exactly: #GET) 		pattern: patternActionAssoc key 		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: '3/1/2025 23:01'!HEAD: patternActionAssoc	self 		addRouteMethod: (TeaMethodMatcher exactly: #HEAD) 		pattern: patternActionAssoc key 		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: '3/1/2025 23:01'!OPTIONS: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #OPTIONS)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: '3/1/2025 23:01'!PATCH: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #PATCH)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: '3/1/2025 23:01'!POST: patternActionAssoc	self 		addRouteMethod: (TeaMethodMatcher exactly: #POST) 		pattern: patternActionAssoc key 		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: '3/1/2025 23:01'!PUT: patternActionAssoc	self 		addRouteMethod: (TeaMethodMatcher exactly: #PUT) 		pattern: patternActionAssoc key 		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: '3/1/2025 23:01'!TRACE: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #TRACE)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'private' stamp: '3/1/2025 23:01'!addRouteMethod: aTeaMethodMatcher pattern: pattern action: aTeaAction	current := dynamicRouter addRoute:		(TeaRoute			matcher: (TeaRequestMatcher method: aTeaMethodMatcher url: pattern asTeaUrlPattern)			action: aTeaAction			transformer: defaultOutput			port: server port)! !!Teapot methodsFor: 'filters' stamp: '3/1/2025 23:01'!after: patternActionAssoc	current := compositeRouter addAfterFilter:				(TeaAfterFilter 			urlPattern: patternActionAssoc key asTeaUrlPattern 			action: patternActionAssoc value)! !!Teapot methodsFor: 'url mapping' stamp: '3/1/2025 23:01'!any: patternActionAssoc	self		addRouteMethod: TeaMethodMatcher any		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'filters' stamp: '3/1/2025 23:01'!before: patternActionAssoc	current := compositeRouter addBeforeFilter:				(TeaBeforeFilter 			urlPattern: patternActionAssoc key asTeaUrlPattern 			action: patternActionAssoc value)! !!Teapot methodsFor: 'url mapping' stamp: '3/1/2025 23:01'!exception: anExceptionSetActionAssoc	current := compositeRouter addErrorHandler:		(TeaErrorHandler			for: anExceptionSetActionAssoc key			action: anExceptionSetActionAssoc value			responseTransformer: defaultOutput)! !!Teapot methodsFor: 'initialization' stamp: '3/1/2025 23:01'!initializeOptions: optionsDictionary	dynamicRouter := TeaDynamicRouter new.	staticRouter := TeaStaticRouter new.	compositeRouter := TeaCompositeRouter routers: {dynamicRouter. staticRouter}.		defaultOutput := self responseTransformer: (optionsDictionary at: #defaultOutput ifAbsent: #html).										self exception: TeaAbort -> [ :abort :req | abort response teaTransform: [ :same | same ] request: req].	server := optionsDictionary 		at: #znServer		ifAbsent: [ ZnServer defaultServerClass new ].	optionsDictionary 		at: #notFoundHandlerClass 		ifPresent: [:class | compositeRouter notFoundHandler: (class new initializeRoutes: dynamicRouter routes)].	server delegate: compositeRouter.		optionsDictionary keysAndValuesDo: [ :key :value | server optionAt: key put: value ].	^ self! !!Teapot methodsFor: 'url mapping' stamp: '3/1/2025 23:01'!output: transformerBlockOrSymbol	current responseTransformer: (self responseTransformer: transformerBlockOrSymbol)	! !!Teapot methodsFor: 'private' stamp: '3/1/2025 23:01'!responseTransformer: transformerBlockOrSymbol	^ transformerBlockOrSymbol isSymbol		ifTrue: [ TeaOutput perform: transformerBlockOrSymbol ]		ifFalse: [ transformerBlockOrSymbol ]! !!Teapot methodsFor: 'url mapping' stamp: '3/1/2025 23:01'!serveStatic: urlPrefixString from: pathString		staticRouter urlPrefix: urlPrefixString path: pathString! !!Teapot methodsFor: 'accessing' stamp: '3/1/2025 23:01'!server	^ server! !!Teapot methodsFor: 'controlling' stamp: '3/1/2025 23:01'!start	server start! !!Teapot methodsFor: 'controlling' stamp: '3/1/2025 23:01'!stop	server stop! !!Teapot methodsFor: 'filters' stamp: '3/1/2025 23:01'!when: aBlockClosure 	current whenClause: aBlockClosure	! !!Collection methodsFor: '*Teapot-Core' stamp: '3/1/2025 23:01'!asTeaUrlPattern	^ TeaUrlPatternSet fromCollection: self! !"Teapot-Core"!!Cupboard commentStamp: '' prior: 0!A cupboard for teapots.I'm the main User Interface to manage teapots instances.You can open me with:		self soleInstance open!!TeaFormTab commentStamp: '' prior: 0!I'm built up from a dynamically extensible key value pair list (TeaKeyValueInput). I can represent POST parameters or HTTP headers for example.!!TeaKeyValueInput commentStamp: '' prior: 0!Two inputs and a remove button.!!TeaKeyValueList commentStamp: '' prior: 0!I'm built up from a dynamically extensible list of other components.!!TeaRequestBodyTabs commentStamp: '' prior: 0!I graphically represent a request body that can be viewed in multiple ways.!!Teaspoon commentStamp: '' prior: 0!I provide a graphical interface for quickly testing and excesising routes. Right click on a route in the inspector to open me.!!ManifestTeapotTools commentStamp: '' prior: 0!Please describe the package using the class comment of the included manifest class. The manifest class also includes other additional metadata for the package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!TeaIconProvider commentStamp: '' prior: 0!An icon provider for tools icons with an icon cache!!TeaRoute methodsFor: '*Teapot-Tools' stamp: '3/1/2025 23:01'!inspectRoute: aBuilder	<inspectorPresentationOrder: 0 title: 'Teaspoon'>	^ Teaspoon new		method: requestMatcher methodMatcher asString		url: requestMatcher urlPattern asTeaspoonPath		port: port.! !!Cupboard class methodsFor: 'accessing' stamp: '3/1/2025 23:01'!iconProvider	^TeaIconProvider! !!Cupboard class methodsFor: 'world menu' stamp: '3/1/2025 23:01'!menuCommandOn: aBuilder 	<worldMenu> 		(aBuilder item: #'Teapot')	 		help: 'Teatime'; 		parent: #'Tools' translated;		icon: self iconProvider teapotIcon;		action: [ self soleInstance open ].	 aBuilder withSeparatorAfter ! !!Cupboard class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!new	self error: 'Do not create new instances - access using #soleInstance'! !!Cupboard class methodsFor: 'private' stamp: '3/1/2025 23:01'!reset	<script>		soleInstance := nil.	 ! !!Cupboard class methodsFor: 'accessing' stamp: '3/1/2025 23:01'!soleInstance	<script: 'self soleInstance inspect'>		^ soleInstance ifNil: [ soleInstance := self basicNew initialize ]! !!Cupboard methodsFor: 'initialization' stamp: '3/1/2025 23:01'!buildBrowseToolBarItem	^ SpToolbarButtonPresenter new		label: 'Browse';		icon: self iconProvider teapotServerIcon;		action: [ self selectedTeapot browse ];		help: 'Browse the selected Teapot';		yourself! !!Cupboard methodsFor: 'initialization' stamp: '3/1/2025 23:01'!buildContextMenu	^ SpMenuPresenter new			addItem: [ :item | 				item 					name: 'Start';					icon: self iconProvider teapotServerStartIcon;					action: [ teapots selectedItem start. self refreshTeapots ] ];			addItem: [ :item | 				item 					name: 'Stop';					icon: self iconProvider teapotServerStopIcon;					action: [ teapots selectedItem stop. self refreshTeapots ] ];			addItem: [ :item | 				item 					name: 'Browse';					icon: self iconProvider teapotServerIcon;					action: [ teapots selectedItem browse. self refreshTeapots ] ];		yourself! !!Cupboard methodsFor: 'initialization' stamp: '3/1/2025 23:01'!buildInspectToolBarItem	^ SpToolbarButtonPresenter new		label: 'Inspect';		icon: self iconProvider teapotInspectIcon;		action: [ self selectedTeapot inspect ];		help: 'Inspect the selected Teapot';		yourself! !!Cupboard methodsFor: 'initialization' stamp: '3/1/2025 23:01'!buildNewStaticToolBarItem	^ SpToolbarButtonPresenter new		  label: 'New File Server';		  icon: self iconProvider teapotServerStaticIcon;		  action: [			  self onNewStaticServer.			  self refreshTeapots ];		  help: 'Create a new Teapot serving static files';		  yourself! !!Cupboard methodsFor: 'initialization' stamp: '3/1/2025 23:01'!buildNewToolBarItem	^ SpToolbarButtonPresenter new		  label: 'New Server';		  icon: self iconProvider teapotServerIcon;		  action: [			  self onNewServer.			  self refreshTeapots ];		  help: 'Create a new Teapot';		  yourself! !!Cupboard methodsFor: 'initialization' stamp: '3/1/2025 23:01'!buildRefreshToolBarItem	^ SpToolbarButtonPresenter new		label: 'Refresh';		icon: self iconProvider teapotRefreshIcon;		action: [ self refreshTeapots ];		help: 'Refresh the Teapot list';		yourself! !!Cupboard methodsFor: 'initialization' stamp: '3/1/2025 23:01'!buildStartToolBarItem		^ SpToolbarButtonPresenter new		label: 'Start';		icon: self iconProvider teapotServerStartIcon;		action: [ self selectedTeapot start. self refreshTeapots ];		help: 'Start the selected Teapot';		yourself! !!Cupboard methodsFor: 'initialization' stamp: '3/1/2025 23:01'!buildStopToolBarItem		^ SpToolbarButtonPresenter new		label: 'Stop';		icon: self iconProvider teapotServerStopIcon;		action: [ self selectedTeapot stop. self refreshTeapots ];		help: 'Stop the selected Teapot';		yourself! !!Cupboard methodsFor: 'initialization' stamp: '3/1/2025 23:01'!buildToolbar		^ self newToolbar 		addItem: self buildRefreshToolBarItem;		addItem: self buildNewToolBarItem;		addItem: self buildNewStaticToolBarItem;		addItem: self buildStartToolBarItem;		addItem: self buildStopToolBarItem;		addItem: self buildBrowseToolBarItem;		addItem: self buildInspectToolBarItem;		yourself! !!Cupboard methodsFor: 'layout' stamp: '3/1/2025 23:01'!defaultLayout 	^ SpBoxLayout newTopToBottom 		add: teapots;		yourself! !!Cupboard methodsFor: 'private' stamp: '3/1/2025 23:01'!iconForTeapot: aTeapot	^aTeapot server isRunning 			ifTrue: [ self iconProvider teapotServerStartIcon ] 			ifFalse: [ self iconProvider teapotServerStopIcon ]! !!Cupboard methodsFor: 'accessing' stamp: '3/1/2025 23:01'!iconProvider	^ self class iconProvider! !!Cupboard methodsFor: 'initialization' stamp: '3/1/2025 23:01'!initializePresenters		teapots := self newList.	teapots		items: self teapots;		displayIcon: [:each | self iconForTeapot: each ];		display: [ :each | self nameForTeapot: each  ];		whenActivatedDo: [ self selectedTeapot inspect ];		bindKeyCombination: Character cr asShortcut toAction: [ self selectedTeapot inspect ];		contextMenu: self buildContextMenu! !!Cupboard methodsFor: 'initialization' stamp: '3/1/2025 23:01'!initializeWindow: aWindowPresenter	super initializeWindow: aWindowPresenter.	aWindowPresenter 		title: 'Teapots';		toolbar: (toolbar := self buildToolbar).! !!Cupboard methodsFor: 'private' stamp: '3/1/2025 23:01'!nameForTeapot: aTeapot	^ String streamContents: [:stream |		stream nextPutAll: aTeapot server port asString.		stream nextPutAll: ' - '.		stream nextPutAll: (aTeapot server isRunning ifTrue: [ 'running' ] ifFalse: [ 'stopped' ]) ].! !!Cupboard methodsFor: 'actions' stamp: '3/1/2025 23:01'!onNewServer	| port pot |	port := UIManager default request: 'New server' initialAnswer: '80'.	port ifNil: [ ^ self ].	pot := Teapot configure: { 		#port -> port asNumber	}.	pot start.			! !!Cupboard methodsFor: 'actions' stamp: '3/1/2025 23:01'!onNewStaticServer	| port directory pot |	port := UIManager default request: 'New server' initialAnswer: '80'.	port ifNil: [ ^self ].	directory := UIManager default chooseDirectory: 'Serve directory'.	directory ifNil: [ ^ self ].	pot := Teapot configure: { 		#port -> port asNumber	}.	pot serveStatic: '/' from: directory.	pot start.			! !!Cupboard methodsFor: 'actions' stamp: '3/1/2025 23:01'!open	self refreshTeapots.	super open.! !!Cupboard methodsFor: 'printing' stamp: '3/1/2025 23:01'!printOn: aStream	aStream nextPutAll: 'Cupboard'! !!Cupboard methodsFor: 'actions' stamp: '3/1/2025 23:01'!refreshTeapots	teapots items: self teapots! !!Cupboard methodsFor: 'accessing' stamp: '3/1/2025 23:01'!selectedTeapot	^ teapots selectedItem! !!Cupboard methodsFor: 'accessing' stamp: '3/1/2025 23:01'!teapots	^ Teapot allInstances! !!TeaFormTab class methodsFor: 'specs' stamp: '3/1/2025 23:01'!defaultLayout	^ SpBoxLayout newVertical 		add: #form expand: false fill: false;      add: (SpBoxLayout newHorizontal 		   add: #addButton expand: false fill: false;         hAlignCenter;         yourself) expand: false fill: false;				yourself! !!TeaFormTab methodsFor: 'accessing' stamp: '3/1/2025 23:01'!addButton	^ addButton ! !!TeaFormTab methodsFor: 'initialization' stamp: '3/1/2025 23:01'!connectPresenters 	addButton whenActionPerformedDo: [ form addKey: 'key' value: 'value' ]! !!TeaFormTab methodsFor: 'accessing' stamp: '3/1/2025 23:01'!form	^ form! !!TeaFormTab methodsFor: 'initialization' stamp: '3/1/2025 23:01'!initializePresenters	addButton := self newButton label: 'Add parameter'; yourself.	form := self instantiate: TeaKeyValueList.	self focusOrder 		add: form;		add: addButton.! !!TeaFormTab methodsFor: 'protocol' stamp: '3/1/2025 23:01'!updateKeyValus: keyValueCollection	form items: keyValueCollection! !!TeaFormTab methodsFor: 'private' stamp: '3/1/2025 23:01'!urlEncoded	| url formParams |	url := '/' asZnUrl.	formParams := form items.	formParams ifEmpty: [ ^ '' ].	formParams do: [ :association | url := url withQuery: association ].	^ url asString allButFirst: 2	! !!TeaFormTab methodsFor: 'protocol' stamp: '3/1/2025 23:01'!writeUrlEncodedTo: aTextModel	self urlEncoded 		ifNotEmpty: [ aTextModel text: self urlEncoded ]! !!TeaKeyValueInput class methodsFor: 'specs' stamp: '3/1/2025 23:01'!defaultLayout	^ SpBoxLayout newHorizontal  		add: #keyInput expand: true fill: true padding: 5;		add: #valueInput expand: true fill: true padding: 5;		add: #removeButton expand: false fill: false padding: 5;		vAlignStart;		yourself! !!TeaKeyValueInput class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!key: keyString value: valueString removeAction: aBlock	^ self new		setKey: keyString 		value: valueString		removeAction: aBlock! !!TeaKeyValueInput methodsFor: 'converting' stamp: '3/1/2025 23:01'!asAssociation	^ keyInput text -> valueInput text! !!TeaKeyValueInput methodsFor: 'initialization' stamp: '3/1/2025 23:01'!initializePresenters	keyInput := self newTextInput placeholder: 'key'; yourself.	valueInput := self newTextInput placeholder: 'value'; yourself.	removeButton := self newButton label: 'Remove'; yourself.	self focusOrder		add: keyInput;		add: valueInput;		add: removeButton.		! !!TeaKeyValueInput methodsFor: 'accessing' stamp: '3/1/2025 23:01'!keyInput	^ keyInput! !!TeaKeyValueInput methodsFor: 'accessing' stamp: '3/1/2025 23:01'!removeButton	^ removeButton! !!TeaKeyValueInput methodsFor: 'initialization' stamp: '3/1/2025 23:01'!setKey: keyString value: valueString removeAction: aBlock	keyInput text: keyString.	valueInput text: valueString.	removeButton whenActionPerformedDo: [ aBlock value: self ].	^ self! !!TeaKeyValueInput methodsFor: 'accessing' stamp: '3/1/2025 23:01'!valueInput	^ valueInput! !!TeaKeyValueList methodsFor: 'protocol' stamp: '3/1/2025 23:01'!addKey: keyString value: valueString	| item |	item := TeaKeyValueInput 		key: keyString 		value: valueString 		removeAction: [ :teaKeyValueInput | self remove: teaKeyValueInput ].	items add: item.	self rebuildLayout.! !!TeaKeyValueList methodsFor: 'private' stamp: '3/1/2025 23:01'!asAssociations	^ items collect: #asAssociation! !!TeaKeyValueList methodsFor: 'initialization' stamp: '3/1/2025 23:01'!defaultLayout	^ SpBoxLayout new! !!TeaKeyValueList methodsFor: 'initialization' stamp: '3/1/2025 23:01'!initialize	super initialize.	items := OrderedCollection new.! !!TeaKeyValueList methodsFor: 'protocol' stamp: '3/1/2025 23:01'!items	^ self withoutDuplicatesAndBlanks: (self asAssociations asOrderedDictionary)! !!TeaKeyValueList methodsFor: 'protocol' stamp: '3/1/2025 23:01'!items: keyedCollection	items removeAll.	keyedCollection keysAndValuesDo: [ :key :value | self addKey: key value: value ].! !!TeaKeyValueList methodsFor: 'initialization' stamp: '3/1/2025 23:01'!layout 	| box |	box := SpBoxLayout newVertical		spacing: 5;		vAlignStart;		yourself.	items do: [ :teaKeyValueInput | box add: teaKeyValueInput ].	^ items 		ifEmpty: [ box ] 		ifNotEmpty: [ SpScrollableLayout with: box ]! !!TeaKeyValueList methodsFor: 'private' stamp: '3/1/2025 23:01'!remove: item	items remove: item.	self rebuildLayout.! !!TeaKeyValueList methodsFor: 'private' stamp: '3/1/2025 23:01'!withoutDuplicatesAndBlanks: keyedCollection	| keyset |	keyset := PluggableSet new		equalBlock: [ :a :b | a key = b key ];		hashBlock: [ :x | x key hash ];		yourself.					keyedCollection keysAndValuesDo: [ :key :value | 		keyset add: (key -> value) ].	^ keyset reject: [ :each | 		each key isEmptyOrNil or: [ each value isEmptyOrNil ] ]! !!TeaRequestBodyTabs class methodsFor: 'layout' stamp: '3/1/2025 23:01'!defaultLayout	^ SpBoxLayout newVertical 		add: #label expand: false fill: false;		spacing: 5;		add: #requestBody expand: true fill: true;		yourself! !!TeaRequestBodyTabs methodsFor: 'private' stamp: '3/1/2025 23:01'!formTabTitle	^ 'Form'! !!TeaRequestBodyTabs methodsFor: 'initialization' stamp: '3/1/2025 23:01'!initializePresenters	label := self newLabel label: 'Request body'; yourself.	requestBody := self newRequestBody.! !!TeaRequestBodyTabs methodsFor: 'accessing' stamp: '3/1/2025 23:01'!label	^ label! !!TeaRequestBodyTabs methodsFor: 'initialization' stamp: '3/1/2025 23:01'!newRequestBody	raw := self newText.	form := TeaFormTab new.	^ self newNotebook 		addPageTitle: self rawTabTitle provider: raw; 		addPageTitle: self formTabTitle provider: form;		whenSelectedPageChangedDo: [ :selected | 			selected title = self formTabTitle				ifTrue: [ form updateKeyValus: ('?' , raw text) asUrl query ]				ifFalse: [ form writeUrlEncodedTo: raw ] ];		yourself! !!TeaRequestBodyTabs methodsFor: 'private' stamp: '3/1/2025 23:01'!rawTabTitle	^ 'Raw'! !!TeaRequestBodyTabs methodsFor: 'accessing' stamp: '3/1/2025 23:01'!requestBody	^ requestBody! !!TeaRequestBodyTabs methodsFor: 'protocol' stamp: '3/1/2025 23:01'!urlEncoded	requestBody selectedPage title = self formTabTitle		ifTrue: [ raw text: form urlEncoded ].	^ raw text! !!Teaspoon class methodsFor: 'layout' stamp: '3/1/2025 23:01'!defaultLayout    ^ SpBoxLayout newVertical         add: (SpBoxLayout newHorizontal                    vAlignCenter;                    add: #methodDropList expand: false fill: false;                    spacing: 5;                    add: #urlInput expand: true fill: true;                    yourself)             expand: false fill: false padding: 10;        add: #requestBody expand: true fill: true;        add: (SpBoxLayout newHorizontal                vAlignCenter;                add: #contentTypeLabel expand: false fill: false;                spacing: 5;                add: #contentTypeDropList expand: true fill: true;                yourself)            expand: false fill: false;        spacing: 10;				  add: #resultLabel expand: false fill: false;        add: #resultText expand: true fill: true;        add: (SpBoxLayout newHorizontal                 add: #execButton expand: false fill: false;                hAlignCenter;                yourself)            expand: false fill: false;        yourself! !!Teaspoon class methodsFor: 'private - accessing' stamp: '3/1/2025 23:01'!iconProvider	^TeaIconProvider ! !!Teaspoon class methodsFor: 'world menu' stamp: '3/1/2025 23:01'!menuCommandOn: aBuilder 	<worldMenu> 		(aBuilder item: #'Teaspoon')	 		help: 'Teaspoon'; 		parent: #'Tools' translated;		icon: self iconProvider teaspoonIcon;		action: [ self open ].! !!Teaspoon class methodsFor: 'interface' stamp: '3/1/2025 23:01'!open	<script>	^ (SpWindowPresenter presenter: self new)		initialExtent: 600@600;		open;		yourself! !!Teaspoon class methodsFor: 'specs' stamp: '3/1/2025 23:01'!title	^ 'Teaspoon client'! !!Teaspoon methodsFor: 'private' stamp: '3/1/2025 23:01'!client	^ ZnClient new		url: self urlInput text;		method: self methodDropList selectedItem;		entity: (ZnStreamingEntity 			readFrom: (ReadStream on: requestBody urlEncoded)			usingType: self contentTypeDropList selectedItem			andLength: requestBody urlEncoded size)		yourself! !!Teaspoon methodsFor: 'initialization' stamp: '3/1/2025 23:01'!connectPresenters 	execButton		whenActionPerformedDo: [ 			self urlInput text notEmpty				ifTrue: [ 					self resultText text: ''.					self resultText text: self client execute.				] 		]! !!Teaspoon methodsFor: 'accessing' stamp: '3/1/2025 23:01'!contentTypeDropList	^ contentTypeDropList! !!Teaspoon methodsFor: 'accessing' stamp: '3/1/2025 23:01'!contentTypeLabel	^ contentTypeLabel! !!Teaspoon methodsFor: 'accessing' stamp: '3/1/2025 23:01'!execButton	^ execButton! !!Teaspoon methodsFor: 'initialization' stamp: '3/1/2025 23:01'!initializePresenters	super initializePresenters.	methodDropList := self newMethodDropList.	urlInput := self newTextInput autoAccept: true; text: 'http://localhost:1701/'; yourself.	requestBody := TeaRequestBodyTabs new.	contentTypeLabel := self newLabel label: 'Content Type'; yourself.	contentTypeDropList := self newContentTypeDropList.	execButton := self newButton label: 'Execute request'; yourself.	resultText := self newText.	resultLabel := self newLabel label: 'Result'; yourself.! !!Teaspoon methodsFor: 'tea spoon' stamp: '3/1/2025 23:01'!method: methodString url: urlString port: portNumber	self populateMethod: methodString.	self populateUrl: urlString port: portNumber.! !!Teaspoon methodsFor: 'accessing' stamp: '3/1/2025 23:01'!methodDropList	^ methodDropList! !!Teaspoon methodsFor: 'initialization' stamp: '3/1/2025 23:01'!newContentTypeDropList	| dropList |	dropList := self newDropList.	#(		applicationFormUrlEncoded 		applicationJson 		applicationXml 		applicationSton 		applicationOctetStream 		text 		textHtml 		textPlain	) do: [ :each | dropList addItemLabeled: (each value: ZnMimeType) do: [] ].		^ dropList! !!Teaspoon methodsFor: 'initialization' stamp: '3/1/2025 23:01'!newMethodDropList	| dropList |	dropList := self newDropList.	ZnConstants knownHTTPMethods do: [ :each | 		dropList addItemLabeled: each do: [] ].	^ dropList! !!Teaspoon methodsFor: 'private' stamp: '3/1/2025 23:01'!populateMethod: methodString	| selected |	selected := methodDropList listItems		detect: [ :each | each = methodString ]		ifNone: [ methodDropList listItems first ].	methodDropList selectItem: selected.! !!Teaspoon methodsFor: 'private' stamp: '3/1/2025 23:01'!populateUrl: urlString port: portNumber	| pathSegment |	pathSegment := urlString.	(pathSegment beginsWith: '/') 		ifFalse: [ pathSegment := '/', pathSegment ].		urlInput text: ('http://localhost:', portNumber asString, pathSegment)! !!Teaspoon methodsFor: 'accessing' stamp: '3/1/2025 23:01'!requestBody	^ requestBody! !!Teaspoon methodsFor: 'accessing' stamp: '3/1/2025 23:01'!resultLabel	^ resultLabel! !!Teaspoon methodsFor: 'accessing' stamp: '3/1/2025 23:01'!resultText	^ resultText! !!Teaspoon methodsFor: 'accessing' stamp: '3/1/2025 23:01'!urlInput	^ urlInput! !!TeaRxUrlPattern methodsFor: '*Teapot-Tools' stamp: '3/1/2025 23:01'!asTeaspoonPath	^ '/'! !!ManifestTeapotTools class methodsFor: 'code-critics' stamp: '3/1/2025 23:01'!ruleLongMethodsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#Cupboard #inspectTeapot: #false)) #'2022-08-29T16:00:19.64012+02:00') )! !!TeaUrlPatternSet methodsFor: '*Teapot-Tools' stamp: '3/1/2025 23:01'!asRequestBuilderPath	^ patterns 		ifEmpty: [ '/' ]		ifNotEmpty: [ patterns first asTeaspoonPath ]! !!TeaUrlPatternSet methodsFor: '*Teapot-Tools' stamp: '3/1/2025 23:01'!asTeaspoonPath	^ patterns 		ifEmpty: [ '/' ]		ifNotEmpty: [ patterns first asTeaspoonPath ]! !!Teapot methodsFor: '*Teapot-Tools' stamp: '3/1/2025 23:01'!browse	WebBrowser openOn: 'http://localhost:', self server port asString! !!Teapot methodsFor: '*Teapot-Tools' stamp: '3/1/2025 23:01'!inspectAfterFilter: aBuilder	<inspectorPresentationOrder: 0 title: 'After Filters'>	| list |	^ (list := SpListPresenter new)		items: compositeRouter afterFilters;		display: [ :filter | filter requestMatcher ];		contextMenu: (SpMenuPresenter new 			addItem: [ :item | 				item					name: 'Remove filter';					action: [ 						self removeAfterFilter: list selectedItem.						list refresh ] ]);				yourself! !!Teapot methodsFor: '*Teapot-Tools' stamp: '3/1/2025 23:01'!inspectBeforeFilter: aBuilder	<inspectorPresentationOrder: 0 title: 'Before Filters'>	| list |	^ (list := SpListPresenter new)		items: compositeRouter beforeFilters;		display: [ :filter | filter requestMatcher ];		contextMenu: (SpMenuPresenter new 			addItem: [ :item | 				item					name: 'Remove filter';					action: [ 						self removeBeforeFilter: list selectedItem.						list refresh ] ];			yourself);  		yourself! !!Teapot methodsFor: '*Teapot-Tools' stamp: '3/1/2025 23:01'!inspectDynamicRoutes: aBuilder	<inspectorPresentationOrder: 0 title: 'Dynamic routes'>      	| list |	^ (list := SpListPresenter new)		items: dynamicRouter routes;		display: [ :route | route printString ];		contextMenu: (SpMenuPresenter new 			addItem: [ :item | 				item					name: 'Remove route';					action: [ 						self removeDynamicRoute: list selectedItem.						list refresh ] ];			yourself);   				yourself.! !!Teapot methodsFor: '*Teapot-Tools' stamp: '3/1/2025 23:01'!removeAfterFilter: aFilter	compositeRouter afterFilters remove: aFilter! !!Teapot methodsFor: '*Teapot-Tools' stamp: '3/1/2025 23:01'!removeAllAfterFilters 	compositeRouter afterFilters removeAll! !!Teapot methodsFor: '*Teapot-Tools' stamp: '3/1/2025 23:01'!removeAllBeforeFilters 	compositeRouter beforeFilters removeAll! !!Teapot methodsFor: '*Teapot-Tools' stamp: '3/1/2025 23:01'!removeAllDynamicRoutes 	dynamicRouter routes removeAll! !!Teapot methodsFor: '*Teapot-Tools' stamp: '3/1/2025 23:01'!removeBeforeFilter: aFilter	compositeRouter beforeFilters remove: aFilter! !!Teapot methodsFor: '*Teapot-Tools' stamp: '3/1/2025 23:01'!removeDynamicRoute: aRoute	dynamicRouter routes remove: aRoute! !!TeaGlobUrlPattern methodsFor: '*Teapot-Tools' stamp: '3/1/2025 23:01'!asTeaspoonPath	^ String streamContents: [ :aStream |			segments 				do: [ :each | each printOn: aStream ]				separatedBy: [ aStream nextPut: $/ ] ]! !!TeaIconProvider class methodsFor: 'private - icons' stamp: '3/1/2025 23:01'!form: base64String	^ Form fromBinaryStream: (base64String base64Decoded asByteArray readStream)! !!TeaIconProvider class methodsFor: 'accessing' stamp: '3/1/2025 23:01'!icons	IconCache ifNil: [ IconCache := Dictionary new ].	^IconCache! !!TeaIconProvider class methodsFor: 'icons' stamp: '3/1/2025 23:01'!teapotIcon	^ self icons			at: #'teapotIcon'			ifAbsentPut: [ self form: self teapotIconContents ]! !!TeaIconProvider class methodsFor: 'private - icons' stamp: '3/1/2025 23:01'!teapotIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABhklEQVR42rWSPSxDURTHzzmvr8TyRBP00Y1BQiwiRD+YkKiPyWqTSDAZjUaj2SyS0lbEpNWPRCTEYBeNKrv4qN57nFYiPoqXNM7Nzcs799zf/Z//vQg1Bv4rIO4LdDCgF5FPwrn0s2PAdmsf1RkNvbK6KbMLGGaR4SCcTz19A0S8A3NkGo/TuexWORG1A/2MvE9EHuQ3PsuQeFFcWjXQtaEVjpHBzZLexj07cK4Je1jTKBn6khmzCNzyJo7h41dAD8z6FJEs+TuT1hijdnAICdJS8ShFRSlv/Ms4Zp6ZzKd2Y75gBqM+v9DoChgt587zsrtObRSLdFFpMm4Hk0AQcgpw89N6CdyHCnGtAthp93e6gI6l0yZ08DTEi1NibSmCpffqeFvILF+C3MD47/LFK8Y9MNRiOJe5+3RczDviYXpJisvdP+wXo2FCVCbC10dc9SHF7eF6QD2vUC8Qkkf0uiT9wFon5OSVqUL65oui6hGxBy3TMMsAU+Y9Ki5M3KZ1lZZqi5oBr2z5j75RN5raAAAAAElFTkSuQmCC'! !!TeaIconProvider class methodsFor: 'icons' stamp: '3/1/2025 23:01'!teapotInspectIcon	^ self iconNamed: #'glamorousInspect'! !!TeaIconProvider class methodsFor: 'icons' stamp: '3/1/2025 23:01'!teapotRefreshIcon	^ self iconNamed: #'glamorousRefresh'! !!TeaIconProvider class methodsFor: 'icons' stamp: '3/1/2025 23:01'!teapotServerIcon	^ self icons			at: #'teapotServerIcon'			ifAbsentPut: [ self form: self teapotServerIconContents ]! !!TeaIconProvider class methodsFor: 'private - icons' stamp: '3/1/2025 23:01'!teapotServerIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC0UlEQVR4Xo2SbU+SURzG+RS2hDdufQBtM0e58GHa8o2W3mbWkjbLhzURTTNEHnwowNKG2oM6JUWF2+fHTJ2aJaFCPlAzJygGOMPM8qF8wqtbXli2rK7t2v7n7Fy/c8520fbk4nKEkZkpIUViKckXSEj9qBEjehNG3kxDILxLenoyCVdXVwbtMHl7s4hJ4ypsi1uUHbDad2Fz2kGtd2G2bWBIZ0Jz6wvLHtDL69RBIIvlS2hGFqEbW4FhcgWmuU0YzduYNu9QswOmDw7MWhwUaAe2Tw7M29dxIyGV3Af4+voR3X1mDAwuoLd/Hl09c9Q8D/34MgVcxYz1O+yft2Ff3sTYWxvKK/oRxU44CGhpe4/Orlm0tk+joWkS6toJ1KhHoax5jdLyPsgLn0GUrUZMnBTnw64jPj7lIEBNjqK+8R1U5DiU1XqUP9WitGwQfEEJMgRS5D8ohrJKjampKQhF9+HjG8j9BeBPlCk0qFDqUKbQ4knJSzwsom6Vd1N/lcJgMGBraxvf1jfw5es64mJvwfMEk9gHBAaeIeQFXXhcPIDCwl7k5z9HrqwDUkkL2Ox0aLXDWFvbwsLCMmZm7QgJYeNsUNBPgLu7B1MirUdeXidk0nbkZDdBLKqjXIuIiBS0tXXBal2C0bSEVxoTgoOjQGfQD/YiLU1MioQqZ1AoUEOQoYZISCI8PBnVNc2YMFiocpnR1jEM9lUO/lioa9FJZDqvygnYsxNwIQmKikYqbMGAZgbquh4kcsU4tJUyWYklg6/aBxDhXBQ9UkE3/hGDQzNIThUg5BxbcyjgKFVRHk9uEWSonIAwgoukm3eo0CW4uR1DQEAktRdN0v4md4/jTA4n17L3ipjYe2D5ROK0z0VcTuSBL6zElajYPNq/5OcfQGRlKZHAKaLal4/bPAXkBa3IypZr6HQ6g/Y/8vI6SVRW9qChUYPsnCJNaGgE9/czPwCyhvLlWzqQAwAAAABJRU5ErkJggg=='! !!TeaIconProvider class methodsFor: 'icons' stamp: '3/1/2025 23:01'!teapotServerStartIcon	^ self icons			at: #'teapotServerStartIcon'			ifAbsentPut: [ self form: self teapotServerStartIconContents ]! !!TeaIconProvider class methodsFor: 'private - icons' stamp: '3/1/2025 23:01'!teapotServerStartIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADR0lEQVR4Xn2T71fTZRyG+S804RV56k3Hc6jciTpHICnNOnVYfCWhCZiiCAxGlEbbhCg2TjQdIYlCwWIIU0crDhAiiOA8xL6B4kFqG7+22QYRHCL5Nbia7ByOnNPpc859zvPmup7nOef+hDw5JzOydQWfaU0qtdYkDjro/9VJv2in8lKdVaMtNUkkksiQ/xtr3ygu3yqe6TU8U4+zHjgHM/FwmT5xFMtP3S71GY1JocjT7dgRGrZF0NH1O+LdBe7en8c+tohzfBXHmB/HhB/n5BpjrkA8fh4GLnB7/0aRm2/aImhpG6LH6qOz20N7xwQ3ezzYBv/i3vBCAF7CN7PK1NwyA0Muqr69wcmMj7cKmiw22q6P09xip8nyANPVIeobBqhv/IXq7zopK2+l4PNG0k5oiBfSSUxM1W0RNDRaMf8wTOOVe9TVi9QY+rhY1UthkQGlUsPZc5UYjSbsdgenPikmIkIibMK7JS9G5p0vIfF8Dqll+ZRUmKmouIlef52c3HOINhsrKys8+meZ2dkFUlKziY19LSiQ7JUIh5vep2SgmNbJFgy/1XC09SgHNXI0xRbSjmvo6uxiIQB7vbPYHX8glaYSFxcnhGx7altYglmgxl5Ns+tHFlcfMTI3TJ2zluzeLA4pPyLlSCENDddwu2dwOP+kq/tB4P/pbNwe/UGU7thtGbXOSuaX51hfX9+IdfoW+pESdpdHkpx6hksXjQzdn6TfNo7Z0kumXBUUPK/YZZKLR5ha9G7Cj+Nf82NxX+E5YziyFCXlFbXYRDc9t0epu9yCUlUaFLycJzEliq9TMfkF7TPmALyGb9nDhUkN6hE5uy4/TVLyp3xZWoU46KM30FZ5zile3SsNdkCaJdW9eecF0u1vUT+t3xC4lhx86BQ4OPgKMd/EIktWkZmlJu5dGeHhO9m3T4bscEZQEBoWGpbbeZwi1zF+nq8LvmBlgq+8uSTciiFNpSUzs4zomCT2RL9HUk4+6oLv2f/GO4rNDhx4+4CQcTXFVTRygralKmqnNMithyisLrBqtUYUiguB9p3ldH4N+q+bAxU+bfrPbYzaHyVsj9guPBv5jCB5Kbi6UXtiBIOhnWvmO3TcsBEfn6B4kvkXxV9YN+ClYBQAAAAASUVORK5CYII='! !!TeaIconProvider class methodsFor: 'icons' stamp: '3/1/2025 23:01'!teapotServerStaticIcon	^ self icons			at: #'teapotServerStaticIcon'			ifAbsentPut: [ self form: self teapotServerStaticIconContents ]! !!TeaIconProvider class methodsFor: 'private - icons' stamp: '3/1/2025 23:01'!teapotServerStaticIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADIElEQVR42l2Ta0gUURTH/1fHWVNz2dLNIinQ0shAKCsSixIp7EMQ7VKbH8SICopo6UFaiBqZBm5R1Bc1i7ZwJw1DlzbQfKTr9rA+aGX2MFbbNsu21Np259Gdcczwwsw5c+85vzn/e+8hoCM0NHThjh07KySJQBAl5BcUGUSRAEREWWkh19Ls4H788DkFQRjCjEHkV0xMrKGj+70tWquRcZBBygIkGkEQDATg9Qyjr/f5kL2p3vmw5QHn831XgEpcbKze0GDvs7FhGmgoIyJCQyEhNJ0ghBDlNyGyCZEQpqFw0Y+8XBN3395gVAB6vd5grX1s07Dh4IMieD6I8FlhiIyaBZZlEDmbQVQEo0j6NPwVz3sGcL26nGtttU8DKqvbbSyrQTDIq08QoijQPfHD7/fj14Qfo76f8AwPYmTkHSbGPnMOx71pwKXLDhsTxirJPD8JoBoxOPiSKhjFnDk6KlWLtFWpuHW7EdVVl8xu96BFBcwznCu/a2MYdjo5QEECjzdve7BvbzaSkpKpPAEBXsDJE8WotVUaR0e/cQogLi7OkF9ww8Zq6B4EJgFysCjyePXahf37tyElJRXj4xP49TsI85HjcLkcRo/Hw5HVaQlRSUv0pdu3rj/IIAj30E/09Osxf8EKMAxDAY+Rk5OF1NSV8P8BPnt9OF9WjMamm/ECT48xL3fzoePmLSW6CEYLegISL6HD9RFdL3jodDqMfHEjOTke0XOTkLw8HV7vF9zhrKi5dlGpnpwpybHmH0s3EZ5+C/Tq8HRSkFQ7OQfqV9S+QtrGw/B8eg9nZycuWApVQNFua8HRDJMcJKnBRJj0CfX/Abh+rM06hPq6Gjx1PXO2tTWtUwAlhbsoYINJDpbUBKLCiJoszx04WwfHow9ITFyNsXEv1+1sNiqA4tNG6ynzRhNouUSYgkhqJdMS9pzhEIhbg8XaZXDYr1qePOkyK4CiUwbr6SOZJjJTgmqnAEevtGJRym709j50VlVeNE51Jtm0IcWcmbE0WxLpCdBWlgQRoFdY9sfG/PqYeQkr5IZqfzrg7n/nsQwM9Fv+b+e/lwaeIIipiHQAAAAASUVORK5CYII='! !!TeaIconProvider class methodsFor: 'icons' stamp: '3/1/2025 23:01'!teapotServerStopIcon	^ self icons			at: #'teapotServerStopIcon'			ifAbsentPut: [ self form: self teapotServerStopIconContents ]! !!TeaIconProvider class methodsFor: 'private - icons' stamp: '3/1/2025 23:01'!teapotServerStopIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADO0lEQVR4Xn2T7U+TVxiH+xdsGfso0Q+Gbh+UBYFEsjeSzS6yKWDWdKyMurEXytDyVsfcKHRtFKdWRFyljxoiVbEoq3vxPVM2qKwd5XXZYK30BYotuEXWQaSUa8/GdDZLdidX7i/nvk7OOb8jebhK399uqtfvsdXqGmx9A15cbi9Ot4cWi9VRUrLNtGnTZrnk/6q710swHCM0vchkeInJyH3iTIQX+WHAj6vPw8e1u2ylpRrTunXpWQmCq9+M4h6KMjByl7HxOby+RTzjcbx+kcAStwJxxicWRVmc8K/3uHSlhwTB1xeH+c4R4XpXiCvXAlz/Nige4w6DI7/j8c8zNR1j5m6MUe805+xOzC32REGn3cXlq36+uuDh8/M/Yzs7zKn2fto7XAitN2g+chljQwea8kMoCspQKsscCYJT7T102n/iTMcQJ0+7aT3hRDjWw8HmC2zbvpP9piMcP96G0+nCaj1NXv5W24PhZLGExjO06Fux7LdjOdrNZ+YbHGy6hmFXO21tVhYWYszP32N2do69ew/xVrFmWaDKzatoK1IFbxoM/GhpoddoxKpS0/CBwO7dX1Dz4TGaD5uZm1sgEpklEJihvEJHdfVHNsnG7Gz5RaUSryA84NY/vXOLAl25mR07BOrqDExMzuAL/IZ78DbKwjLS0jLlEqtCERyqqmasvp5fHmJUZKSmhk8zXxJ3sqDV1jI8EqSv3ye+zCQvv1LIixtkcok9dS1Rv49YNCryR0JfiM5yMvNpqkSBpnwn/YMhurq99Nz0kpPzOiuSVyRLvpRKmQuFiC/F/0s8ztn09VRWmSlRa+l1BcWQ3WHPvhaKVGXLGegqKGAsO5tg7mZuFxYSURUxVfgGvtw8RmUyhLTnqKg0o3jtXd4s1iBNeZL1WTL0emFZ8Iw0Rf79Y0kEVq4kLBJZtYopsY+LOB55FJ2qXrwDgRc2bOXZ5xW8qq5AU3kYXd2Bf0O0JUVaMZiRQTQ3l/miImbz8xlIz0AoUTuamjqo1gq8856JKu1R9h04T2OjNZia+lTiR0p9Qppl3JhjM65ZYzPIZLa1q1f/vSAp6fHkE9ZLdJzrRv9Jk6P4bbXpr9Ddn/sTU0VgFvyaFxkAAAAASUVORK5CYII='! !!TeaIconProvider class methodsFor: 'icons' stamp: '3/1/2025 23:01'!teaspoonIcon	^ self icons			at: #'teaspoonIcon'			ifAbsentPut: [ self form: (self teaspoonIconContents) ]! !!TeaIconProvider class methodsFor: 'private - icons' stamp: '3/1/2025 23:01'!teaspoonIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABdklEQVR42mNkoBAwgoiJs6fLvHv/oe/d27cM6urqTxQVFfq8HV2fEG1AQ1f7qlevX4XCBDk5OBnExcWLynLy+4kyIK+idNWfv39C0SUNDQz7U6PjiggaMG3+3L4r164UokvycPMwdDU0MxI0YNfhgzK7du96/O37NwwFCfEJYWY6+qvxGgACPdMmF967f68PXYG8nHxYeW4BYQNAYM6yxX23bt0q/PL1C1xMVFRsdWNZZRhRBsDA8YtnQw8ePMTw8+fP0JevXoby8vCu7qxvCiPaAGRQ2dyw6uOnj6FArzzR09Oz9LR3ekKSASDQNWXi4wcPH8hwc3E/YefgsGyprHlCkgGgWNqzd89xYNjIMDMxP2FkZLSc1NH9hGgDQKCuo1Xm/fv3x//++yvDyMD4hIWV1XJiW+cTog0AAWCKlfn79+/x/wz/ZZiZmZ+oKCtbkmQACORXlcv8//fvODDpy0hJSh0n2QAQmDx3lsynT59W/fnz5wkA2dSUkQj2i7UAAAAASUVORK5CYII='! !!TeaRequestMatcher methodsFor: '*Teapot-Tools' stamp: '3/1/2025 23:01'!urlPattern	^ urlPattern! !"Teapot-Tools"!!TeaTestClient commentStamp: '' prior: 0!Http client for testing.!!TeaUrlPatternTest methodsFor: 'private' stamp: '3/1/2025 23:01'!pattern: patternString matches: urlString	| placeholders |	placeholders := Dictionary new.	self assert: ((TeaGlobUrlPattern parseString: patternString) matchesUrl: urlString asUrl placeholders: placeholders).	^ placeholders! !!TeaUrlPatternTest methodsFor: 'private' stamp: '3/1/2025 23:01'!pattern: patternString noMatch: urlString	| placeholders |	placeholders := Dictionary new.	self deny: ((TeaGlobUrlPattern parseString: patternString) matchesUrl: urlString asUrl placeholders: placeholders).	^ placeholders! !!TeaUrlPatternTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testLongerPatternEndedPlaceholder	self pattern: '/a/b/<id>' noMatch: '/a/b'.! !!TeaUrlPatternTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testLongerPatternEndedWildcard	self pattern: '/a/b/c/*' matches: '/a/b/c'.	self pattern: '/1/2/3/*/*' matches: '/1/2/3'.		self pattern: '/a/b/c/*' noMatch: '/a/b'.! !!TeaUrlPatternTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testNoWildcard		self pattern: '/aa' matches: '/aa'.	self pattern: '/aa' noMatch: '/bb'.! !!TeaUrlPatternTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testPlaceholderSubstitute	| placeholders |		placeholders := self pattern: '/<id>/a/b' matches: '/123/a/b'.	self assert: (placeholders at: #id) equals: '123'.		placeholders := self pattern: '/a/<id>/b' matches: '/a/25/b'.	self assert: (placeholders at: #id) equals: '25'.		placeholders := self pattern: '/a/b/<id>' matches: '/a/b/xyz'.		self assert: (placeholders at: #id) equals: 'xyz'.		! !!TeaUrlPatternTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testPlaceholderTypeMatch	| placeholders |	placeholders := self pattern: '/<id:IsInteger>' matches: '/12'.	self assert: (placeholders at: #id) equals: 12.		placeholders := self pattern: '/<id:IsInteger>/abc' matches: '/-34/abc'.	self assert: (placeholders at: #id) equals: -34.		placeholders := self pattern: '/<float:IsNumber>/<int:IsNumber>' matches: '/3.14/3'.	self assert: (placeholders at: #float) equals: 3.14.	self assert: (placeholders at: #int) equals: 3.	! !!TeaUrlPatternTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testPlaceholderTypeNoMatch	self pattern: '/<id:IsInteger>' noMatch: '/foobar'.		self pattern: '/<id:IsNumber>' noMatch: '/foobar'.	self pattern: '/<id:IsInteger>' noMatch: '/12.3'.		! !!TeaUrlPatternTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testPlaceholders	self pattern: '/<id>/a/b' matches: '/1/a/b'.	self pattern: '/a/<id>/b' matches: '/a/2/b'.	self pattern: '/a/b/<id>' matches: '/a/b/1'.			self pattern: '/<id>/a/b' noMatch: '/1/a/c'.	self pattern: '/a/<id>/b' noMatch: '/a/2/c'.	self pattern: '/a/b/<id>' noMatch: '/a/c/1'.! !!TeaUrlPatternTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testRoot	self pattern: '/' matches: '/'.		self pattern: '/' noMatch: '/a'.		self pattern: '/a' noMatch: '/'.	self pattern: '/a/b' noMatch: '/'.	! !!TeaUrlPatternTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testShorterPatternEndedPlaceholder	self pattern: '/a/b/<id>' noMatch: '/a/b/1/2'.	! !!TeaUrlPatternTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testShorterPatternEndedWildcard	 	self pattern: '/a/*' matches: '/a/b/c'.	self pattern: '/*' matches: '/1/2/3'.	 	self pattern: '/a/*' noMatch: '/b/b/c'.	self pattern: '/a/b' noMatch: '/a/b/c'.	! !!TeaUrlPatternTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testTralingSlash	self pattern: '/a/b' matches: '/a/b/'.! !!TeaUrlPatternTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testWildcards	self pattern: '/*/1/2' matches: '/0/1/2'.	self pattern: '/a/b/*' matches: '/a/b/c'.	self pattern: '/x/*/z' matches: '/x/y/z'.		self pattern: '/*/1/2' noMatch: '/a/1/z'.		self pattern: '/a/b/*' noMatch: '/a/1/z'.		self pattern: '/x/*/z' noMatch: '/a/1/z'.						! !!TeapotAbortTest methodsFor: 'running' stamp: '3/1/2025 23:01'!setUp	server := Teapot on		GET: 'badrequest' -> [ :req | req abort: (ZnResponse badRequest: req) ];		GET: 'unauthorized' -> [ :req | req abort: TeaResponse unauthorized ];		GET: 'abortstring' -> [ :req | req abort: 'abort test' ];				start.! !!TeapotAbortTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	server stop! !!TeapotAbortTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testAbortSupportsAnyObject	self assert: (TeaTestClient httpGetString: '/abortstring') equals: 'abort test'.! !!TeapotAbortTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testErrorCodes	self assert: (TeaTestClient httpGet: '/badrequest') code equals: 400.	self assert: (TeaTestClient httpGet: '/unauthorized') code equals: 401.! !!TeapotAfterTest methodsFor: 'running' stamp: '3/1/2025 23:01'!setUp	server := Teapot on		after: '/after/<param>' -> [ :req :resp | resp headers at: 'header-key' put: (req at: #param) ];		GET: '/after/*' -> 'after-return';				start		! !!TeapotAfterTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	server stop! !!TeapotAfterTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testAfterFilterCanModifyResponse	| response |		response := TeaTestClient httpGet: '/after/header-value'.	self assert: response entity string equals: 'after-return'.	self assert: (response headers at: 'header-key') equals: 'header-value'.		response := TeaTestClient httpPost: '/after/notfound'.	self assert: response code equals: 404.	self assert: (response headers at: 'header-key') equals: 'notfound'.! !!TeapotBeforeTest methodsFor: 'private' stamp: '3/1/2025 23:01'!forbidden	^ ZnResponse new		statusLine: ZnStatusLine forbidden;		headers: ZnHeaders defaultResponseHeaders;		yourself! !!TeapotBeforeTest methodsFor: 'private' stamp: '3/1/2025 23:01'!logRequest: aTeaRequest	log add: (aTeaRequest at: #user)! !!TeapotBeforeTest methodsFor: 'running' stamp: '3/1/2025 23:01'!setUp	log := OrderedCollection new.	server := Teapot on		before: '/secure/*' -> [ :req | ((req at: #user) = 'admin' and: [ (req at: #pass) = '****' ]) 			ifFalse: [ req abort: self forbidden ] ];		before: '*' -> (Send message: #logRequest: to: self);		before: '*' -> 'any';		GET: '/secure' -> 'protected';		GET: '/secure/1/2/3' -> 'protected';		POST: '/public' -> 'public';		start		! !!TeapotBeforeTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	server stop! !!TeapotBeforeTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testAuthentication	self assert: (TeaTestClient httpGetString: '/secure?user=admin&pass=****') equals: 'protected'.	self assert: (TeaTestClient httpGetString: '/secure/1/2/3?user=admin&pass=****') equals: 'protected'.			self assert: (TeaTestClient httpGet: '/secure?user=user01&pass=****') code equals: 403.	self assert: (TeaTestClient httpGet: '/secure/1/2/3?user=user02&pass=****') code equals: 403.			self assert: (TeaTestClient httpPostString: '/public?user=any') equals: 'public'.! !!TeapotBeforeTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testMultipleBeforeHandlers	TeaTestClient httpGet: '/secure?user=admin&pass=****'.	TeaTestClient httpGet: '/secure/1/2/3?user=admin&pass=****'.		TeaTestClient httpGet: '/secure?user=user01&pass=****'. "403 before second filter"	TeaTestClient httpPost: '/public?user=pubuser'.					self assert: log asArray equals: #(admin admin pubuser).! !!TeapotDefaultFormatTest methodsFor: 'running' stamp: '3/1/2025 23:01'!setUp	server := (Teapot configure: { #defaultOutput -> #text })		GET: 'default' -> 'any';		GET: 'html' -> 'any'; output: #html;		start		! !!TeapotDefaultFormatTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	server stop! !!TeapotDefaultFormatTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testDefault	self 		assert: (TeaTestClient httpGet: '/default') contentType 		equals: ZnMimeType textPlain! !!TeapotDefaultFormatTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testOverride	self 		assert: (TeaTestClient httpGet: '/html') contentType 		equals: ZnMimeType textHtml! !!TeapotEncodingTest methodsFor: 'running' stamp: '3/1/2025 23:01'!setUp	server := Teapot on		GET: 'enc' -> (TeaResponse ok 								body: 'rvztr tkrfrgp'; 								charSet: 'iso-8859-2');		start! !!TeapotEncodingTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	server stop! !!TeapotEncodingTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testUserSpecifiedEncoding	| response |	response := TeaTestClient httpGet: '/enc'.	self 		assert: response entity string		equals: 'rvztr tkrfrgp'.			self 		assert: response contentType charSet		equals: 'iso-8859-2'! !!TeapotErrorHandlingTest methodsFor: 'private' stamp: '3/1/2025 23:01'!handleError: ex request: req	self assert: (ex isKindOf: Exception).	self assert: (req isKindOf: TeaRequest).	^ ZnResponse ok: (ZnStringEntity text: 'outofbounds/domainerror handled')! !!TeapotErrorHandlingTest methodsFor: 'running' stamp: '3/1/2025 23:01'!setUp	server := Teapot on		GET: '/zerodiv' -> [ 1 / 0 ];		GET: '/sub' -> [ #() at: 123 ];					GET: '/domain' -> [ -2 sqrt ];		GET: '/nonbool' -> [ NotYetImplemented signal ];		GET: '/keynotfound' -> [ KeyNotFound signal ];		exception: ZeroDivide -> [ :ex :req | 'zerodiv handled' ];		exception: SubscriptOutOfBounds, DomainError -> (Send message: #handleError:request: to: self);		exception: NotYetImplemented -> (ZnResponse ok: (ZnStringEntity text: 'nonbool handled'));		exception: KeyNotFound -> 42;		output: [ :resp :req | ZnResponse ok: (ZnStringEntity text: resp body printStringRoman) ];		start		! !!TeapotErrorHandlingTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	server stop! !!TeapotErrorHandlingTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testHandlesExceptionSet	self assert: (TeaTestClient httpGetString: '/sub') equals: 'outofbounds/domainerror handled'.		self assert: (TeaTestClient httpGetString: '/domain') equals: 'outofbounds/domainerror handled'.		! !!TeapotErrorHandlingTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testHandlesOneException	self assert: (TeaTestClient httpGetString: '/zerodiv') equals: 'zerodiv handled'.	! !!TeapotErrorHandlingTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testTransformingErroHandlerResponse	self assert: (TeaTestClient httpGetString: '/keynotfound') equals: 'XLII'.! !!TeapotErrorHandlingTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testValueAsExceptionHandler	self assert: (TeaTestClient httpGetString: '/nonbool') equals: 'nonbool handled'.	! !!TeapotFormParamsTest methodsFor: 'running' stamp: '3/1/2025 23:01'!setUp	server := Teapot on		POST: '/form' -> [ :req | (req at: #foo), '-', (req at: #bar) ];		exception: TeaNoSuchParam -> 'no such param';		start.! !!TeapotFormParamsTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	server stop! !!TeapotFormParamsTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testFormParams	| result |	result := ZnEasy post: 'http://localhost:1701/form' data: (ZnApplicationFormUrlEncodedEntity new 		at: 'foo' put: 'abc'; 		at: 'bar' put: '123'; 		yourself).	self assert: result entity string equals: 'abc-123'.! !!TeapotFormParamsTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testFormParamsNotFound	| result |	result := ZnEasy post: 'http://localhost:1701/form' data: (ZnApplicationFormUrlEncodedEntity new 		at: 'invalid1' put: 'abc'; 		at: 'invalid2' put: '123'; 		yourself).	self assert: result entity string equals: 'no such param'! !!TeapotFormatTest methodsFor: 'running' stamp: '3/1/2025 23:01'!setUp	server := Teapot on		GET: '/a' -> [ 4 ]; output: [ :resp :req | ZnResponse ok: (ZnStringEntity text: resp body printStringRoman) ];		GET: 'default' -> 'any';		GET: '/plain' -> 'any'; output: #text;		GET: 'xml' -> 'any'; output: (TeaOutput stringWithContentType: ZnMimeType applicationXml);		start		! !!TeapotFormatTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	server stop! !!TeapotFormatTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testArbitraryContentType	self 		assert: (TeaTestClient httpGet: '/xml') contentType 		equals: (ZnMimeType applicationXml charSet: 'utf-8'; yourself)! !!TeapotFormatTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testConverting	self assert: (TeaTestClient httpGetString: '/a') equals: 'IV'.	! !!TeapotFormatTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testDefaultContentTypeIsHtml	self 		assert: (TeaTestClient httpGet: '/default') contentType 		equals: ZnMimeType textHtml! !!TeapotFormatTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testSetsContentType	self 		assert: (TeaTestClient httpGet: '/plain') contentType 		equals: ZnMimeType textPlain! !!TeapotMessageSendTest methodsFor: 'web controller' stamp: '3/1/2025 23:01'!msg1	^ 'msg1 result'! !!TeapotMessageSendTest methodsFor: 'web controller' stamp: '3/1/2025 23:01'!msg2Req: req nil: resp	self assert: resp isNil.	^ 'msg2 ', (req at: #param)! !!TeapotMessageSendTest methodsFor: 'web controller' stamp: '3/1/2025 23:01'!msg3Req: req	^ 'msg3 ', (req at: #param)! !!TeapotMessageSendTest methodsFor: 'running' stamp: '3/1/2025 23:01'!setUp	server := Teapot on		GET: '/msg1' -> (Send message: #msg1 to: self);		GET: '/msg2/<param>' -> (Send message: #msg2Req:nil: to: self);				GET: '/msg3/<param>' -> (Send message: #msg3Req: to: self);							start.		! !!TeapotMessageSendTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	server stop! !!TeapotMessageSendTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testReceivingOneArgKeywordMessage	self assert: (TeaTestClient httpGetString: '/msg3/bar') equals: 'msg3 bar'.! !!TeapotMessageSendTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testReceivingTwoArgsKeywordMessage	self assert: (TeaTestClient httpGetString: '/msg2/foo') equals: 'msg2 foo'.! !!TeapotMessageSendTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testReceivingUnaryMessage	self assert: (TeaTestClient httpGetString: '/msg1') equals: 'msg1 result'.! !!TeapotPathParamTest methodsFor: 'running' stamp: '3/1/2025 23:01'!setUp	server := Teapot on		GET: '/user/<id>' -> [ :req | '1-', (req at: #id) ];		GET: '/user/<id>/create' -> [ :req | '2-', (req at: #id) ];		GET: '/<id>/<user>' -> [ :req | '3-', (req at: #id) ];						POST: '/user/<id>/create' -> [ :req | '4-', (req at: #id) ];		start.		! !!TeapotPathParamTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	server stop! !!TeapotPathParamTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testPlaceholderAtLast	self assert: (TeaTestClient httpGetString: '/user/12') equals: '1-12'	! !!TeapotPathParamTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testPlaceholderFirst	self assert: (TeaTestClient httpGetString: '/54/user') equals: '3-54'.	! !!TeapotPathParamTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testPlaceholderInside	self assert: (TeaTestClient httpGetString: '/user/34/create') equals: '2-34'.		! !!TeapotPathParamTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testPlaceholderPost	self assert: (TeaTestClient httpPostString: '/user/789/create') equals: '4-789'.		! !!TeapotQueryParamsTest methodsFor: 'running' stamp: '3/1/2025 23:01'!setUp	server := Teapot on		GET: '/query' -> [ :req | req at: #foo ];		GET: '/queryopt' -> [ :req | req at: #foo ifAbsent: [ 'default' ] ];				start! !!TeapotQueryParamsTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	server stop! !!TeapotQueryParamsTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testDefaultQueryParam	self assert: (TeaTestClient httpGetString: '/queryopt') equals: 'default'.	! !!TeapotQueryParamsTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testQueryParam	self assert: (TeaTestClient httpGetString: '/query?foo=bar') equals: 'bar'.	self assert: (TeaTestClient httpGetString: '/queryopt?foo=baz') equals: 'baz'.! !!TeapotRegexpTest methodsFor: 'running' stamp: '3/1/2025 23:01'!setUp	server := Teapot on		GET: '/./' asRegex -> [ 'regexp' ];		GET: '\w+(\d)/\d/xxx' asRegex -> [ :req | req at: 1 ];		GET: '/(\d)/([abc]+)/\d/(.*)' asRegex -> [ :req | (req at: 1), (req at: 2), (req at: 3) ];				start! !!TeapotRegexpTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	server stop! !!TeapotRegexpTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testCollectingSubexpressions	self assert: (TeaTestClient httpGetString: '/abc3/4/xxx') equals: '3'.		self assert: (TeaTestClient httpGetString: '/1/aabbcc/2/foobar') equals: '1aabbccfoobar'.! !!TeapotRegexpTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testIgnoresQueryParam	self assert: (TeaTestClient httpGetString: '/k/?param=value') equals: 'regexp'.	! !!TeapotRegexpTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testRegexpMatch	self assert: (TeaTestClient httpGetString: '/k/') equals: 'regexp'.	! !!TeapotResponseTest methodsFor: 'running' stamp: '3/1/2025 23:01'!setUp	server := Teapot on		GET: '/test400' -> [ 			TeaResponse badRequest				body: 'malformed input';				headers: { 'my-header' -> 'my-value' } ];		start! !!TeapotResponseTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	server stop! !!TeapotResponseTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testReturnsCustomCodeBodyAndHeaders	| response |	response := TeaTestClient httpGet: '/test400'.	self assert: response entity string equals: 'malformed input'.	self assert: response code equals: 400.	self assert: (response headers at: 'my-header') equals: 'my-value'.! !!TeapotReturnResponseTest methodsFor: 'running' stamp: '3/1/2025 23:01'!setUp	| stream |	stream := ZnStreamingEntity		readFrom: 'direct stream' readStream		usingType: ZnMimeType textHtml		andLength: 'direct stream' size.			server := Teapot on		GET: '/resp1' -> [ :req | ZnResponse ok: (ZnStringEntity text: 'direct response') ];		GET: '/resp2' -> (ZnResponse ok: stream);		GET: '/redirect' -> (ZnResponse redirect: '/redirect_location');		GET: '/redirect_location' -> 'redirected here';		start! !!TeapotReturnResponseTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	server stop! !!TeapotReturnResponseTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testDirectStreamResponse	self assert: (TeaTestClient httpGetString: '/resp2') equals: 'direct stream'.	! !!TeapotReturnResponseTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testDirectStringResponse	self assert: (TeaTestClient httpGetString: '/resp1') equals: 'direct response'.	! !!TeapotReturnResponseTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testRedirect	self assert: (TeaTestClient httpGetString: '/redirect') equals: 'redirected here'.	! !!TeapotRouteSetTest methodsFor: 'running' stamp: '3/1/2025 23:01'!setUp	server := Teapot on		before: { '/secure/*' . '/protected/*' } -> [ :req | req abort: TeaResponse unauthorized ];			GET: {'/a'. '/b'. '/c'} -> 'abc';		POST: { '/x/<param>'. '/y/<param>' } -> [ :req | req at: #param ];		after: { '/a'. '/b' } -> [ :req :resp | resp headers at: 'test' put: 'ab' ];		start.! !!TeapotRouteSetTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	server stop! !!TeapotRouteSetTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testMatchesAnyRouteInAfterFilter	| response |	response := TeaTestClient httpGet: '/a'.	self assert: (response headers at: 'test') equals: 'ab'.		response := TeaTestClient httpGet: '/b'.	self assert: (response headers at: 'test') equals: 'ab'.			response := TeaTestClient httpGet: '/c'.	self assert: (response headers at: 'test' ifAbsent: nil) equals: nil.! !!TeapotRouteSetTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testMatchesAnyRouteInBeforeFilter	| response |	response := TeaTestClient httpGet: '/secure/123'.	self assert: response code equals: 401.		response := TeaTestClient httpGet: '/protected/123'.	self assert: response code equals: 401.! !!TeapotRouteSetTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testMatchesAnyRouteInSet	self assert: (TeaTestClient httpGetString: '/a') equals: 'abc'.	self assert: (TeaTestClient httpGetString: '/b') equals: 'abc'.	self assert: (TeaTestClient httpGetString: '/c') equals: 'abc'.! !!TeapotRouteSetTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testMatchesAnyRouteInSetWithParams	self assert: (TeaTestClient httpPostString: '/x/value1') equals: 'value1'.	self assert: (TeaTestClient httpPostString: '/y/value2') equals: 'value2'.	! !!TeapotRoutingTest methodsFor: 'running' stamp: '3/1/2025 23:01'!setUp	| teapot |	teapot := Teapot configure: { #notFoundHandlerClass -> Tea405AwareNotFoundHandler }.	server := teapot		GET: '/' -> '1';		GET: '/a' -> '2';		POST: '/a' -> 'post';		GET: '/a/*/b' -> [ '3' ];		GET: '/*/c' -> [ '4' ];			GET: '/x/y/*' -> [ '5' ];		GET: '/x/*/*/z/*' -> [ '6' ];		GET: '/404' -> (ZnResponse notFound: '/custom');		any: 'any' -> 'any';		start.		! !!TeapotRoutingTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	server stop! !!TeapotRoutingTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!test404 	self assert: (TeaTestClient httpGet: '/1/2/3/4') code equals: 404! !!TeapotRoutingTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!test405	| response |	response := TeaTestClient httpDelete: '/a'.	self assert: response code equals: 405.	self 		assert: (', ' split: (response headers at: 'Allow')) asSet		equals: #(GET POST) asSet.! !!TeapotRoutingTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testAnyMatchesToAnyHttpMethod 	self assert: (TeaTestClient httpGetString: '/any') equals: 'any'. 	self assert: (TeaTestClient httpPostString: '/any') equals: 'any'. 	self assert: (TeaTestClient httpPutString: '/any') equals: 'any'.	 	self assert: (TeaTestClient httpDeleteString: '/any') equals: 'any'.! !!TeapotRoutingTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testCustom404 	self assert: (TeaTestClient httpGetString: '/404') equals: 'Not Found /custom', String crlf! !!TeapotRoutingTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testMultipleWildcard	self assert: (TeaTestClient httpGetString: '/x/foo/bar/z/baz') equals: '6'.	self assert: (TeaTestClient httpGetString: '/x/foo/bar/z/baz/123') equals: '6'.	! !!TeapotRoutingTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testNoWildcard	self assert: (TeaTestClient httpGetString: '') equals: '1'.	self assert: (TeaTestClient httpGetString: '/a') equals: '2'.		! !!TeapotRoutingTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testWildcardEnd	self assert: (TeaTestClient httpGetString: '/x/y/foo') equals: '5'.		! !!TeapotRoutingTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testWildcardFirst	self assert: (TeaTestClient httpGetString: '/foo/c') equals: '4'	! !!TeapotRoutingTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testWildcardInside	self assert: (TeaTestClient httpGetString: '/a/bar/b') equals: '3'	! !!TeapotSslTest methodsFor: 'private' stamp: '3/1/2025 23:01'!pemContent	^ String streamContents: [ :stream | 		{'-----BEGIN CERTIFICATE-----'.'MIICAzCCAWwCCQDqdNQzO71rWzANBgkqhkiG9w0BAQUFADBFMQswCQYDVQQGEwJB'.'VTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJuZXQgV2lkZ2l0'.'cyBQdHkgTHRkMCAXDTE3MDYyNDA4MDM1OVoYDzIxMTcwNTMxMDgwMzU5WjBFMQsw'.'CQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJu'.'ZXQgV2lkZ2l0cyBQdHkgTHRkMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDk'.'ysKeTfdTjx0l573Ag4ITy80env0TfKGdyjlHkehuzQBQsg+DiyQs2Ckr9GaaZIOe'.'BW/6btvHG51aGG+Fz2WtHY4MetyLJ/zy5PlzjOeGvRwAUwla0JZX8fB8poKgNXkm'.'gVeuCA3PKPnE6Ba1ucofvdtIsDMqpbABLMxdjhvagQIDAQABMA0GCSqGSIb3DQEB'.'BQUAA4GBAEf6vsOCHtWJT760Wdm606TWpY+EbxKdXViEtWaDT0K91HBrGqBnSvgC'.'1ByDRKz1L3UyfUjgaP04Iuy3aAUtUZ188A4YfC1XLcYln3K/3NNP4+S272R09Nne'.'kV7vvJt4I8vubjEo3Ihassy4PVTwcf6JnUBIdK7p4k+yAupHjzof'.'-----END CERTIFICATE-----'.'-----BEGIN RSA PRIVATE KEY-----'.'MIICXQIBAAKBgQDkysKeTfdTjx0l573Ag4ITy80env0TfKGdyjlHkehuzQBQsg+D'.'iyQs2Ckr9GaaZIOeBW/6btvHG51aGG+Fz2WtHY4MetyLJ/zy5PlzjOeGvRwAUwla'.'0JZX8fB8poKgNXkmgVeuCA3PKPnE6Ba1ucofvdtIsDMqpbABLMxdjhvagQIDAQAB'.'AoGAG501XDIA1f8B/5820dONkaIZgcaiuQVj5E2SGEdODIGFtjenk7LpjNgSMBHx'.'iFT1Zc82Mr3KnP+CQGuOmlHr7XylvmFM29x/cLd4HSvZNdg6pMrzuv/ILC27GLfU'.'gDGAVmyeBiyMTOLk6TJ/LElIrt+HABaHaa43XH/mF3VjAoECQQDzc3aDXCOOBvlA'.'mV3TgMEIuP9vEq5dgdz7bYZSVutc605AYo/1c9TkmlMy722/abQm0IpT1XRNjTmc'.'HT+Y5gb5AkEA8JXcGS9T0L5Vl2cel9wiad5oNbLGfG17nQQUl3LXikfPrcBGDmD4'.'aoEZkScPx3gKfawwKw8wsUwus30aWZapyQJBAJ5IqftKQsuq+Q/pJznGcrsrHNio'.'urmNH5JRaY3LeYeWbfAqpRKfVwGy3Pk29pIHNdwupmFPXSi284fu9FSC6nECQQDV'.'w+IPwpyPcj7syuRE/ITbWpFvfQydjE30YqbFNnZLWKkv8hKNPh4by9/iuDlt+7we'.'k/ssl0+liVJJixP5nEP5AkB8dFXPvAsxeTHCPMwAsJlPnxRodktuY7SlEUqqEpex'.'yxwciD3/Fyai686sj5iYiOuy2xcxaFZvJ1K1J/aCvwhK'.'-----END RSA PRIVATE KEY-----'.} do: [ :line | stream nextPutAll: line; crlf ]]! !!TeapotSslTest methodsFor: 'private' stamp: '3/1/2025 23:01'!pemFile	^ FileLocator temp asFileReference / 'test-teapot-ssl.pem'! !!TeapotSslTest methodsFor: 'initialization' stamp: '3/1/2025 23:01'!setUp	self writeOutPemTo: self pemFile.	teapot := Teapot configure: { 		#znServer -> (			(ZnSecureServer on: 1443) 				certificate: self pemFile fullName;				yourself).	}.	teapot		GET: '/ssl' -> 'secure';		start.! !!TeapotSslTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	teapot stop.	self pemFile delete.! !!TeapotSslTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testHttpsGet	self skip.	"| result |	result := ZnEasy get: 'https://localhost:1443/ssl'.	self assert: result equals: 'secure'."! !!TeapotSslTest methodsFor: 'private' stamp: '3/1/2025 23:01'!writeOutPemTo: aFileReference	aFileReference writeStreamDo: [ :stream | stream nextPutAll: self pemContent ]! !!TeapotStaticFilesTest methodsFor: 'private' stamp: '3/1/2025 23:01'!createTempHtdocs	| tmpHtdocs |	tmpHtdocs := FileLocator temp asFileReference / 'test_htdocs'.	tmpHtdocs createDirectory.	tmpHtdocs / 'index.html' writeStreamDo: [ :stream | stream nextPutAll: 'static index' ].	tmpHtdocs / 'a.txt' writeStreamDo: [ :stream | stream nextPutAll: 'a' ].	tmpHtdocs / 'b.txt' writeStreamDo: [ :stream | stream nextPutAll: 'static' ].	^ tmpHtdocs! !!TeapotStaticFilesTest methodsFor: 'running' stamp: '3/1/2025 23:01'!setUp	htdocs := self createTempHtdocs.	server := Teapot on		GET: 'here/are/statics/b.txt' -> 'dynamic';		serveStatic: 'here/are/statics' from: htdocs;		start! !!TeapotStaticFilesTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	htdocs deleteAll.	server stop.! !!TeapotStaticFilesTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testDynamicContentServedBeforeStatic	self assert: (TeaTestClient httpGetString: '/here/are/statics/b.txt') equals: 'dynamic'.	! !!TeapotStaticFilesTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testStaticFile	self assert: (TeaTestClient httpGetString: '/here/are/statics/a.txt') equals: 'a'.	! !!TeapotStaticFilesTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testStaticIndexHtml	self assert: (TeaTestClient httpGetString: '/here/are/statics') equals: 'static index'.	! !!TeapotStaticFilesTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testStaticNotFound	self assert: (TeaTestClient httpGet: '/here/are/statics/notfound.txt') code equals: 404.	! !!TeapotStreamingTest methodsFor: 'private' stamp: '3/1/2025 23:01'!content	^ (ByteArray new: 4096 withAll: 65) asString! !!TeapotStreamingTest methodsFor: 'private' stamp: '3/1/2025 23:01'!createDownloadableFile	| file |	file := FileLocator temp asFileReference / 'download.file'.	file writeStreamDo: [ :stream | stream nextPutAll: self content ].	^ file! !!TeapotStreamingTest methodsFor: 'private' stamp: '3/1/2025 23:01'!deleteDownloadableFile	downloadFile delete! !!TeapotStreamingTest methodsFor: 'running' stamp: '3/1/2025 23:01'!setUp	downloadFile := self createDownloadableFile.	server := Teapot on		GET: '/stream' -> downloadFile readStream;		output: #stream;		start! !!TeapotStreamingTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	self deleteDownloadableFile.	server stop.! !!TeapotStreamingTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testStreamingContent	self 		assert: (TeaTestClient httpGet: '/stream') contents asString 		equals: self content	! !!TeapotTeaResponseTest methodsFor: 'running' stamp: '3/1/2025 23:01'!setUp	server := Teapot on		GET: '/ok' -> (TeaResponse ok body: 'tested ok');		GET: '/badrequest' -> [:req | TeaResponse badRequest body: 'Bad Request'];		GET: '/created' -> [:req | TeaResponse created body: 'Created'; location: req url];		GET: '/notallowed' -> [:req | TeaResponse methodNotAllowed ];		GET: '/notfound' -> [:req | TeaResponse notFound ];		GET: '/notmodified' -> [:req | TeaResponse notModified ];		GET: '/redirect' -> (TeaResponse redirect location: '/target');		GET: '/servererror' -> (TeaResponse serverError body: 'tested server error');		GET: '/unauthorized' -> (TeaResponse unauthorized body: 'Unauthorized'; headerName: 'WWW-Authenticate' value: 'tested unauthorized');		start! !!TeapotTeaResponseTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	server stop.! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testBadRequest	| response |	response := TeaTestClient httpGet: '/badrequest'.	self assert: response code equals: 400.	self assert: response entity string equals: 'Bad Request'! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testCreated	| response |	response := TeaTestClient httpGet: '/created'.	self assert: response code equals: 201.	self assert: response entity string equals: 'Created'.	self assert: (response headers at: 'Location') equals: '/created'.! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testMethodNotAllowed	| response |	response := TeaTestClient httpGet: '/notallowed'.	self assert: response code equals: 405.! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testNotFound	| response |	response := TeaTestClient httpGet: '/notfound'.	self assert: response code equals: 404.! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testNotModified	| response |	response := TeaTestClient httpGet: '/notmodified'.	self assert: response code equals: 304.! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testOk	| response |	response := TeaTestClient httpGet: '/ok'.	self assert: response code equals: 200.	self assert: response entity string equals: 'tested ok'.! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testRedirect	| response |	response := TeaTestClient httpGetNoRedirect: '/redirect'.	self assert: response code equals: 302.	self assert: (response headers at: 'Location') equals: '/target'.! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testServerError	| response |	response := TeaTestClient httpGet: '/servererror'.	self assert: response code equals: 500.	self assert: response entity string equals: 'tested server error'! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testUnauthorized	| response |	response := TeaTestClient httpGet: '/unauthorized'.	self assert: response code equals: 401.	self assert: response entity string equals: 'Unauthorized'.	self assert: (response headers at: 'WWW-Authenticate') equals: 'tested unauthorized'.! !!TeapotWhenClauseTest methodsFor: 'running' stamp: '3/1/2025 23:01'!setUp	server := Teapot on		any: '/when' -> 'get'; when: [:req | req method = 'GET'];		any: '/when' -> 'post'; when: [:req | req method = 'POST'];		any: '/when/<p>' -> 'param-dispatch'; when: [:req | (req at: #p) = 'pval'];		any: '/when' -> 'unfiltered';		any: '/never' -> 'never match'; when: [ false ];		before: '/*' -> [:req | 			req abort: (TeaResponse ok body: 'before') ]; 			when: [:req | req relativeUrl path = 'beforeurl' ];		after: '/*' -> [:req :resp | 			resp statusLine: ZnStatusLine ok. 			resp entity: (ZnStringEntity text: 'after') ]; 			when: [:req | req relativeUrl path = 'afterurl' ];		start! !!TeapotWhenClauseTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	server stop! !!TeapotWhenClauseTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testDispatchesOnMethodInWhenFilter	self 		assert: (TeaTestClient httpGetString: '/when') 		equals: 'get'.		self 		assert: (TeaTestClient httpPutString: '/when/pval') 		equals: 'param-dispatch'.	self 		assert: (TeaTestClient httpPostString: '/when') 		equals: 'post'.	self 		assert: (TeaTestClient httpDeleteString: '/when') 		equals: 'unfiltered'.			self assert: (TeaTestClient httpGet: '/never') isNotFound.! !!TeapotWhenClauseTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testWhenClauseWithBeforeAfterFilter	self 		assert: (TeaTestClient httpGetString: '/beforeurl') 		equals: 'before'.	self 		assert: (TeaTestClient httpGetString: '/afterurl') 		equals: 'after'.! !!TeapotWithTypeConstraintTest methodsFor: 'running' stamp: '3/1/2025 23:01'!setUp	server := Teapot on		GET: '/u/<identifier:IsUUID>/more' -> [ :req | (req at: #identifier) asString ];		GET: '/u' -> 'no uuid';		GET: '/u/<identifier:IsUUID>' -> [ :req | (req at: #identifier) asString36  ];				start! !!TeapotWithTypeConstraintTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	server stop! !!TeapotWithTypeConstraintTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testNoParams	self 		assert: (TeaTestClient httpGetString: '/u') 		equals: 'no uuid'.	! !!TeapotWithTypeConstraintTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testParseTypeConstraint	self 		assert: (TeaTestClient httpGetString: '/u/964d5d07-1834-0d00-a106-47ae08909eb2') 		equals: (UUID fromString: '964d5d07-1834-0d00-a106-47ae08909eb2') asString36.	! !!TeapotWithTypeConstraintTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testParseTypeConstraint2	self 		assert: (TeaTestClient httpGetString: '/u/964d5d07-1834-0d00-a106-47ae08909eb2/more') 		equals: '964d5d07-1834-0d00-a106-47ae08909eb2'.	! !!TeaTestClient class methodsFor: 'private' stamp: '3/1/2025 23:01'!httpDelete: aString	^ ZnEasy delete: 'http://localhost:1701', aString	! !!TeaTestClient class methodsFor: 'private' stamp: '3/1/2025 23:01'!httpDeleteString: aString	^ ZnClient new		url: 'http://localhost:1701', aString;		delete	! !!TeaTestClient class methodsFor: 'private' stamp: '3/1/2025 23:01'!httpGet: aString	^ ZnEasy get: 'http://localhost:1701', aString	! !!TeaTestClient class methodsFor: 'private' stamp: '3/1/2025 23:01'!httpGetNoRedirect: aString	^ ZnClient new		followRedirects: false;		get: 'http://localhost:1701', aString;				response	! !!TeaTestClient class methodsFor: 'private' stamp: '3/1/2025 23:01'!httpGetString: aString	^ (self httpGet: aString) entity string	! !!TeaTestClient class methodsFor: 'private' stamp: '3/1/2025 23:01'!httpPost: aString	^ ZnEasy post: 'http://localhost:1701', aString data: (ZnEntity text: 'any')	! !!TeaTestClient class methodsFor: 'private' stamp: '3/1/2025 23:01'!httpPostString: aString	^ (self httpPost: aString) entity string	! !!TeaTestClient class methodsFor: 'private' stamp: '3/1/2025 23:01'!httpPut: aString	^ ZnEasy put: 'http://localhost:1701', aString data: (ZnEntity text: 'any')	! !!TeaTestClient class methodsFor: 'private' stamp: '3/1/2025 23:01'!httpPutString: aString	^ (self httpPut: aString) entity string	! !"Teapot-Tests"!!BaselineOfTealight commentStamp: '' prior: 0!A baseline for Tealight project!!BaselineOfTealight methodsFor: 'baseline' stamp: '3/1/2025 23:01'!baseline: spec	<baseline>	spec for: #common do: [ 		spec			baseline: 'Teapot' with: [ 				spec					repository: 'github://zeroflag/Teapot:master/source';					loads: #( 'Development' ) ];			import: 'Teapot'.		spec			package: 'Tealight-Web-Tools'			with: [ spec requires: #( 'Teapot' ) ].		spec			package: 'Tealight-Web-Tools-Tests'			with: [ spec requires: #( 'Tealight-Web-Tools' ) ].		spec			group: 'Tools' with: #( 'Tealight-Web-Tools' );			group: 'Tests' with: #( 'Tealight-Web-Tools-Tests' );			group: 'all' with: #( 'Tests' );			group: 'default' with: #( 'all' ) ]! !"BaselineOfTealight"!!TLDesktopMenu commentStamp: '' prior: 0!Desktop menu!!TLIconCache commentStamp: '' prior: 0!Utility class for caching icons (preventing unnnecessary instances of Forms). !!TLRESTAPIBuilder commentStamp: '' prior: 0!A simple utility class to build a REST API from methods!!TLVersionedRESTAPIBuilder commentStamp: '' prior: 0!An API builder for a versioned REST API!!TLRESTApiURLPathBuilder commentStamp: '' prior: 0!Utility class to build the REST API URL pathThe path is built from   - an optional API prefix  - an optional version  - the actual path  !!TLWebserver commentStamp: '' prior: 0!The Tealight server!!TLDesktopMenu class methodsFor: 'private - accessing' stamp: '3/1/2025 23:01'!mainMenuSymbol	^ #Tealight! !!TLDesktopMenu class methodsFor: 'world menu' stamp: '3/1/2025 23:01'!menuCommandOn: aBuilder 	<worldMenu>		| parent |	parent := self mainMenuSymbol.	(aBuilder item: parent)		order: 3.0; 	 		icon: (TLIconCache appIcon).	aBuilder withSeparatorAfter				 ! !!TLDesktopMenu class methodsFor: 'world menu' stamp: '3/1/2025 23:01'!serverMenuCommandOn: aBuilder	<worldMenu>	| parent |	parent := self mainMenuSymbol.	(aBuilder item: #Webserver)		parent: parent;		order: 2;		icon: TLIconCache serverIcon.	(aBuilder item: #'Start webserver')		parent: #Webserver;		icon: TLIconCache serverStartIcon;		action: [ TLWebserver start ].	(aBuilder item: #'Stop webserver')		parent: #Webserver;		icon: TLIconCache serverStopIcon;		action: [ TLWebserver stop ].	aBuilder withSeparatorAfter.	(aBuilder item: #'Browse webserver')		parent: #Webserver;		icon: TLIconCache serverIcon;		action: [ TLWebserver openWebbrowser ]! !!TLIconCache class methodsFor: 'icons' stamp: '3/1/2025 23:01'!appIcon	<script: 'self appIcon inspect'>	^ self iconNamed: #appIcon! !!TLIconCache class methodsFor: 'private - icons' stamp: '3/1/2025 23:01'!appIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABs0lEQVR42mNkIAJ0rzj4/+GjKwx8AtIMbWkBjMhyjMQYsGTWrP/RzhwMt84/Z3ipHMZgZ6jISLQBR87d+/9o6UwG7V8PGF7/ZGV47JzMkBjuSLwBq3ec+f+2MpaBi/EfA8P/fwxfsvsYslJ8iTPg0Nk7//dt2cPAsWk6g8C/HwxvP3xi+B9awGDq68XgbqvLSNCAHUeu/t9QU8Eg+eIqwz82DobvLx4z/FY1Y3Brn8DgaUeEASCwds/F/7sbShn+P7vD8FPLlsEzO5ch3NOE+DBonbrh/4VNqxl0PP0ZvFwsGEx15EiLxsbZu/4bqUkx6KtKMRy5cJfh4r2XDJ05PsS7ABwWx278X739JMPFI4cZFLR1GNZMKSDegP7lR/7PX3+U4d+PrwwGusoMmSG2DNaGSsQboJO98r+aEDNDpIMaQ6izHoZ6vAbsP3vv/7l7bxiKQ83g6rKmHfrvZyzJ4GGuSlw0wkDXmtP/1z/8y/DoHw9DhyEDQ6yLDnEG9G268H/5K1aGRxxCDAx//jLofX/JsDvTmLgwqFt74f9MBlkGxh8/GHR/vGbwFvnHUOBvhKIHACf7oBFVIpg+AAAAAElFTkSuQmCC'! !!TLIconCache class methodsFor: 'generate' stamp: '3/1/2025 23:01'!generateIcon	<script>		| base64Contents fileName contentsMethod iconMethod iconName |  	fileName := UIManager default chooseFullFileNameMatching: #('png') label: 'Icon file'.	fileName ifNil: [ ^ self ].	iconName := UIManager default request: 'Icon name' initialAnswer: 'blank'.	iconName ifNil: [ ^ self ].	base64Contents := (Base64MimeConverter mimeEncode: fileName binary) contents.	fileName close.	contentsMethod := String		streamContents: [ :s | 			s				nextPutAll: iconName;				nextPutAll: 'IconContents';				cr;				cr;				tab;				nextPut: $^;				nextPut: $';				nextPutAll: base64Contents;				nextPut: $' ].	iconMethod := String		streamContents: [ :s | 			s				nextPutAll: iconName;				nextPutAll: 'Icon';				cr;				tab;				nextPutAll: '<script: ''self ';				nextPutAll: iconName;				nextPutAll: 'Icon';				nextPutAll: ' inspect''>';				cr;				cr;				tab;				nextPutAll: '^ self iconNamed: #';				nextPutAll: iconName;				nextPutAll: 'Icon' ].	self class compile: contentsMethod classified: #'private - icons'.	self class compile: iconMethod classified: #icons! !!TLIconCache class methodsFor: 'private - accessing' stamp: '3/1/2025 23:01'!iconCache	^ IconCache ifNil: [ IconCache := Dictionary new ]! !!TLIconCache class methodsFor: 'accessing' stamp: '3/1/2025 23:01'!iconNamed: aSymbol	"Returns the icon with the given name"	(self class canUnderstand: aSymbol) ifFalse: [ ^super iconNamed: aSymbol ].	^ self iconCache		at: aSymbol		ifAbsentPut: [ 			Form				fromBinaryStream: (self perform: (aSymbol , 'Contents') asSymbol) base64Decoded readStream ]! !!TLIconCache class methodsFor: 'initialization-release' stamp: '3/1/2025 23:01'!reset	"Reset the icon cache"		<script>		IconCache := nil! !!TLIconCache class methodsFor: 'icons' stamp: '3/1/2025 23:01'!serverIcon	<script: 'self serverIcon inspect'>	^ self iconNamed: #serverIcon! !!TLIconCache class methodsFor: 'private - icons' stamp: '3/1/2025 23:01'!serverIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC0UlEQVR4Xo2SbU+SURzG+RS2hDdufQBtM0e58GHa8o2W3mbWkjbLhzURTTNEHnwowNKG2oM6JUWF2+fHTJ2aJaFCPlAzJygGOMPM8qF8wqtbXli2rK7t2v7n7Fy/c8520fbk4nKEkZkpIUViKckXSEj9qBEjehNG3kxDILxLenoyCVdXVwbtMHl7s4hJ4ypsi1uUHbDad2Fz2kGtd2G2bWBIZ0Jz6wvLHtDL69RBIIvlS2hGFqEbW4FhcgWmuU0YzduYNu9QswOmDw7MWhwUaAe2Tw7M29dxIyGV3Af4+voR3X1mDAwuoLd/Hl09c9Q8D/34MgVcxYz1O+yft2Ff3sTYWxvKK/oRxU44CGhpe4/Orlm0tk+joWkS6toJ1KhHoax5jdLyPsgLn0GUrUZMnBTnw64jPj7lIEBNjqK+8R1U5DiU1XqUP9WitGwQfEEJMgRS5D8ohrJKjampKQhF9+HjG8j9BeBPlCk0qFDqUKbQ4knJSzwsom6Vd1N/lcJgMGBraxvf1jfw5es64mJvwfMEk9gHBAaeIeQFXXhcPIDCwl7k5z9HrqwDUkkL2Ox0aLXDWFvbwsLCMmZm7QgJYeNsUNBPgLu7B1MirUdeXidk0nbkZDdBLKqjXIuIiBS0tXXBal2C0bSEVxoTgoOjQGfQD/YiLU1MioQqZ1AoUEOQoYZISCI8PBnVNc2YMFiocpnR1jEM9lUO/lioa9FJZDqvygnYsxNwIQmKikYqbMGAZgbquh4kcsU4tJUyWYklg6/aBxDhXBQ9UkE3/hGDQzNIThUg5BxbcyjgKFVRHk9uEWSonIAwgoukm3eo0CW4uR1DQEAktRdN0v4md4/jTA4n17L3ipjYe2D5ROK0z0VcTuSBL6zElajYPNq/5OcfQGRlKZHAKaLal4/bPAXkBa3IypZr6HQ6g/Y/8vI6SVRW9qChUYPsnCJNaGgE9/czPwCyhvLlWzqQAwAAAABJRU5ErkJggg=='! !!TLIconCache class methodsFor: 'icons' stamp: '3/1/2025 23:01'!serverStartIcon	<script: 'self serverStartIcon inspect'>		^ self iconNamed: #serverStartIcon! !!TLIconCache class methodsFor: 'private - icons' stamp: '3/1/2025 23:01'!serverStartIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADR0lEQVR4Xn2T71fTZRyG+S804RV56k3Hc6jciTpHICnNOnVYfCWhCZiiCAxGlEbbhCg2TjQdIYlCwWIIU0crDhAiiOA8xL6B4kFqG7+22QYRHCL5Nbia7ByOnNPpc859zvPmup7nOef+hDw5JzOydQWfaU0qtdYkDjro/9VJv2in8lKdVaMtNUkkksiQ/xtr3ygu3yqe6TU8U4+zHjgHM/FwmT5xFMtP3S71GY1JocjT7dgRGrZF0NH1O+LdBe7en8c+tohzfBXHmB/HhB/n5BpjrkA8fh4GLnB7/0aRm2/aImhpG6LH6qOz20N7xwQ3ezzYBv/i3vBCAF7CN7PK1NwyA0Muqr69wcmMj7cKmiw22q6P09xip8nyANPVIeobBqhv/IXq7zopK2+l4PNG0k5oiBfSSUxM1W0RNDRaMf8wTOOVe9TVi9QY+rhY1UthkQGlUsPZc5UYjSbsdgenPikmIkIibMK7JS9G5p0vIfF8Dqll+ZRUmKmouIlef52c3HOINhsrKys8+meZ2dkFUlKziY19LSiQ7JUIh5vep2SgmNbJFgy/1XC09SgHNXI0xRbSjmvo6uxiIQB7vbPYHX8glaYSFxcnhGx7altYglmgxl5Ns+tHFlcfMTI3TJ2zluzeLA4pPyLlSCENDddwu2dwOP+kq/tB4P/pbNwe/UGU7thtGbXOSuaX51hfX9+IdfoW+pESdpdHkpx6hksXjQzdn6TfNo7Z0kumXBUUPK/YZZKLR5ha9G7Cj+Nf82NxX+E5YziyFCXlFbXYRDc9t0epu9yCUlUaFLycJzEliq9TMfkF7TPmALyGb9nDhUkN6hE5uy4/TVLyp3xZWoU46KM30FZ5zile3SsNdkCaJdW9eecF0u1vUT+t3xC4lhx86BQ4OPgKMd/EIktWkZmlJu5dGeHhO9m3T4bscEZQEBoWGpbbeZwi1zF+nq8LvmBlgq+8uSTciiFNpSUzs4zomCT2RL9HUk4+6oLv2f/GO4rNDhx4+4CQcTXFVTRygralKmqnNMithyisLrBqtUYUiguB9p3ldH4N+q+bAxU+bfrPbYzaHyVsj9guPBv5jCB5Kbi6UXtiBIOhnWvmO3TcsBEfn6B4kvkXxV9YN+ClYBQAAAAASUVORK5CYII='! !!TLIconCache class methodsFor: 'icons' stamp: '3/1/2025 23:01'!serverStopIcon	<script: 'self serverStopIcon inspect'>	^ self iconNamed: #serverStopIcon! !!TLIconCache class methodsFor: 'private - icons' stamp: '3/1/2025 23:01'!serverStopIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADQ0lEQVR4Xn2Ta0zTVxiHG+GDprilxuhGCH5RYrJsxokGvI24DBJmYLBWQDrYZthGwka5VNFkCIFMN7WbFVfhr4ZIVWyV1V28Z8oGlbXjzrLBWumFiy24xa4rkVKe/R3T2SzZmzx5v5z3OTnn/I7kydq4cbNm2zalQS7PNXT22LF22bF02dhVUWVev36TJjo6WiH5v2rrsOP2BBmbmGHUM8uo9xEhRjwz/NjjxNpp43X5dsPDzaKiohLDBNe/HaSrz0/PwH2GhgPYHTPYhkPYnSKuWe64QgyPzIiyEJ7fHnDlWjthgm8u9/O92cvN1jGu3XBx8zu3eIx79A78gc05xfhEkMn7QQbtE1wwWdDVm8IFLSYrV687+fqSjS8u/oLhfD9nmrtpNloRGm9Rd+wqtfuNFKuOkJVTREqK3BwmONPcTovpZ84Z+zh9tovGUxaEE+0crrvE+x/s4ZDmGCdPNmGxWNHrz7JuXZLh8XBkZGSM8Nk56qsbaThkouF4G5/rbnFYe4Oaj5ppatIzPR1kauoBPl+AAweOsGVL6pzgueXLS7Ryhft2TQ0/NdTTUVuLPr+Q/bsE9u37kordJ6g7qiMQmMbr9eFyTaIqqSQtLdMgeXbJEsXl3FzsgvCYO//0lswsKlU6du4U2Lu3hpHRSRyu3+nqvUuusgiZbJFCok1Lc/eVlTNUVcWvTzAoMlBRwSdrUygvb0Ct/pD+ATed3Q7xZUZ5dauSpUufUUhMLzyP3+kg6PeL/BnWp/0+Tq/dQJkoKFbtobt3jNY2O+237aSmbiciMiJG8lVcHIGxMUKzof8SCnF+TQKlZTreK1TTYXWLIbvHxwfrycsvmstAa04OQ0lJuNPTuKtU4s3PY1z5Bo701xhMTkZYvZmSUh1Z2e/w1o5i4lasJCExmepqYU6weOFCxQ+yRbhiY/GIeJctY1zswyLmp56mMr9KvAOBl195k00vZSEvLKG49Chv71D9G6IVMllJb3w8/vR0pvLy8GVk0LMmnt0ZmWat1ki5WqDgXQ1l6uMc/PSiuLvWLZVKwz+SdMGCxOzVLxqyY2MN2atWGaTz5/+9YN68iJhT+isYL7RRUFBqTkjYoHkYukdzfwGRNFI+0JfMpQAAAABJRU5ErkJggg=='! !!TLRESTAPIBuilder class methodsFor: 'accessing' stamp: '3/1/2025 23:01'!allPragmas	"Return a collection of all the REST API pragmas"		^ (PragmaCollector selectors: {self pragmaKeyword}) pragmas! !!TLRESTAPIBuilder class methodsFor: 'building' stamp: '3/1/2025 23:01'!buildAPI	"Build the API from the receiver and subclasses"	<script>		self buildAPIFor: self teapotRefreshed! !!TLRESTAPIBuilder class methodsFor: 'building' stamp: '3/1/2025 23:01'!buildAPIFor: aTeapot	"Build the API from the receiver and subclasses"	<script>	self withAllSubclassesDo: [ :each | (each on: aTeapot) build ]! !!TLRESTAPIBuilder class methodsFor: 'instance creation' stamp: '3/1/2025 23:01'!on: aTeapot	^ self new teapot: aTeapot; yourself! !!TLRESTAPIBuilder class methodsFor: 'accessing' stamp: '3/1/2025 23:01'!pragmaKeyword	"Return the Pragma keyword that is used to define a REST API"		^#REST_API:pattern:! !!TLRESTAPIBuilder class methodsFor: 'accessing' stamp: '3/1/2025 23:01'!teapot	^TLWebserver teapot! !!TLRESTAPIBuilder class methodsFor: 'accessing' stamp: '3/1/2025 23:01'!teapotRefreshed	^TLWebserver teapotRefreshed ! !!TLRESTAPIBuilder methodsFor: 'accessing' stamp: '3/1/2025 23:01'!allPragmas		^ self class allPragmas! !!TLRESTAPIBuilder methodsFor: 'building' stamp: '3/1/2025 23:01'!build	"Build a regular API (unversioned) by installing a teapot route for each pragma definition"	self allPragmas do: [ :each | 		self			installHook: each arguments first			path: (self pathFromPragma: each)			pragma: each ]! !!TLRESTAPIBuilder methodsFor: 'installing' stamp: '3/1/2025 23:01'!installHook: httpMethod path: aPath pragma: aPragma	"Install a dynamic route as a hook in the current teapot"	| action route |	action := Send		          message: aPragma methodSelector		          to: aPragma method methodClass instanceSide.	route := aPath -> action.	self teapot perform: (httpMethod , ':') asSymbol with: route! !!TLRESTAPIBuilder methodsFor: 'private - factory' stamp: '3/1/2025 23:01'!newPathBuilder	^ TLRESTApiURLPathBuilder new! !!TLRESTAPIBuilder methodsFor: 'private - utilities' stamp: '3/1/2025 23:01'!pathFromPragma: aPragma	^(self newPathBuilder)						function: aPragma arguments second;			path! !!TLRESTAPIBuilder methodsFor: 'accessing' stamp: '3/1/2025 23:01'!pragmaKeyword	^ self class pragmaKeyword! !!TLRESTAPIBuilder methodsFor: 'accessing' stamp: '3/1/2025 23:01'!teapot	^ teapot! !!TLRESTAPIBuilder methodsFor: 'accessing' stamp: '3/1/2025 23:01'!teapot: anObject	teapot := anObject! !!TLVersionedRESTAPIBuilder class methodsFor: 'accessing' stamp: '3/1/2025 23:01'!pragmaKeyword	"Return the Pragma keyword that is used to define a versioned REST API"		^#REST_API:versions:pattern:! !!TLVersionedRESTAPIBuilder methodsFor: 'building' stamp: '3/1/2025 23:01'!build	"Build a regular API (unversioned) by installing a teapot route for each pragma definition"	self allPragmas do: [ :each | 			each arguments second do: [:version |				self installHook: each arguments first path: (self pathFromPragma: each version: version) pragma: each ] ]! !!TLVersionedRESTAPIBuilder methodsFor: 'private - utilities' stamp: '3/1/2025 23:01'!pathFromPragma: aPragma	^(self newPathBuilder)						version: aPragma arguments second;			function: aPragma arguments third;			path! !!TLVersionedRESTAPIBuilder methodsFor: 'private - utilities' stamp: '3/1/2025 23:01'!pathFromPragma: aPragma version: aVersion	^(self newPathBuilder)						version: aVersion;			function: aPragma arguments third;			path! !!TLRESTApiURLPathBuilder class methodsFor: 'accessing' stamp: '3/1/2025 23:01'!apiPrefix	"Return the API prefix"		^APIPrefix ! !!TLRESTApiURLPathBuilder class methodsFor: 'class initialization' stamp: '3/1/2025 23:01'!initialize	"initializes the receiver"		self useStandardPrefix! !!TLRESTApiURLPathBuilder class methodsFor: 'actions' stamp: '3/1/2025 23:01'!useAPIPrefix: aString	"Use the given string as API prefix"		APIPrefix := aString! !!TLRESTApiURLPathBuilder class methodsFor: 'actions' stamp: '3/1/2025 23:01'!useStandardPrefix	"Use the standard API prefix"		APIPrefix := 'api'! !!TLRESTApiURLPathBuilder class methodsFor: 'actions' stamp: '3/1/2025 23:01'!withoutPrefix	"Do not use any prefix"			APIPrefix := ''! !!TLRESTApiURLPathBuilder methodsFor: 'accessing' stamp: '3/1/2025 23:01'!apiPrefix	^ apiPrefix! !!TLRESTApiURLPathBuilder methodsFor: 'accessing' stamp: '3/1/2025 23:01'!apiPrefix: anObject	apiPrefix := anObject! !!TLRESTApiURLPathBuilder methodsFor: 'accessing' stamp: '3/1/2025 23:01'!function	^ function! !!TLRESTApiURLPathBuilder methodsFor: 'accessing' stamp: '3/1/2025 23:01'!function: anObject	function := anObject! !!TLRESTApiURLPathBuilder methodsFor: 'initialization' stamp: '3/1/2025 23:01'!initialize	"Initializes the receiver"	super initialize.	apiPrefix := self class apiPrefix.	version := String empty.	function := String empty.! !!TLRESTApiURLPathBuilder methodsFor: 'accessing' stamp: '3/1/2025 23:01'!path	^String streamContents: [:s | 		self 			write: self apiPrefix on: s;			write: self version on: s;			write: self function on: s	 ].! !!TLRESTApiURLPathBuilder methodsFor: 'accessing' stamp: '3/1/2025 23:01'!version	^ version! !!TLRESTApiURLPathBuilder methodsFor: 'accessing' stamp: '3/1/2025 23:01'!version: anObject	version := anObject! !!TLRESTApiURLPathBuilder methodsFor: 'private  - writing' stamp: '3/1/2025 23:01'!write: part on: aStream	part isEmpty ifTrue: [ ^self ].	(part beginsWith: '/')		ifFalse: [ aStream nextPut: $/ ].	aStream nextPutAll: part	! !!TLWebserver class methodsFor: 'defaults' stamp: '3/1/2025 23:01'!defaultConfiguration	"Override to set more default values"	^ {		#port -> self defaultPort 	}! !!TLWebserver class methodsFor: 'defaults' stamp: '3/1/2025 23:01'!defaultPort	"Return the default server port"		^DefaultPort ifNil: [ DefaultPort := 8080 ]! !!TLWebserver class methodsFor: 'defaults' stamp: '3/1/2025 23:01'!defaultPort: anInteger	"Sets the default server port"		DefaultPort := anInteger ! !!TLWebserver class methodsFor: 'defaults' stamp: '3/1/2025 23:01'!defaultServer	"Return the default server"		DefaultServer ifNil: [ self installAsDefaultServer ].	^DefaultServer ! !!TLWebserver class methodsFor: 'defaults' stamp: '3/1/2025 23:01'!defaultServer: aTLWebServer		DefaultServer := aTLWebServer! !!TLWebserver class methodsFor: 'class initialization' stamp: '3/1/2025 23:01'!initialize	DefaultPort := nil.	DefaultServer := nil! !!TLWebserver class methodsFor: 'private' stamp: '3/1/2025 23:01'!installAsDefaultServer	self defaultServer: self new! !!TLWebserver class methodsFor: 'operating' stamp: '3/1/2025 23:01'!openWebbrowser	<script>		| baseURL |	baseURL := 'http://localhost'.	self defaultPort = 80 ifFalse: [ 		baseURL := baseURL , ':' , self defaultPort asString ].	WebBrowser openOn: baseURL! !!TLWebserver class methodsFor: 'running' stamp: '3/1/2025 23:01'!start	"Start the server"	<script>		^self defaultServer start! !!TLWebserver class methodsFor: 'running' stamp: '3/1/2025 23:01'!startOn: aPort	"start on the given port"		self 		defaultPort: aPort;		start! !!TLWebserver class methodsFor: 'running' stamp: '3/1/2025 23:01'!stop	"Stop the server"	<script>		^ self defaultServer stop! !!TLWebserver class methodsFor: 'accessing' stamp: '3/1/2025 23:01'!teapot	^ self defaultServer teapot! !!TLWebserver class methodsFor: 'accessing' stamp: '3/1/2025 23:01'!teapotRefreshed	^ self defaultServer refreshTeapot! !!TLWebserver methodsFor: 'accessing' stamp: '3/1/2025 23:01'!configuration	^ configuration ifNil: [ configuration := self class defaultConfiguration ]! !!TLWebserver methodsFor: 'accessing' stamp: '3/1/2025 23:01'!configuration: anObject	configuration := anObject! !!TLWebserver methodsFor: 'private - initialization' stamp: '3/1/2025 23:01'!initTeapot	teapot := Teapot configure: self configuration! !!TLWebserver methodsFor: 'initialization' stamp: '3/1/2025 23:01'!initialize	super initialize.	self initTeapot! !!TLWebserver methodsFor: 'testing' stamp: '3/1/2025 23:01'!isRunning	^ self teapot server isRunning! !!TLWebserver methodsFor: 'printing' stamp: '3/1/2025 23:01'!printOn: aStream	aStream nextPutAll: 'a '.	aStream nextPutAll: self className.	aStream nextPut: $(.	aStream nextPutAll: (self isRunning ifTrue: [ 'running' ] ifFalse: [ 'stopped' ]).	aStream nextPut: $).	self configuration printOn: aStream.! !!TLWebserver methodsFor: 'initialization' stamp: '3/1/2025 23:01'!refreshTeapot	self teapot server isRunning ifTrue: [ self stop ].	self initTeapot.	^ self teapot! !!TLWebserver methodsFor: 'running' stamp: '3/1/2025 23:01'!start	self teapot start! !!TLWebserver methodsFor: 'running' stamp: '3/1/2025 23:01'!stop	self teapot stop! !!TLWebserver methodsFor: 'accessing' stamp: '3/1/2025 23:01'!teapot	^teapot! !"Tealight-Web-Tools"!!TLRESTApiURLPathBuilderTest commentStamp: '' prior: 0!A test class for TLRESTApiURLPathBuilder!!TLRESTApiURLPathBuilderTest methodsFor: 'utilities' stamp: '3/1/2025 23:01'!buildWith: aBlock returnsPath: expectedPath	| builder |	builder := self defaultTestClass new.	aBlock value: builder.	self assert: builder path equals: expectedPath! !!TLRESTApiURLPathBuilderTest methodsFor: 'private - accessing' stamp: '3/1/2025 23:01'!defaultTestClass	^TLRESTApiURLPathBuilder! !!TLRESTApiURLPathBuilderTest methodsFor: 'running' stamp: '3/1/2025 23:01'!setUp	"Setup the test"	super setUp.	backupAPIPrefix := self defaultTestClass apiPrefix.	self defaultTestClass useStandardPrefix! !!TLRESTApiURLPathBuilderTest methodsFor: 'running' stamp: '3/1/2025 23:01'!tearDown	self defaultTestClass useAPIPrefix: backupAPIPrefix.	super tearDown! !!TLRESTApiURLPathBuilderTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testCustomPrefix	| cls |	cls := self defaultTestClass.	cls useAPIPrefix: '/myapp/api'.	self assert: cls apiPrefix equals: '/myapp/api'! !!TLRESTApiURLPathBuilderTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testEmptyPathBuilding	self buildWith: [ :builder |  ] returnsPath: '/api'! !!TLRESTApiURLPathBuilderTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testFullPathBuilding	self		buildWith: [ :builder | 			builder				apiPrefix: 'myapi';				version: 'v1';				function: 'foo' ]		returnsPath: '/myapi/v1/foo'! !!TLRESTApiURLPathBuilderTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testPrefixedPathBuilding	self		buildWith: [ :builder | 			builder				apiPrefix: 'myPrefix';				version: 'v1' ]		returnsPath: '/myPrefix/v1'! !!TLRESTApiURLPathBuilderTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testSimplePathBuilding	self buildWith: [ :builder |  ] returnsPath: '/api'! !!TLRESTApiURLPathBuilderTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testStandardPrefix	| cls |	cls := self defaultTestClass.	self assert: cls apiPrefix equals: 'api'! !!TLRESTApiURLPathBuilderTest methodsFor: 'tests' stamp: '3/1/2025 23:01'!testVersionedPathBuilding	self		buildWith: [ :builder | builder version: 'v1' ]		returnsPath: '/api/v1'! !"Tealight-Web-Tools-Tests"!Object subclass: #GuildDatabase    instanceVariableNames: 'connection'    classVariableNames: 'Instance'    poolDictionaries: ''    category: 'GuildApp-Database'!!GuildDatabase methodsFor: 'initialize-release' stamp: '3/1/2025 23:27'!initialize    Instance := self new.    Instance connectToDatabase: (Smalltalk imageDirectory / 'guilds.db') fullName.    Instance createTables.    "Return the singleton instance"    ^ Instance! !!GuildDatabase methodsFor: 'initialize-release' stamp: '3/1/2025 23:27' prior: 1133165!initialize    Instance := self new.    Instance connectToDatabase: (Smalltalk imageDirectory / 'guilds.db') fullName.    Instance createTables.! !GuildDatabase removeSelector: #initialize!!GuildDatabase methodsFor: 'class initialization' stamp: '3/1/2025 23:27'!initialize    Instance := self new.    Instance connectToDatabase: (Smalltalk imageDirectory / 'guilds.db') fullName.    Instance createTables.! !GuildDatabase removeSelector: #initialize!!GuildDatabase methodsFor: 'nil' stamp: '3/1/2025 23:31'!initialize    super initialize.    dbFile := (Smalltalk imageDirectory / 'guilds.db') fullName.    connection := SQLite3Connection on: dbFile.    connection open.    self createTables! !!GuildDatabase methodsFor: 'initialization' stamp: '3/1/2025 23:32'!createTables    "Table for guild resources"	connection execute: 'CREATE TABLE IF NOT EXISTS resources (    id INTEGER PRIMARY KEY,    name TEXT,    amount INTEGER,    changePerDay INTEGER  );'."Table for guild members"	connection execute: 'CREATE TABLE IF NOT EXISTS members (    id INTEGER PRIMARY KEY,    name TEXT,    role TEXT,    tasks TEXT  );'.! !!GuildDatabase methodsFor: 'initialization' stamp: '3/1/2025 23:33'!connection    ^ connection! !Object subclass: #GuildAPI    instanceVariableNames: 'database'    classVariableNames: ''    poolDictionaries: ''    category: 'GuildApp'!Smalltalk globals removeClassNamed: #AnObsoleteGuildAPI!Object subclass: #GuildAPI    instanceVariableNames: 'database'    classVariableNames: ''    poolDictionaries: ''    category: 'GuildApp'!!GuildAPI methodsFor: 'nil' stamp: '3/1/2025 23:34'!initialize    super initialize.    database := GuildDatabase new.! !!GuildAPI methodsFor: 'nil' stamp: '3/1/2025 23:34'!startServer    | teapot |    teapot := Teapot configure: {        #defaultOutput -> #json.        #port -> 8080.        #bindAddress -> #localhost}.        teapot        GET: '/api/resources' -> [ database connection execute: 'SELECT * FROM resources' ];        POST: '/api/resources' -> [ :request | self createResource: request ];        PUT: '/api/resources/<id>' -> [ :request | self updateResource: request ];        DELETE: '/api/resources/<id>' -> [ :request | self deleteResource: request ];        GET: '/api/members' -> [ database connection execute: 'SELECT * FROM members' ];        POST: '/api/members' -> [ :request | self createMember: request ].        teapot run.! !!GuildAPI methodsFor: 'as yet unclassified' stamp: '3/1/2025 23:43' prior: 1137297!startServer    | teapot |    teapot := Teapot configure: {        #defaultOutput -> #json.        #port -> 8080.        #bindAddress -> #localhost}.        teapot        GET: '/api/resources' -> [ database connection execute: 'SELECT * FROM resources' ];        teapot.! !----QUIT----2025-03-02T00:41:46.513781-05:00 Pharo 12.0 - 64bit (stable).1.image priorSource: 433171!----QUIT----2025-03-02T00:41:46.518121-05:00 Pharo 12.0 - 64bit (stable).1.image priorSource: 569713!